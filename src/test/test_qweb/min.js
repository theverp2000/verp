/* /web/static/lib/es6-promise/es6-promise-polyfill.js defined in bundle 'web.assetsCommon' */ 
/*! * @overview es6-promise - a tiny implementation of Promises/A+. * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald) * @license Licensed under MIT license * See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE * @version v4.2.5+7f2b526d */ (function (global, factory) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global.ES6Promise = factory()); }(this, (function () { 'use strict'; function objectOrFunction(x) { var type = typeof x; return x !== null && (type === 'object' || type === 'function'); } function isFunction(x) { return typeof x === 'function'; } var _isArray = void 0; if (Array.isArray) { _isArray = Array.isArray; } else { _isArray = function (x) { return Object.prototype.toString.call(x) === '[object Array]'; }; } var isArray = _isArray; var len = 0; var vertxNext = void 0; var customSchedulerFn = void 0; var asap = function asap(callback, arg) { queue[len] = callback; queue[len + 1] = arg; len += 2; if (len === 2) { // If len is 2, that means that we need to schedule an async flush. // If additional callbacks are queued before the queue is flushed, they // will be processed by this flush that we are scheduling. if (customSchedulerFn) { customSchedulerFn(flush); } else { scheduleFlush(); } } }; function setScheduler(scheduleFn) { customSchedulerFn = scheduleFn; } function setAsap(asapFn) { asap = asapFn; } var browserWindow = typeof window !== 'undefined' ? window : undefined; var browserGlobal = browserWindow || {}; var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver; var isNode = false; // test for web worker but not in IE10 var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined'; // node function useNextTick() { // node version 0.10.x displays a deprecation warning when nextTick is used recursively // see https://github.com/cujojs/when/issues/410 for details return function () { return process.nextTick(flush); }; } // vertx function useVertxTimer() { if (typeof vertxNext !== 'undefined') { return function () { vertxNext(flush); }; } return useSetTimeout(); } function useMutationObserver() { var iterations = 0; var observer = new BrowserMutationObserver(flush); var node = document.createTextNode(''); observer.observe(node, { characterData: true }); return function () { node.data = iterations = ++iterations % 2; }; } // web worker function useMessageChannel() { var channel = new MessageChannel(); channel.port1.onmessage = flush; return function () { return channel.port2.postMessage(0); }; } function useSetTimeout() { // Store setTimeout reference so es6-promise will be unaffected by // other code modifying setTimeout (like sinon.useFakeTimers()) var globalSetTimeout = setTimeout; return function () { return globalSetTimeout(flush, 1); }; } var queue = new Array(1000); function flush() { for (var i = 0; i < len; i += 2) { var callback = queue[i]; var arg = queue[i + 1]; callback(arg); queue[i] = undefined; queue[i + 1] = undefined; } len = 0; } function attemptVertx() { try { var vertx = Function('return this')().require('vertx'); vertxNext = vertx.runOnLoop || vertx.runOnContext; return useVertxTimer(); } catch (e) { return useSetTimeout(); } } var scheduleFlush = void 0; // Decide what async method to use to triggering processing of queued callbacks: if (isNode) { scheduleFlush = useNextTick(); } else if (BrowserMutationObserver) { scheduleFlush = useMutationObserver(); } else if (isWorker) { scheduleFlush = useMessageChannel(); } else if (browserWindow === undefined && typeof require === 'function') { scheduleFlush = attemptVertx(); } else { scheduleFlush = useSetTimeout(); } function then(onFulfillment, onRejection) { var parent = this; var child = new this.constructor(noop); if (child[PROMISE_ID] === undefined) { makePromise(child); } var _state = parent._state; if (_state) { var callback = arguments[_state - 1]; asap(function () { return invokeCallback(_state, child, callback, parent._result); }); } else { subscribe(parent, child, onFulfillment, onRejection); } return child; } /** `Promise.resolve` returns a promise that will become resolved with the passed `value`. It is shorthand for the following: ```javascript let promise = new Promise(function(resolve, reject){ resolve(1); }); promise.then(function(value){ // value === 1 }); ``` Instead of writing the above, your code now simply becomes the following: ```javascript let promise = Promise.resolve(1); promise.then(function(value){ // value === 1 }); ``` @method resolve @static @param {Any} value value that the returned promise will be resolved with Useful for tooling. @return {Promise} a promise that will become fulfilled with the given `value` */ function resolve$1(object) { /*jshint validthis:true */ var Constructor = this; if (object && typeof object === 'object' && object.constructor === Constructor) { return object; } var promise = new Constructor(noop); resolve(promise, object); return promise; } var PROMISE_ID = Math.random().toString(36).substring(2); function noop() { } var PENDING = void 0; var FULFILLED = 1; var REJECTED = 2; var TRY_CATCH_ERROR = { error: null }; function selfFulfillment() { return new TypeError("You cannot resolve a promise with itself"); } function cannotReturnOwn() { return new TypeError('A promises callback cannot return that same promise.'); } function getThen(promise) { try { return promise.then; } catch (error) { TRY_CATCH_ERROR.error = error; return TRY_CATCH_ERROR; } } function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) { try { then$$1.call(value, fulfillmentHandler, rejectionHandler); } catch (e) { return e; } } function handleForeignThenable(promise, thenable, then$$1) { asap(function (promise) { var sealed = false; var error = tryThen(then$$1, thenable, function (value) { if (sealed) { return; } sealed = true; if (thenable !== value) { resolve(promise, value); } else { fulfill(promise, value); } }, function (reason) { if (sealed) { return; } sealed = true; reject(promise, reason); }, 'Settle: ' + (promise._label || ' unknown promise')); if (!sealed && error) { sealed = true; reject(promise, error); } }, promise); } function handleOwnThenable(promise, thenable) { if (thenable._state === FULFILLED) { fulfill(promise, thenable._result); } else if (thenable._state === REJECTED) { reject(promise, thenable._result); } else { subscribe(thenable, undefined, function (value) { return resolve(promise, value); }, function (reason) { return reject(promise, reason); }); } } function handleMaybeThenable(promise, maybeThenable, then$$1) { if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) { handleOwnThenable(promise, maybeThenable); } else { if (then$$1 === TRY_CATCH_ERROR) { reject(promise, TRY_CATCH_ERROR.error); TRY_CATCH_ERROR.error = null; } else if (then$$1 === undefined) { fulfill(promise, maybeThenable); } else if (isFunction(then$$1)) { handleForeignThenable(promise, maybeThenable, then$$1); } else { fulfill(promise, maybeThenable); } } } function resolve(promise, value) { if (promise === value) { reject(promise, selfFulfillment()); } else if (objectOrFunction(value)) { handleMaybeThenable(promise, value, getThen(value)); } else { fulfill(promise, value); } } function publishRejection(promise) { if (promise._onerror) { promise._onerror(promise._result); } publish(promise); } function fulfill(promise, value) { if (promise._state !== PENDING) { return; } promise._result = value; promise._state = FULFILLED; if (promise._subscribers.length !== 0) { asap(publish, promise); } } function reject(promise, reason) { if (promise._state !== PENDING) { return; } promise._state = REJECTED; promise._result = reason; asap(publishRejection, promise); } function subscribe(parent, child, onFulfillment, onRejection) { var _subscribers = parent._subscribers; var length = _subscribers.length; parent._onerror = null; _subscribers[length] = child; _subscribers[length + FULFILLED] = onFulfillment; _subscribers[length + REJECTED] = onRejection; if (length === 0 && parent._state) { asap(publish, parent); } } function publish(promise) { var subscribers = promise._subscribers; var settled = promise._state; if (subscribers.length === 0) { return; } var child = void 0, callback = void 0, detail = promise._result; for (var i = 0; i < subscribers.length; i += 3) { child = subscribers[i]; callback = subscribers[i + settled]; if (child) { invokeCallback(settled, child, callback, detail); } else { callback(detail); } } promise._subscribers.length = 0; } function tryCatch(callback, detail) { try { return callback(detail); } catch (e) { TRY_CATCH_ERROR.error = e; return TRY_CATCH_ERROR; } } function invokeCallback(settled, promise, callback, detail) { var hasCallback = isFunction(callback), value = void 0, error = void 0, succeeded = void 0, failed = void 0; if (hasCallback) { value = tryCatch(callback, detail); if (value === TRY_CATCH_ERROR) { failed = true; error = value.error; value.error = null; } else { succeeded = true; } if (promise === value) { reject(promise, cannotReturnOwn()); return; } } else { value = detail; succeeded = true; } if (promise._state !== PENDING) { // noop } else if (hasCallback && succeeded) { resolve(promise, value); } else if (failed) { reject(promise, error); } else if (settled === FULFILLED) { fulfill(promise, value); } else if (settled === REJECTED) { reject(promise, value); } } function initializePromise(promise, resolver) { try { resolver(function resolvePromise(value) { resolve(promise, value); }, function rejectPromise(reason) { reject(promise, reason); }); } catch (e) { reject(promise, e); } } var id = 0; function nextId() { return id++; } function makePromise(promise) { promise[PROMISE_ID] = id++; promise._state = undefined; promise._result = undefined; promise._subscribers = []; } function validationError() { return new Error('Array Methods must be provided an Array'); } var Enumerator = function () { function Enumerator(Constructor, input) { this._instanceConstructor = Constructor; this.promise = new Constructor(noop); if (!this.promise[PROMISE_ID]) { makePromise(this.promise); } if (isArray(input)) { this.length = input.length; this._remaining = input.length; this._result = new Array(this.length); if (this.length === 0) { fulfill(this.promise, this._result); } else { this.length = this.length || 0; this._enumerate(input); if (this._remaining === 0) { fulfill(this.promise, this._result); } } } else { reject(this.promise, validationError()); } } Enumerator.prototype._enumerate = function _enumerate(input) { for (var i = 0; this._state === PENDING && i < input.length; i++) { this._eachEntry(input[i], i); } }; Enumerator.prototype._eachEntry = function _eachEntry(entry, i) { var c = this._instanceConstructor; var resolve$$1 = c.resolve; if (resolve$$1 === resolve$1) { var _then = getThen(entry); if (_then === then && entry._state !== PENDING) { this._settledAt(entry._state, i, entry._result); } else if (typeof _then !== 'function') { this._remaining--; this._result[i] = entry; } else if (c === Promise$2) { var promise = new c(noop); handleMaybeThenable(promise, entry, _then); this._willSettleAt(promise, i); } else { this._willSettleAt(new c(function (resolve$$1) { return resolve$$1(entry); }), i); } } else { this._willSettleAt(resolve$$1(entry), i); } }; Enumerator.prototype._settledAt = function _settledAt(state, i, value) { var promise = this.promise; if (promise._state === PENDING) { this._remaining--; if (state === REJECTED) { reject(promise, value); } else { this._result[i] = value; } } if (this._remaining === 0) { fulfill(promise, this._result); } }; Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) { var enumerator = this; subscribe(promise, undefined, function (value) { return enumerator._settledAt(FULFILLED, i, value); }, function (reason) { return enumerator._settledAt(REJECTED, i, reason); }); }; return Enumerator; }(); /** `Promise.all` accepts an array of promises, and returns a new promise which is fulfilled with an array of fulfillment values for the passed promises, or rejected with the reason of the first passed promise to be rejected. It casts all elements of the passed iterable to promises as it runs this algorithm. Example: ```javascript let promise1 = resolve(1); let promise2 = resolve(2); let promise3 = resolve(3); let promises = [ promise1, promise2, promise3 ]; Promise.all(promises).then(function(array){ // The array here would be [ 1, 2, 3 ]; }); ``` If any of the `promises` given to `all` are rejected, the first promise that is rejected will be given as an argument to the returned promises's rejection handler. For example: Example: ```javascript let promise1 = resolve(1); let promise2 = reject(new Error("2")); let promise3 = reject(new Error("3")); let promises = [ promise1, promise2, promise3 ]; Promise.all(promises).then(function(array){ // Code here never runs because there are rejected promises! }, function(error) { // error.message === "2" }); ``` @method all @static @param {Array} entries array of promises @param {String} label optional string for labeling the promise. Useful for tooling. @return {Promise} promise that is fulfilled when all `promises` have been fulfilled, or rejected if any of them become rejected. @static */ function all(entries) { return new Enumerator(this, entries).promise; } /** `Promise.race` returns a new promise which is settled in the same way as the first passed promise to settle. Example: ```javascript let promise1 = new Promise(function(resolve, reject){ setTimeout(function(){ resolve('promise 1'); }, 200); }); let promise2 = new Promise(function(resolve, reject){ setTimeout(function(){ resolve('promise 2'); }, 100); }); Promise.race([promise1, promise2]).then(function(result){ // result === 'promise 2' because it was resolved before promise1 // was resolved. }); ``` `Promise.race` is deterministic in that only the state of the first settled promise matters. For example, even if other promises given to the `promises` array argument are resolved, but the first settled promise has become rejected before the other promises became fulfilled, the returned promise will become rejected: ```javascript let promise1 = new Promise(function(resolve, reject){ setTimeout(function(){ resolve('promise 1'); }, 200); }); let promise2 = new Promise(function(resolve, reject){ setTimeout(function(){ reject(new Error('promise 2')); }, 100); }); Promise.race([promise1, promise2]).then(function(result){ // Code here never runs }, function(reason){ // reason.message === 'promise 2' because promise 2 became rejected before // promise 1 became fulfilled }); ``` An example real-world use case is implementing timeouts: ```javascript Promise.race([ajax('foo.json'), timeout(5000)]) ``` @method race @static @param {Array} promises array of promises to observe Useful for tooling. @return {Promise} a promise which settles in the same way as the first passed promise to settle. */ function race(entries) { /*jshint validthis:true */ var Constructor = this; if (!isArray(entries)) { return new Constructor(function (_, reject) { return reject(new TypeError('You must pass an array to race.')); }); } else { return new Constructor(function (resolve, reject) { var length = entries.length; for (var i = 0; i < length; i++) { Constructor.resolve(entries[i]).then(resolve, reject); } }); } } /** `Promise.reject` returns a promise rejected with the passed `reason`. It is shorthand for the following: ```javascript let promise = new Promise(function(resolve, reject){ reject(new Error('WHOOPS')); }); promise.then(function(value){ // Code here doesn't run because the promise is rejected! }, function(reason){ // reason.message === 'WHOOPS' }); ``` Instead of writing the above, your code now simply becomes the following: ```javascript let promise = Promise.reject(new Error('WHOOPS')); promise.then(function(value){ // Code here doesn't run because the promise is rejected! }, function(reason){ // reason.message === 'WHOOPS' }); ``` @method reject @static @param {Any} reason value that the returned promise will be rejected with. Useful for tooling. @return {Promise} a promise rejected with the given `reason`. */ function reject$1(reason) { /*jshint validthis:true */ var Constructor = this; var promise = new Constructor(noop); reject(promise, reason); return promise; } function needsResolver() { throw new TypeError('You must pass a resolver function as the first argument to the promise constructor'); } function needsNew() { throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function."); } /** Promise objects represent the eventual result of an asynchronous operation. The primary way of interacting with a promise is through its `then` method, which registers callbacks to receive either a promise's eventual value or the reason why the promise cannot be fulfilled. Terminology ----------- - `promise` is an object or function with a `then` method whose behavior conforms to this specification. - `thenable` is an object or function that defines a `then` method. - `value` is any legal JavaScript value (including undefined, a thenable, or a promise). - `exception` is a value that is thrown using the throw statement. - `reason` is a value that indicates why a promise was rejected. - `settled` the final resting state of a promise, fulfilled or rejected. A promise can be in one of three states: pending, fulfilled, or rejected. Promises that are fulfilled have a fulfillment value and are in the fulfilled state. Promises that are rejected have a rejection reason and are in the rejected state. A fulfillment value is never a thenable. Promises can also be said to *resolve* a value. If this value is also a promise, then the original promise's settled state will match the value's settled state. So a promise that *resolves* a promise that rejects will itself reject, and a promise that *resolves* a promise that fulfills will itself fulfill. Basic Usage: ------------ ```js let promise = new Promise(function(resolve, reject) { // on success resolve(value); // on failure reject(reason); }); promise.then(function(value) { // on fulfillment }, function(reason) { // on rejection }); ``` Advanced Usage: --------------- Promises shine when abstracting away asynchronous interactions such as `XMLHttpRequest`s. ```js function getJSON(url) { return new Promise(function(resolve, reject){ let xhr = new XMLHttpRequest(); xhr.open('GET', url); xhr.onreadystatechange = handler; xhr.responseType = 'json'; xhr.setRequestHeader('Accept', 'application/json'); xhr.send(); function handler() { if (this.readyState === this.DONE) { if (this.status === 200) { resolve(this.response); } else { reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']')); } } }; }); } getJSON('/posts.json').then(function(json) { // on fulfillment }, function(reason) { // on rejection }); ``` Unlike callbacks, promises are great composable primitives. ```js Promise.all([ getJSON('/posts'), getJSON('/comments') ]).then(function(values){ values[0] // => postsJSON values[1] // => commentsJSON return values; }); ``` @class Promise @param {Function} resolver Useful for tooling. @constructor */ var Promise$2 = function () { function Promise(resolver) { this[PROMISE_ID] = nextId(); this._result = this._state = undefined; this._subscribers = []; if (noop !== resolver) { typeof resolver !== 'function' && needsResolver(); this instanceof Promise ? initializePromise(this, resolver) : needsNew(); } } /** The primary way of interacting with a promise is through its `then` method, which registers callbacks to receive either a promise's eventual value or the reason why the promise cannot be fulfilled. ```js findUser().then(function(user){ // user is available }, function(reason){ // user is unavailable, and you are given the reason why }); ``` Chaining -------- The return value of `then` is itself a promise. This second, 'downstream' promise is resolved with the return value of the first promise's fulfillment or rejection handler, or rejected if the handler throws an exception. ```js findUser().then(function (user) { return user.name; }, function (reason) { return 'default name'; }).then(function (userName) { // If `findUser` fulfilled, `userName` will be the user's name, otherwise it // will be `'default name'` }); findUser().then(function (user) { throw new Error('Found user, but still unhappy'); }, function (reason) { throw new Error('`findUser` rejected and we're unhappy'); }).then(function (value) { // never reached }, function (reason) { // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'. // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'. }); ``` If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream. ```js findUser().then(function (user) { throw new PedagogicalException('Upstream error'); }).then(function (value) { // never reached }).then(function (value) { // never reached }, function (reason) { // The `PedgagocialException` is propagated all the way down to here }); ``` Assimilation ------------ Sometimes the value you want to propagate to a downstream promise can only be retrieved asynchronously. This can be achieved by returning a promise in the fulfillment or rejection handler. The downstream promise will then be pending until the returned promise is settled. This is called *assimilation*. ```js findUser().then(function (user) { return findCommentsByAuthor(user); }).then(function (comments) { // The user's comments are now available }); ``` If the assimliated promise rejects, then the downstream promise will also reject. ```js findUser().then(function (user) { return findCommentsByAuthor(user); }).then(function (comments) { // If `findCommentsByAuthor` fulfills, we'll have the value here }, function (reason) { // If `findCommentsByAuthor` rejects, we'll have the reason here }); ``` Simple Example -------------- Synchronous Example ```javascript let result; try { result = findResult(); // success } catch(reason) { // failure } ``` Errback Example ```js findResult(function(result, err){ if (err) { // failure } else { // success } }); ``` Promise Example; ```javascript findResult().then(function(result){ // success }, function(reason){ // failure }); ``` Advanced Example -------------- Synchronous Example ```javascript let author, books; try { author = findAuthor(); books = findBooksByAuthor(author); // success } catch(reason) { // failure } ``` Errback Example ```js function foundBooks(books) { } function failure(reason) { } findAuthor(function(author, err){ if (err) { failure(err); // failure } else { try { findBoooksByAuthor(author, function(books, err) { if (err) { failure(err); } else { try { foundBooks(books); } catch(reason) { failure(reason); } } }); } catch(error) { failure(err); } // success } }); ``` Promise Example; ```javascript findAuthor(). then(findBooksByAuthor). then(function(books){ // found books }).catch(function(reason){ // something went wrong }); ``` @method then @param {Function} onFulfilled @param {Function} onRejected Useful for tooling. @return {Promise} */ /** `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same as the catch block of a try/catch statement. ```js function findAuthor(){ throw new Error('couldn't find that author'); } // synchronous try { findAuthor(); } catch(reason) { // something went wrong } // async with promises findAuthor().catch(function(reason){ // something went wrong }); ``` @method catch @param {Function} onRejection Useful for tooling. @return {Promise} */ Promise.prototype.catch = function _catch(onRejection) { return this.then(null, onRejection); }; /** `finally` will be invoked regardless of the promise's fate just as native try/catch/finally behaves Synchronous example: ```js findAuthor() { if (Math.random() > 0.5) { throw new Error(); } return new Author(); } try { return findAuthor(); // succeed or fail } catch(error) { return findOtherAuther(); } finally { // always runs // doesn't affect the return value } ``` Asynchronous example: ```js findAuthor().catch(function(reason){ return findOtherAuther(); }).finally(function(){ // author was either found, or not }); ``` @method finally @param {Function} callback @return {Promise} */ Promise.prototype.finally = function _finally(callback) { var promise = this; var constructor = promise.constructor; if (isFunction(callback)) { return promise.then(function (value) { return constructor.resolve(callback()).then(function () { return value; }); }, function (reason) { return constructor.resolve(callback()).then(function () { throw reason; }); }); } return promise.then(callback, callback); }; return Promise; }(); Promise$2.prototype.then = then; Promise$2.all = all; Promise$2.race = race; Promise$2.resolve = resolve$1; Promise$2.reject = reject$1; Promise$2._setScheduler = setScheduler; Promise$2._setAsap = setAsap; Promise$2._asap = asap; /*global self*/ function polyfill() { var local = void 0; try { local = Function('return this')(); } catch (e) { throw new Error('polyfill failed because global object is unavailable in this environment'); } var P = local.Promise; if (P) { var promiseToString = null; try { promiseToString = Object.prototype.toString.call(P.resolve()); } catch (e) { // silently ignored } if (promiseToString === '[object Promise]' && !P.cast) { return; } } local.Promise = Promise$2; } // Strange compat.. Promise$2.polyfill = polyfill; Promise$2.Promise = Promise$2; Promise$2.polyfill(); return Promise$2; }))); ; /* /web/static/src/legacy/js/promise_extension.js defined in bundle 'web.assetsCommon' */ /** * This file adds a 'guardedCatch' function to the Promise API. This function * has to be used when we don't want to swallow real errors (crashes), like * 'catch' does (i.e. basically all the time in Verp). We only execute the * 'onRejected' handler if the rejection's reason is not an Error, and we always * return a rejected Promise to let the rejection bubble up (and trigger the * 'unhandledrejection' event). */ (function () { var _catch = Promise.prototype.catch; Promise.prototype.guardedCatch = function (onRejected) { return _catch.call(this, function (reason) { if (!reason || !(reason instanceof Error)) { if (onRejected) { onRejected.call(this, reason); } } return Promise.reject(reason); }); }; })(); ; /* /web/static/src/boot.js defined in bundle 'web.assetsCommon' */ /** *------------------------------------------------------------------------------ * Verp Web Boostrap Code *------------------------------------------------------------------------------ * * Each module can return a promise. In that case, the module is marked as loaded * only when the promise is resolved, and its value is equal to the resolved value. * The module can be rejected (unloaded). This will be logged in the console as info. * * logs: * Missing dependencies: * These modules do not appear in the page. It is possible that the * JavaScript file is not in the page or that the module name is wrong * Failed modules: * A javascript error is detected * Rejected modules: * The module returns a rejected promise. It (and its dependent modules) * is not loaded. * Rejected linked modules: * Modules who depend on a rejected module * Non loaded modules: * Modules who depend on a missing or a failed module * Debug: * Non loaded or failed module informations for debugging */ (function () { "use strict"; var jobUID = Date.now(); var jobs = []; var factories = Object.create(null); var jobDeps = []; var jobPromises = []; var services = Object.create({}); var commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/gm; var cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g; if (!window.verp) { window.verp = {}; } var verp = window.verp; var debug = verp.debug; var didLogInfoResolve; var didLogInfoPromise = new Promise(function (resolve) { didLogInfoResolve = resolve; }); verp.testing = typeof QUnit === "object"; verp.remainingJobs = jobs; verp.__DEBUG__ = { didLogInfo: didLogInfoPromise, getDependencies: function (name, transitive) { var deps = name instanceof Array ? name : [name]; var changed; do { changed = false; jobDeps.forEach(function (dep) { if (deps.indexOf(dep.to) >= 0 && deps.indexOf(dep.from) < 0) { deps.push(dep.from); changed = true; } }); } while (changed && transitive); return deps; }, getDependents: function (name) { return jobDeps .filter(function (dep) { return dep.from === name; }) .map(function (dep) { return dep.to; }); }, getWaitedJobs: function () { return jobs .map(function (job) { return job.name; }) .filter(function (item, index, self) { // uniq return self.indexOf(item) === index; }); }, getMissingJobs: function () { var self = this; var waited = this.getWaitedJobs(); var missing = []; waited.forEach(function (job) { self.getDependencies(job).forEach(function (job) { if (!(job in self.services)) { missing.push(job); } }); }); return missing .filter(function (item, index, self) { return self.indexOf(item) === index; }) .filter(function (item) { return waited.indexOf(item) < 0; }) .filter(function (job) { return !job.error; }); }, getFailedJobs: function () { return jobs.filter(function (job) { return !!job.error; }); }, factories: factories, services: services, }; verp.define = function () { var args = Array.prototype.slice.call(arguments); var name = typeof args[0] === "string" ? args.shift() : "__verp_job" + jobUID++; var factory = args[args.length - 1]; var deps; if (args[0] instanceof Array) { deps = args[0]; } else { deps = []; factory .toString() .replace(commentRegExp, "") .replace(cjsRequireRegExp, function (match, dep) { deps.push(dep); }); } if (!(deps instanceof Array)) { throw new Error("Dependencies should be defined by an array", deps); } if (typeof factory !== "function") { throw new Error("Factory should be defined by a function", factory); } if (typeof name !== "string") { throw new Error("Invalid name definition (should be a string", name); } if (name in factories) { throw new Error("Service " + name + " already defined"); } factory.deps = deps; factories[name] = factory; jobs.push({ name: name, factory: factory, deps: deps, }); deps.forEach(function (dep) { jobDeps.push({ from: dep, to: name }); }); this.processJobs(jobs, services); }; verp.log = function () { var missing = []; var failed = []; var cycle = null; if (jobs.length) { var debugJobs = {}; var rejected = []; var rejectedLinked = []; var job; var jobdep; for (var k = 0; k < jobs.length; k++) { debugJobs[jobs[k].name] = job = { dependencies: jobs[k].deps, dependents: verp.__DEBUG__.getDependents(jobs[k].name), name: jobs[k].name, }; if (jobs[k].error) { job.error = jobs[k].error; } if (jobs[k].rejected) { job.rejected = jobs[k].rejected; rejected.push(job.name); } var deps = verp.__DEBUG__.getDependencies(job.name); for (var i = 0; i < deps.length; i++) { if (job.name !== deps[i] && !(deps[i] in services)) { jobdep = debugJobs[deps[i]]; if (!jobdep && deps[i] in factories) { for (var j = 0; j < jobs.length; j++) { if (jobs[j].name === deps[i]) { jobdep = jobs[j]; break; } } } if (jobdep && jobdep.rejected) { if (!job.rejected) { job.rejected = []; rejectedLinked.push(job.name); } job.rejected.push(deps[i]); } else { if (!job.missing) { job.missing = []; } job.missing.push(deps[i]); } } } } missing = verp.__DEBUG__.getMissingJobs(); failed = verp.__DEBUG__.getFailedJobs(); var unloaded = Object.keys(debugJobs) // Object.values is not supported .map(function (key) { return debugJobs[key]; }) .filter(function (job) { return job.missing; }); if (debug || failed.length || unloaded.length) { var log = window.console[ !failed.length || !unloaded.length ? "info" : "error" ].bind(window.console); log( (failed.length ? "error" : unloaded.length ? "warning" : "info") + ": Some modules could not be started" ); if (missing.length) { log("Missing dependencies: ", missing); } if (failed.length) { log( "Failed modules: ", failed.map(function (fail) { return fail.name; }) ); } if (rejected.length) { log("Rejected modules: ", rejected); } if (rejectedLinked.length) { log("Rejected linked modules: ", rejectedLinked); } if (unloaded.length) { cycle = findCycle(unloaded); if (cycle) { console.error("Cyclic dependencies: " + cycle); } log( "Non loaded modules: ", unloaded.map(function (unload) { return unload.name; }) ); } if (debug && Object.keys(debugJobs).length) { log("Debug: ", debugJobs); } } } verp.__DEBUG__.jsModules = { missing: missing, failed: failed.map((mod) => mod.name), unloaded: unloaded ? unloaded.map((mod) => mod.name) : [], cycle, }; didLogInfoResolve(); }; verp.processJobs = function (jobs, services) { var job; function processJob(job) { var require = makeRequire(job); var jobExec; function onError(e) { job.error = e; console.error(`Error while loading ${job.name}: ${e.message}`, e); } var def = new Promise(function (resolve) { try { jobExec = job.factory.call(null, require); jobs.splice(jobs.indexOf(job), 1); } catch (e) { onError(e); } if (!job.error) { Promise.resolve(jobExec) .then(function (data) { services[job.name] = data; resolve(); verp.processJobs(jobs, services); }) .guardedCatch(function (e) { job.rejected = e || true; jobs.push(job); }) .catch(function (e) { if (e instanceof Error) { onError(e); } resolve(); }); } else { resolve(); } }); jobPromises.push(def); } function isReady(job) { return ( !job.error && !job.rejected && job.factory.deps.every(function (name) { return name in services; }) ); } function makeRequire(job) { var deps = {}; Object.keys(services) .filter(function (item) { return job.deps.indexOf(item) >= 0; }) .forEach(function (key) { deps[key] = services[key]; }); return function require(name) { if (!(name in deps)) { console.error("Undefined dependency: ", name); } return deps[name]; }; } while (jobs.length) { job = undefined; for (var i = 0; i < jobs.length; i++) { if (isReady(jobs[i])) { job = jobs[i]; break; } } if (!job) { break; } processJob(job); } return services; }; // Automatically log errors detected when loading modules window.addEventListener("load", function logWhenLoaded() { setTimeout(function () { var len = jobPromises.length; Promise.all(jobPromises).then(function () { if (len === jobPromises.length) { verp.log(); } else { logWhenLoaded(); } }); }, 5000); }); /** * Visit the list of jobs, and return the first found cycle, if any * * @param {any[]} jobs * @returns {null | string} either a string describing a cycle, or null */ function findCycle(jobs) { // build dependency graph const dependencyGraph = new Map(); for (let job of jobs) { dependencyGraph.set(job.name, job.dependencies); } // helpers function visitJobs(jobs, visited = new Set()) { for (let job of jobs) { const result = visitJob(job, visited); if (result) { return result; } } return null; } function visitJob(job, visited) { if (visited.has(job)) { const jobs = Array.from(visited).concat([job]); const index = jobs.indexOf(job); return jobs .slice(index) .map((j) => `"${j}"`) .join(" => "); } const deps = dependencyGraph.get(job); return deps ? visitJobs(deps, new Set(visited).add(job)) : null; } // visit each root to find cycles return visitJobs(jobs.map((j) => j.name)); } })(); ; /* /web/static/src/session.js defined in bundle 'web.assetsCommon' */ verp.define(@web/session, async function (require) { 'use strict'; let __exports = {}; const session = __exports.session return __exports; }); ; /* /web/static/src/legacy/js/core/cookie_utils.js defined in bundle 'web.assetsCommon' */ verp.define('web.utils.cookies', function (require) { "use strict"; return { /** * Reads the cookie described by the given name. * * @param {string} cookieName * @returns {string} */ getCookie(cookieName) { var cookies = document.cookie ? document.cookie.split('; ') : []; for (var i = 0, l = cookies.length; i < l; i++) { var parts = cookies[i].split('='); var name = parts.shift(); var cookie = parts.join('='); if (cookieName && cookieName === name) { return cookie; } } return ""; }, /** * Creates a cookie. * * @param {string} name the name of the cookie * @param {string} value the value stored in the cookie * @param {integer} ttl time to live of the cookie in millis. -1 to erase the cookie. */ setCookie(name, value, ttl) { ttl = ttl || 24 * 60 * 60 * 365; document.cookie = [ `${name}=${value}`, 'path=/', `max-age=${ttl}`, `expires=${new Date(new Date().getTime() + ttl * 1000).toGMTString()}` ].join(';'); }, }; }); ; /* /web/static/src/legacy/js/core/menu.js defined in bundle 'web.assetsCommon' */ verp.define(@web/legacy/js/core/menu, async function (require) { 'use strict'; let __exports = {}; __exports.initAutoMoreMenu = initAutoMoreMenu; async function initAutoMoreMenu return __exports; }); ; /* /web/static/lib/underscore/underscore.js defined in bundle 'web.assetsCommon' */ // Underscore.js 1.8.2 // http://underscorejs.org // (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors // Underscore may be freely distributed under the MIT license. (function() { // Baseline setup // -------------- // Establish the root object, `window` in the browser, or `exports` on the server. var root = this; // Save the previous value of the `_` variable. var previousUnderscore = root._; // Save bytes in the minified (but not gzipped) version: var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype; // Create quick reference variables for speed access to core prototypes. var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty; // All **ECMAScript 5** native function implementations that we hope to use // are declared here. var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind, nativeCreate = Object.create; // Naked function reference for surrogate-prototype-swapping. var Ctor = function(){}; // Create a safe reference to the Underscore object for use below. var _ = function(obj) { if (obj instanceof _) return obj; if (!(this instanceof _)) return new _(obj); this._wrapped = obj; }; // Export the Underscore object for **Node.js**, with // backwards-compatibility for the old `require()` API. If we're in // the browser, add `_` as a global object. if (typeof exports !== 'undefined') { if (typeof module !== 'undefined' && module.exports) { exports = module.exports = _; } exports._ = _; } else { root._ = _; } // Current version. _.VERSION = '1.8.2'; // Internal function that returns an efficient (for current engines) version // of the passed-in callback, to be repeatedly applied in other Underscore // functions. var optimizeCb = function(func, context, argCount) { if (context === void 0) return func; switch (argCount == null ? 3 : argCount) { case 1: return function(value) { return func.call(context, value); }; case 2: return function(value, other) { return func.call(context, value, other); }; case 3: return function(value, index, collection) { return func.call(context, value, index, collection); }; case 4: return function(accumulator, value, index, collection) { return func.call(context, accumulator, value, index, collection); }; } return function() { return func.apply(context, arguments); }; }; // A mostly-internal function to generate callbacks that can be applied // to each element in a collection, returning the desired result — either // identity, an arbitrary callback, a property matcher, or a property accessor. var cb = function(value, context, argCount) { if (value == null) return _.identity; if (_.isFunction(value)) return optimizeCb(value, context, argCount); if (_.isObject(value)) return _.matcher(value); return _.property(value); }; _.iteratee = function(value, context) { return cb(value, context, Infinity); }; // An internal function for creating assigner functions. var createAssigner = function(keysFunc, undefinedOnly) { return function(obj) { var length = arguments.length; if (length < 2 || obj == null) return obj; for (var index = 1; index < length; index++) { var source = arguments[index], keys = keysFunc(source), l = keys.length; for (var i = 0; i < l; i++) { var key = keys[i]; if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key]; } } return obj; }; }; // An internal function for creating a new object that inherits from another. var baseCreate = function(prototype) { if (!_.isObject(prototype)) return {}; if (nativeCreate) return nativeCreate(prototype); Ctor.prototype = prototype; var result = new Ctor; Ctor.prototype = null; return result; }; // Helper for collection methods to determine whether a collection // should be iterated as an array or as an object // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1; var isArrayLike = function(collection) { var length = collection && collection.length; return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX; }; // Collection Functions // -------------------- // The cornerstone, an `each` implementation, aka `forEach`. // Handles raw objects in addition to array-likes. Treats all // sparse array-likes as if they were dense. _.each = _.forEach = function(obj, iteratee, context) { iteratee = optimizeCb(iteratee, context); var i, length; if (isArrayLike(obj)) { for (i = 0, length = obj.length; i < length; i++) { iteratee(obj[i], i, obj); } } else { var keys = _.keys(obj); for (i = 0, length = keys.length; i < length; i++) { iteratee(obj[keys[i]], keys[i], obj); } } return obj; }; // Return the results of applying the iteratee to each element. _.map = _.collect = function(obj, iteratee, context) { iteratee = cb(iteratee, context); var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, results = Array(length); for (var index = 0; index < length; index++) { var currentKey = keys ? keys[index] : index; results[index] = iteratee(obj[currentKey], currentKey, obj); } return results; }; // Create a reducing function iterating left or right. function createReduce(dir) { // Optimized iterator function as using arguments.length // in the main function will deoptimize the, see #1991. function iterator(obj, iteratee, memo, keys, index, length) { for (; index >= 0 && index < length; index += dir) { var currentKey = keys ? keys[index] : index; memo = iteratee(memo, obj[currentKey], currentKey, obj); } return memo; } return function(obj, iteratee, memo, context) { iteratee = optimizeCb(iteratee, context, 4); var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, index = dir > 0 ? 0 : length - 1; // Determine the initial value if none is provided. if (arguments.length < 3) { memo = obj[keys ? keys[index] : index]; index += dir; } return iterator(obj, iteratee, memo, keys, index, length); }; } // **Reduce** builds up a single result from a list of values, aka `inject`, // or `foldl`. _.reduce = _.foldl = _.inject = createReduce(1); // The right-associative version of reduce, also known as `foldr`. _.reduceRight = _.foldr = createReduce(-1); // Return the first value which passes a truth test. Aliased as `detect`. _.find = _.detect = function(obj, predicate, context) { var key; if (isArrayLike(obj)) { key = _.findIndex(obj, predicate, context); } else { key = _.findKey(obj, predicate, context); } if (key !== void 0 && key !== -1) return obj[key]; }; // Return all the elements that pass a truth test. // Aliased as `select`. _.filter = _.select = function(obj, predicate, context) { var results = []; predicate = cb(predicate, context); _.each(obj, function(value, index, list) { if (predicate(value, index, list)) results.push(value); }); return results; }; // Return all the elements for which a truth test fails. _.reject = function(obj, predicate, context) { return _.filter(obj, _.negate(cb(predicate)), context); }; // Determine whether all of the elements match a truth test. // Aliased as `all`. _.every = _.all = function(obj, predicate, context) { predicate = cb(predicate, context); var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length; for (var index = 0; index < length; index++) { var currentKey = keys ? keys[index] : index; if (!predicate(obj[currentKey], currentKey, obj)) return false; } return true; }; // Determine if at least one element in the object matches a truth test. // Aliased as `any`. _.some = _.any = function(obj, predicate, context) { predicate = cb(predicate, context); var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length; for (var index = 0; index < length; index++) { var currentKey = keys ? keys[index] : index; if (predicate(obj[currentKey], currentKey, obj)) return true; } return false; }; // Determine if the array or object contains a given value (using `===`). // Aliased as `includes` and `include`. _.contains = _.includes = _.include = function(obj, target, fromIndex) { if (!isArrayLike(obj)) obj = _.values(obj); return _.indexOf(obj, target, typeof fromIndex == 'number' && fromIndex) >= 0; }; // Invoke a method (with arguments) on every item in a collection. _.invoke = function(obj, method) { var args = slice.call(arguments, 2); var isFunc = _.isFunction(method); return _.map(obj, function(value) { var func = isFunc ? method : value[method]; return func == null ? func : func.apply(value, args); }); }; // Convenience version of a common use case of `map`: fetching a property. _.pluck = function(obj, key) { return _.map(obj, _.property(key)); }; // Convenience version of a common use case of `filter`: selecting only objects // containing specific `key:value` pairs. _.where = function(obj, attrs) { return _.filter(obj, _.matcher(attrs)); }; // Convenience version of a common use case of `find`: getting the first object // containing specific `key:value` pairs. _.findWhere = function(obj, attrs) { return _.find(obj, _.matcher(attrs)); }; // Return the maximum element (or element-based computation). _.max = function(obj, iteratee, context) { var result = -Infinity, lastComputed = -Infinity, value, computed; if (iteratee == null && obj != null) { obj = isArrayLike(obj) ? obj : _.values(obj); for (var i = 0, length = obj.length; i < length; i++) { value = obj[i]; if (value > result) { result = value; } } } else { iteratee = cb(iteratee, context); _.each(obj, function(value, index, list) { computed = iteratee(value, index, list); if (computed > lastComputed || computed === -Infinity && result === -Infinity) { result = value; lastComputed = computed; } }); } return result; }; // Return the minimum element (or element-based computation). _.min = function(obj, iteratee, context) { var result = Infinity, lastComputed = Infinity, value, computed; if (iteratee == null && obj != null) { obj = isArrayLike(obj) ? obj : _.values(obj); for (var i = 0, length = obj.length; i < length; i++) { value = obj[i]; if (value < result) { result = value; } } } else { iteratee = cb(iteratee, context); _.each(obj, function(value, index, list) { computed = iteratee(value, index, list); if (computed < lastComputed || computed === Infinity && result === Infinity) { result = value; lastComputed = computed; } }); } return result; }; // Shuffle a collection, using the modern version of the // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle). _.shuffle = function(obj) { var set = isArrayLike(obj) ? obj : _.values(obj); var length = set.length; var shuffled = Array(length); for (var index = 0, rand; index < length; index++) { rand = _.random(0, index); if (rand !== index) shuffled[index] = shuffled[rand]; shuffled[rand] = set[index]; } return shuffled; }; // Sample **n** random values from a collection. // If **n** is not specified, returns a single random element. // The internal `guard` argument allows it to work with `map`. _.sample = function(obj, n, guard) { if (n == null || guard) { if (!isArrayLike(obj)) obj = _.values(obj); return obj[_.random(obj.length - 1)]; } return _.shuffle(obj).slice(0, Math.max(0, n)); }; // Sort the object's values by a criterion produced by an iteratee. _.sortBy = function(obj, iteratee, context) { iteratee = cb(iteratee, context); return _.pluck(_.map(obj, function(value, index, list) { return { value: value, index: index, criteria: iteratee(value, index, list) }; }).sort(function(left, right) { var a = left.criteria; var b = right.criteria; if (a !== b) { if (a > b || a === void 0) return 1; if (a < b || b === void 0) return -1; } return left.index - right.index; }), 'value'); }; // An internal function used for aggregate "group by" operations. var group = function(behavior) { return function(obj, iteratee, context) { var result = {}; iteratee = cb(iteratee, context); _.each(obj, function(value, index) { var key = iteratee(value, index, obj); behavior(result, value, key); }); return result; }; }; // Groups the object's values by a criterion. Pass either a string attribute // to group by, or a function that returns the criterion. _.groupby = group(function(result, value, key) { if (_.has(result, key)) result[key].push(value); else result[key] = [value]; }); // Indexes the object's values by a criterion, similar to `groupby`, but for // when you know that your index values will be unique. _.indexBy = group(function(result, value, key) { result[key] = value; }); // Counts instances of an object that group by a certain criterion. Pass // either a string attribute to count by, or a function that returns the // criterion. _.countBy = group(function(result, value, key) { if (_.has(result, key)) result[key]++; else result[key] = 1; }); // Safely create a real, live array from anything iterable. _.toArray = function(obj) { if (!obj) return []; if (_.isArray(obj)) return slice.call(obj); if (isArrayLike(obj)) return _.map(obj, _.identity); return _.values(obj); }; // Return the number of elements in an object. _.size = function(obj) { if (obj == null) return 0; return isArrayLike(obj) ? obj.length : _.keys(obj).length; }; // Split a collection into two arrays: one whose elements all satisfy the given // predicate, and one whose elements all do not satisfy the predicate. _.partition = function(obj, predicate, context) { predicate = cb(predicate, context); var pass = [], fail = []; _.each(obj, function(value, key, obj) { (predicate(value, key, obj) ? pass : fail).push(value); }); return [pass, fail]; }; // Array Functions // --------------- // Get the first element of an array. Passing **n** will return the first N // values in the array. Aliased as `head` and `take`. The **guard** check // allows it to work with `_.map`. _.first = _.head = _.take = function(array, n, guard) { if (array == null) return void 0; if (n == null || guard) return array[0]; return _.initial(array, array.length - n); }; // Returns everything but the last entry of the array. Especially useful on // the arguments object. Passing **n** will return all the values in // the array, excluding the last N. _.initial = function(array, n, guard) { return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n))); }; // Get the last element of an array. Passing **n** will return the last N // values in the array. _.last = function(array, n, guard) { if (array == null) return void 0; if (n == null || guard) return array[array.length - 1]; return _.rest(array, Math.max(0, array.length - n)); }; // Returns everything but the first entry of the array. Aliased as `tail` and `drop`. // Especially useful on the arguments object. Passing an **n** will return // the rest N values in the array. _.rest = _.tail = _.drop = function(array, n, guard) { return slice.call(array, n == null || guard ? 1 : n); }; // Trim out all falsy values from an array. _.compact = function(array) { return _.filter(array, _.identity); }; // Internal implementation of a recursive `flatten` function. var flatten = function(input, shallow, strict, startIndex) { var output = [], idx = 0; for (var i = startIndex || 0, length = input && input.length; i < length; i++) { var value = input[i]; if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) { //flatten current level of array or arguments object if (!shallow) value = flatten(value, shallow, strict); var j = 0, len = value.length; output.length += len; while (j < len) { output[idx++] = value[j++]; } } else if (!strict) { output[idx++] = value; } } return output; }; // Flatten out an array, either recursively (by default), or just one level. _.flatten = function(array, shallow) { return flatten(array, shallow, false); }; // Return a version of the array that does not contain the specified value(s). _.without = function(array) { return _.difference(array, slice.call(arguments, 1)); }; // Produce a duplicate-free version of the array. If the array has already // been sorted, you have the option of using a faster algorithm. // Aliased as `unique`. _.uniq = _.unique = function(array, isSorted, iteratee, context) { if (array == null) return []; if (!_.isBoolean(isSorted)) { context = iteratee; iteratee = isSorted; isSorted = false; } if (iteratee != null) iteratee = cb(iteratee, context); var result = []; var seen = []; for (var i = 0, length = array.length; i < length; i++) { var value = array[i], computed = iteratee ? iteratee(value, i, array) : value; if (isSorted) { if (!i || seen !== computed) result.push(value); seen = computed; } else if (iteratee) { if (!_.contains(seen, computed)) { seen.push(computed); result.push(value); } } else if (!_.contains(result, value)) { result.push(value); } } return result; }; // Produce an array that contains the union: each distinct element from all of // the passed-in arrays. _.union = function() { return _.uniq(flatten(arguments, true, true)); }; // Produce an array that contains every item shared between all the // passed-in arrays. _.intersection = function(array) { if (array == null) return []; var result = []; var argsLength = arguments.length; for (var i = 0, length = array.length; i < length; i++) { var item = array[i]; if (_.contains(result, item)) continue; for (var j = 1; j < argsLength; j++) { if (!_.contains(arguments[j], item)) break; } if (j === argsLength) result.push(item); } return result; }; // Take the difference between one array and a number of other arrays. // Only the elements present in just the first array will remain. _.difference = function(array) { var rest = flatten(arguments, true, true, 1); return _.filter(array, function(value){ return !_.contains(rest, value); }); }; // Zip together multiple lists into a single array -- elements that share // an index go together. _.zip = function() { return _.unzip(arguments); }; // Complement of _.zip. Unzip accepts an array of arrays and groups // each array's elements on shared indices _.unzip = function(array) { var length = array && _.max(array, 'length').length || 0; var result = Array(length); for (var index = 0; index < length; index++) { result[index] = _.pluck(array, index); } return result; }; // Converts lists into objects. Pass either a single array of `[key, value]` // pairs, or two parallel arrays of the same length -- one of keys, and one of // the corresponding values. _.object = function(list, values) { var result = {}; for (var i = 0, length = list && list.length; i < length; i++) { if (values) { result[list[i]] = values[i]; } else { result[list[i][0]] = list[i][1]; } } return result; }; // Return the position of the first occurrence of an item in an array, // or -1 if the item is not included in the array. // If the array is large and already in sort order, pass `true` // for **isSorted** to use binary search. _.indexOf = function(array, item, isSorted) { var i = 0, length = array && array.length; if (typeof isSorted == 'number') { i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted; } else if (isSorted && length) { i = _.sortedIndex(array, item); return array[i] === item ? i : -1; } if (item !== item) { return _.findIndex(slice.call(array, i), _.isNaN); } for (; i < length; i++) if (array[i] === item) return i; return -1; }; _.lastIndexOf = function(array, item, from) { var idx = array ? array.length : 0; if (typeof from == 'number') { idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1); } if (item !== item) { return _.findLastIndex(slice.call(array, 0, idx), _.isNaN); } while (--idx >= 0) if (array[idx] === item) return idx; return -1; }; // Generator function to create the findIndex and findLastIndex functions function createIndexFinder(dir) { return function(array, predicate, context) { predicate = cb(predicate, context); var length = array != null && array.length; var index = dir > 0 ? 0 : length - 1; for (; index >= 0 && index < length; index += dir) { if (predicate(array[index], index, array)) return index; } return -1; }; } // Returns the first index on an array-like that passes a predicate test _.findIndex = createIndexFinder(1); _.findLastIndex = createIndexFinder(-1); // Use a comparator function to figure out the smallest index at which // an object should be inserted so as to maintain order. Uses binary search. _.sortedIndex = function(array, obj, iteratee, context) { iteratee = cb(iteratee, context, 1); var value = iteratee(obj); var low = 0, high = array.length; while (low < high) { var mid = Math.floor((low + high) / 2); if (iteratee(array[mid]) < value) low = mid + 1; else high = mid; } return low; }; // Generate an integer Array containing an arithmetic progression. A port of // the native Javascript `range()` function. See // [the Javascript documentation](http://docs.javascript.org/library/functions.html#range). _.range = function(start, stop, step) { if (arguments.length <= 1) { stop = start || 0; start = 0; } step = step || 1; var length = Math.max(Math.ceil((stop - start) / step), 0); var range = Array(length); for (var idx = 0; idx < length; idx++, start += step) { range[idx] = start; } return range; }; // Function (ahem) Functions // ------------------ // Determines whether to execute a function as a constructor // or a normal function with the provided arguments var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) { if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args); var self = baseCreate(sourceFunc.prototype); var result = sourceFunc.apply(self, args); if (_.isObject(result)) return result; return self; }; // Create a function bound to a given object (assigning `this`, and arguments, // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if // available. _.bind = function(func, context) { if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1)); if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function'); var args = slice.call(arguments, 2); var bound = function() { return executeBound(func, bound, context, this, args.concat(slice.call(arguments))); }; return bound; }; // Partially apply a function by creating a version that has had some of its // arguments pre-filled, without changing its dynamic `this` context. _ acts // as a placeholder, allowing any combination of arguments to be pre-filled. _.partial = function(func) { var boundArgs = slice.call(arguments, 1); var bound = function() { var position = 0, length = boundArgs.length; var args = Array(length); for (var i = 0; i < length; i++) { args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i]; } while (position < arguments.length) args.push(arguments[position++]); return executeBound(func, bound, this, this, args); }; return bound; }; // Bind a number of an object's methods to that object. Remaining arguments // are the method names to be bound. Useful for ensuring that all callbacks // defined on an object belong to it. _.bindAll = function(obj) { var i, length = arguments.length, key; if (length <= 1) throw new Error('bindAll must be passed function names'); for (i = 1; i < length; i++) { key = arguments[i]; obj[key] = _.bind(obj[key], obj); } return obj; }; // Memoize an expensive function by storing its results. _.memoize = function(func, hasher) { var memoize = function(key) { var cache = memoize.cache; var address = '' + (hasher ? hasher.apply(this, arguments) : key); if (!_.has(cache, address)) cache[address] = func.apply(this, arguments); return cache[address]; }; memoize.cache = {}; return memoize; }; // Delays a function for the given number of milliseconds, and then calls // it with the arguments supplied. _.delay = function(func, wait) { var args = slice.call(arguments, 2); return setTimeout(function(){ return func.apply(null, args); }, wait); }; // Defers a function, scheduling it to run after the current call stack has // cleared. _.defer = _.partial(_.delay, _, 1); // Returns a function, that, when invoked, will only be triggered at most once // during a given window of time. Normally, the throttled function will run // as much as it can, without ever going more than once per `wait` duration; // but if you'd like to disable the execution on the leading edge, pass // `{leading: false}`. To disable execution on the trailing edge, ditto. _.throttle = function(func, wait, options) { var context, args, result; var timeout = null; var previous = 0; if (!options) options = {}; var later = function() { previous = options.leading === false ? 0 : _.now(); timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; }; return function() { var now = _.now(); if (!previous && options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining <= 0 || remaining > wait) { if (timeout) { clearTimeout(timeout); timeout = null; } previous = now; result = func.apply(context, args); if (!timeout) context = args = null; } else if (!timeout && options.trailing !== false) { timeout = setTimeout(later, remaining); } return result; }; }; // Returns a function, that, as long as it continues to be invoked, will not // be triggered. The function will be called after it stops being called for // N milliseconds. If `immediate` is passed, trigger the function on the // leading edge, instead of the trailing. _.debounce = function(func, wait, immediate) { var timeout, args, context, timestamp, result; var later = function() { var last = _.now() - timestamp; if (last < wait && last >= 0) { timeout = setTimeout(later, wait - last); } else { timeout = null; if (!immediate) { result = func.apply(context, args); if (!timeout) context = args = null; } } }; return function() { context = this; args = arguments; timestamp = _.now(); var callNow = immediate && !timeout; if (!timeout) timeout = setTimeout(later, wait); if (callNow) { result = func.apply(context, args); context = args = null; } return result; }; }; // Returns the first function passed as an argument to the second, // allowing you to adjust arguments, run code before and after, and // conditionally execute the original function. _.wrap = function(func, wrapper) { return _.partial(wrapper, func); }; // Returns a negated version of the passed-in predicate. _.negate = function(predicate) { return function() { return !predicate.apply(this, arguments); }; }; // Returns a function that is the composition of a list of functions, each // consuming the return value of the function that follows. _.compose = function() { var args = arguments; var start = args.length - 1; return function() { var i = start; var result = args[start].apply(this, arguments); while (i--) result = args[i].call(this, result); return result; }; }; // Returns a function that will only be executed on and after the Nth call. _.after = function(times, func) { return function() { if (--times < 1) { return func.apply(this, arguments); } }; }; // Returns a function that will only be executed up to (but not including) the Nth call. _.before = function(times, func) { var memo; return function() { if (--times > 0) { memo = func.apply(this, arguments); } if (times <= 1) func = null; return memo; }; }; // Returns a function that will be executed at most one time, no matter how // often you call it. Useful for lazy initialization. _.once = _.partial(_.before, 2); // Object Functions // ---------------- // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed. var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString'); var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']; function collectNonEnumProps(obj, keys) { var nonEnumIdx = nonEnumerableProps.length; var constructor = obj.constructor; var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto; // Constructor is a special case. var prop = 'constructor'; if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop); while (nonEnumIdx--) { prop = nonEnumerableProps[nonEnumIdx]; if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) { keys.push(prop); } } } // Retrieve the names of an object's own properties. // Delegates to **ECMAScript 5**'s native `Object.keys` _.keys = function(obj) { if (!_.isObject(obj)) return []; if (nativeKeys) return nativeKeys(obj); var keys = []; for (var key in obj) if (_.has(obj, key)) keys.push(key); // Ahem, IE < 9. if (hasEnumBug) collectNonEnumProps(obj, keys); return keys; }; // Retrieve all the property names of an object. _.allKeys = function(obj) { if (!_.isObject(obj)) return []; var keys = []; for (var key in obj) keys.push(key); // Ahem, IE < 9. if (hasEnumBug) collectNonEnumProps(obj, keys); return keys; }; // Retrieve the values of an object's properties. _.values = function(obj) { var keys = _.keys(obj); var length = keys.length; var values = Array(length); for (var i = 0; i < length; i++) { values[i] = obj[keys[i]]; } return values; }; // Returns the results of applying the iteratee to each element of the object // In contrast to _.map it returns an object _.mapObject = function(obj, iteratee, context) { iteratee = cb(iteratee, context); var keys = _.keys(obj), length = keys.length, results = {}, currentKey; for (var index = 0; index < length; index++) { currentKey = keys[index]; results[currentKey] = iteratee(obj[currentKey], currentKey, obj); } return results; }; // Convert an object into a list of `[key, value]` pairs. _.pairs = function(obj) { var keys = _.keys(obj); var length = keys.length; var pairs = Array(length); for (var i = 0; i < length; i++) { pairs[i] = [keys[i], obj[keys[i]]]; } return pairs; }; // Invert the keys and values of an object. The values must be serializable. _.invert = function(obj) { var result = {}; var keys = _.keys(obj); for (var i = 0, length = keys.length; i < length; i++) { result[obj[keys[i]]] = keys[i]; } return result; }; // Return a sorted list of the function names available on the object. // Aliased as `methods` _.functions = _.methods = function(obj) { var names = []; for (var key in obj) { if (_.isFunction(obj[key])) names.push(key); } return names.sort(); }; // Extend a given object with all the properties in passed-in object(s). _.extend = createAssigner(_.allKeys); // Assigns a given object with all the own properties in the passed-in object(s) // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) _.extendOwn = _.assign = createAssigner(_.keys); // Returns the first key on an object that passes a predicate test _.findKey = function(obj, predicate, context) { predicate = cb(predicate, context); var keys = _.keys(obj), key; for (var i = 0, length = keys.length; i < length; i++) { key = keys[i]; if (predicate(obj[key], key, obj)) return key; } }; // Return a copy of the object only containing the whitelisted properties. _.pick = function(object, oiteratee, context) { var result = {}, obj = object, iteratee, keys; if (obj == null) return result; if (_.isFunction(oiteratee)) { keys = _.allKeys(obj); iteratee = optimizeCb(oiteratee, context); } else { keys = flatten(arguments, false, false, 1); iteratee = function(value, key, obj) { return key in obj; }; obj = Object(obj); } for (var i = 0, length = keys.length; i < length; i++) { var key = keys[i]; var value = obj[key]; if (iteratee(value, key, obj)) result[key] = value; } return result; }; // Return a copy of the object without the blacklisted properties. _.omit = function(obj, iteratee, context) { if (_.isFunction(iteratee)) { iteratee = _.negate(iteratee); } else { var keys = _.map(flatten(arguments, false, false, 1), String); iteratee = function(value, key) { return !_.contains(keys, key); }; } return _.pick(obj, iteratee, context); }; // Fill in a given object with default properties. _.defaults = createAssigner(_.allKeys, true); // Create a (shallow-cloned) duplicate of an object. _.clone = function(obj) { if (!_.isObject(obj)) return obj; return _.isArray(obj) ? obj.slice() : _.extend({}, obj); }; // Invokes interceptor with the obj, and then returns obj. // The primary purpose of this method is to "tap into" a method chain, in // order to perform operations on intermediate results within the chain. _.tap = function(obj, interceptor) { interceptor(obj); return obj; }; // Returns whether an object has a given set of `key:value` pairs. _.isMatch = function(object, attrs) { var keys = _.keys(attrs), length = keys.length; if (object == null) return !length; var obj = Object(object); for (var i = 0; i < length; i++) { var key = keys[i]; if (attrs[key] !== obj[key] || !(key in obj)) return false; } return true; }; // Internal recursive comparison function for `isEqual`. var eq = function(a, b, aStack, bStack) { // Identical objects are equal. `0 === -0`, but they aren't identical. // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal). if (a === b) return a !== 0 || 1 / a === 1 / b; // A strict comparison is necessary because `null == undefined`. if (a == null || b == null) return a === b; // Unwrap any wrapped objects. if (a instanceof _) a = a._wrapped; if (b instanceof _) b = b._wrapped; // Compare `[[Class]]` names. var className = toString.call(a); if (className !== toString.call(b)) return false; switch (className) { // Strings, numbers, regular expressions, dates, and booleans are compared by value. case '[object RegExp]': // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i') case '[object String]': // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is // equivalent to `new String("5")`. return '' + a === '' + b; case '[object Number]': // `NaN`s are equivalent, but non-reflexive. // Object(NaN) is equivalent to NaN if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values. return +a === 0 ? 1 / +a === 1 / b : +a === +b; case '[object Date]': case '[object Boolean]': // Coerce dates and booleans to numeric primitive values. Dates are compared by their // millisecond representations. Note that invalid dates with millisecond representations // of `NaN` are not equivalent. return +a === +b; } var areArrays = className === '[object Array]'; if (!areArrays) { if (typeof a != 'object' || typeof b != 'object') return false; // Objects with different constructors are not equivalent, but `Object`s or `Array`s // from different frames are. var aCtor = a.constructor, bCtor = b.constructor; if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && ('constructor' in a && 'constructor' in b)) { return false; } } // Assume equality for cyclic structures. The algorithm for detecting cyclic // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`. // Initializing stack of traversed objects. // It's done here since we only need them for objects and arrays comparison. aStack = aStack || []; bStack = bStack || []; var length = aStack.length; while (length--) { // Linear search. Performance is inversely proportional to the number of // unique nested structures. if (aStack[length] === a) return bStack[length] === b; } // Add the first object to the stack of traversed objects. aStack.push(a); bStack.push(b); // Recursively compare objects and arrays. if (areArrays) { // Compare array lengths to determine if a deep comparison is necessary. length = a.length; if (length !== b.length) return false; // Deep compare the contents, ignoring non-numeric properties. while (length--) { if (!eq(a[length], b[length], aStack, bStack)) return false; } } else { // Deep compare objects. var keys = _.keys(a), key; length = keys.length; // Ensure that both objects contain the same number of properties before comparing deep equality. if (_.keys(b).length !== length) return false; while (length--) { // Deep compare each member key = keys[length]; if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false; } } // Remove the first object from the stack of traversed objects. aStack.pop(); bStack.pop(); return true; }; // Perform a deep comparison to check if two objects are equal. _.isEqual = function(a, b) { return eq(a, b); }; // Is a given array, string, or object empty? // An "empty" object has no enumerable own-properties. _.isEmpty = function(obj) { if (obj == null) return true; if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0; return _.keys(obj).length === 0; }; // Is a given value a DOM element? _.isElement = function(obj) { return !!(obj && obj.nodeType === 1); }; // Is a given value an array? // Delegates to ECMA5's native Array.isArray _.isArray = nativeIsArray || function(obj) { return toString.call(obj) === '[object Array]'; }; // Is a given variable an object? _.isObject = function(obj) { var type = typeof obj; return type === 'function' || type === 'object' && !!obj; }; // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError. _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) { _['is' + name] = function(obj) { return toString.call(obj) === '[object ' + name + ']'; }; }); // Define a fallback version of the method in browsers (ahem, IE < 9), where // there isn't any inspectable "Arguments" type. if (!_.isArguments(arguments)) { _.isArguments = function(obj) { return _.has(obj, 'callee'); }; } // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8, // IE 11 (#1621), and in Safari 8 (#1929). if (typeof /./ != 'function' && typeof Int8Array != 'object') { _.isFunction = function(obj) { return typeof obj == 'function' || false; }; } // Is a given object a finite number? _.isFinite = function(obj) { return isFinite(obj) && !isNaN(parseFloat(obj)); }; // Is the given value `NaN`? (NaN is the only number which does not equal itself). _.isNaN = function(obj) { return _.isNumber(obj) && obj !== +obj; }; // Is a given value a boolean? _.isBoolean = function(obj) { return obj === true || obj === false || toString.call(obj) === '[object Boolean]'; }; // Is a given value equal to null? _.isNull = function(obj) { return obj === null; }; // Is a given variable undefined? _.isUndefined = function(obj) { return obj === void 0; }; // Shortcut function for checking if an object has a given property directly // on itself (in other words, not on a prototype). _.has = function(obj, key) { return obj != null && hasOwnProperty.call(obj, key); }; // Utility Functions // ----------------- // Run Underscore.js in *noConflict* mode, returning the `_` variable to its // previous owner. Returns a reference to the Underscore object. _.noConflict = function() { root._ = previousUnderscore; return this; }; // Keep the identity function around for default iteratees. _.identity = function(value) { return value; }; // Predicate-generating functions. Often useful outside of Underscore. _.constant = function(value) { return function() { return value; }; }; _.noop = function(){}; _.property = function(key) { return function(obj) { return obj == null ? void 0 : obj[key]; }; }; // Generates a function for a given object that returns a given property. _.propertyOf = function(obj) { return obj == null ? function(){} : function(key) { return obj[key]; }; }; // Returns a predicate for checking whether an object has a given set of // `key:value` pairs. _.matcher = _.matches = function(attrs) { attrs = _.extendOwn({}, attrs); return function(obj) { return _.isMatch(obj, attrs); }; }; // Run a function **n** times. _.times = function(n, iteratee, context) { var accum = Array(Math.max(0, n)); iteratee = optimizeCb(iteratee, context, 1); for (var i = 0; i < n; i++) accum[i] = iteratee(i); return accum; }; // Return a random integer between min and max (inclusive). _.random = function(min, max) { if (max == null) { max = min; min = 0; } return min + Math.floor(Math.random() * (max - min + 1)); }; // A (possibly faster) way to get the current timestamp as an integer. _.now = Date.now || function() { return new Date().getTime(); }; // List of HTML entities for escaping. var escapeMap = { '&': '&', '<': '<', '>': '>', '"': '"', "'": ''', '`': '`' }; var unescapeMap = _.invert(escapeMap); // Functions for escaping and unescaping strings to/from HTML interpolation. var createEscaper = function(map) { var escaper = function(match) { return map[match]; }; // Regexes for identifying a key that needs to be escaped var source = '(?:' + _.keys(map).join('|') + ')'; var testRegexp = RegExp(source); var replaceRegexp = RegExp(source, 'g'); return function(string) { string = string == null ? '' : '' + string; return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string; }; }; _.escape = createEscaper(escapeMap); _.unescape = createEscaper(unescapeMap); // If the value of the named `property` is a function then invoke it with the // `object` as context; otherwise, return it. _.result = function(object, property, fallback) { var value = object == null ? void 0 : object[property]; if (value === void 0) { value = fallback; } return _.isFunction(value) ? value.call(object) : value; }; // Generate a unique integer id (unique within the entire client session). // Useful for temporary DOM ids. var idCounter = 0; _.uniqueId = function(prefix) { var id = ++idCounter + ''; return prefix ? prefix + id : id; }; // By default, Underscore uses ERB-style template delimiters, change the // following template settings to use alternative delimiters. _.templateSettings = { evaluate : /<%([\s\S]+?)%>/g, interpolate : /<%=([\s\S]+?)%>/g, escape : /<%-([\s\S]+?)%>/g }; // When customizing `templateSettings`, if you don't want to define an // interpolation, evaluation or escaping regex, we need one that is // guaranteed not to match. var noMatch = /(.)^/; // Certain characters need to be escaped so that they can be put into a // string literal. var escapes = { "'": "'", '\\': '\\', '\r': 'r', '\n': 'n', '\u2028': 'u2028', '\u2029': 'u2029' }; var escaper = /\\|'|\r|\n|\u2028|\u2029/g; var escapeChar = function(match) { return '\\' + escapes[match]; }; // JavaScript micro-templating, similar to John Resig's implementation. // Underscore templating handles arbitrary delimiters, preserves whitespace, // and correctly escapes quotes within interpolated code. // NB: `oldSettings` only exists for backwards compatibility. _.template = function(text, settings, oldSettings) { if (!settings && oldSettings) settings = oldSettings; settings = _.defaults({}, settings, _.templateSettings); // Combine delimiters into one regular expression via alternation. var matcher = RegExp([ (settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source ].join('|') + '|$', 'g'); // Compile the template source, escaping string literals appropriately. var index = 0; var source = "__p+='"; text.replace(matcher, function(match, escape, interpolate, evaluate, offset) { source += text.slice(index, offset).replace(escaper, escapeChar); index = offset + match.length; if (escape) { source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'"; } else if (interpolate) { source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'"; } else if (evaluate) { source += "';\n" + evaluate + "\n__p+='"; } // Adobe VMs need the match returned to produce the correct offest. return match; }); source += "';\n"; // If a variable is not specified, place data values in local scope. if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n'; source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + 'return __p;\n'; try { var render = new Function(settings.variable || 'obj', '_', source); } catch (e) { e.source = source; throw e; } var template = function(data) { return render.call(this, data, _); }; // Provide the compiled source as a convenience for precompilation. var argument = settings.variable || 'obj'; template.source = 'function(' + argument + '){\n' + source + '}'; return template; }; // Add a "chain" function. Start chaining a wrapped Underscore object. _.chain = function(obj) { var instance = _(obj); instance._chain = true; return instance; }; // OOP // --------------- // If Underscore is called as a function, it returns a wrapped object that // can be used OO-style. This wrapper holds altered versions of all the // underscore functions. Wrapped objects may be chained. // Helper function to continue chaining intermediate results. var result = function(instance, obj) { return instance._chain ? _(obj).chain() : obj; }; // Add your own custom functions to the Underscore object. _.mixin = function(obj) { _.each(_.functions(obj), function(name) { var func = _[name] = obj[name]; _.prototype[name] = function() { var args = [this._wrapped]; push.apply(args, arguments); return result(this, func.apply(_, args)); }; }); }; // Add all of the Underscore functions to the wrapper object. _.mixin(_); // Add all mutator Array functions to the wrapper. _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) { var method = ArrayProto[name]; _.prototype[name] = function() { var obj = this._wrapped; method.apply(obj, arguments); if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0]; return result(this, obj); }; }); // Add all accessor Array functions to the wrapper. _.each(['concat', 'join', 'slice'], function(name) { var method = ArrayProto[name]; _.prototype[name] = function() { return result(this, method.apply(this._wrapped, arguments)); }; }); // Extracts the result from a wrapped and chained object. _.prototype.value = function() { return this._wrapped; }; // Provide unwrapping proxy for some methods used in engine operations // such as arithmetic and JSON stringification. _.prototype.valueOf = _.prototype.toJSON = _.prototype.value; _.prototype.toString = function() { return '' + this._wrapped; }; // AMD registration happens at the end for compatibility with AMD loaders // that may not enforce next-turn semantics on modules. Even though general // practice for AMD registration is to be anonymous, underscore registers // as a named module because, like jQuery, it is a base library that is // popular enough to be bundled in a third party lib, but not be part of // an AMD load request. Those cases could generate an error when an // anonymous define() is called outside of a loader request. if (typeof define === 'function' && define.amd) { define('underscore', [], function() { return _; }); } }.call(this));; /* /web/static/lib/underscore.string/lib/underscore.string.js defined in bundle 'web.assetsCommon' */ // Underscore.string // (c) 2010 Esa-Matti Suuronen // Underscore.string is freely distributable under the terms of the MIT license. // Documentation: https://github.com/epeli/underscore.string // Some code is borrowed from MooTools and Alexandru Marasteanu. // Version '2.3.2' !function(root, String){ 'use strict'; // Defining helper functions. var nativeTrim = String.prototype.trim; var nativeTrimRight = String.prototype.trimRight; var nativeTrimLeft = String.prototype.trimLeft; var parseNumber = function(source) { return source * 1 || 0; }; var strRepeat = function(str, qty){ if (qty < 1) return ''; var result = ''; while (qty > 0) { if (qty & 1) result += str; qty >>= 1, str += str; } return result; }; var slice = [].slice; var defaultToWhiteSpace = function(characters) { if (characters == null) return '\\s'; else if (characters.source) return characters.source; else return '[' + _s.escapeRegExp(characters) + ']'; }; // Helper for toBoolean function boolMatch(s, matchers) { var i, matcher, down = s.toLowerCase(); matchers = [].concat(matchers); for (i = 0; i < matchers.length; i += 1) { matcher = matchers[i]; if (!matcher) continue; if (matcher.test && matcher.test(s)) return true; if (matcher.toLowerCase() === down) return true; } } var escapeChars = { lt: '<', gt: '>', quot: '"', amp: '&', apos: "'" }; var reversedEscapeChars = {}; for(var key in escapeChars) reversedEscapeChars[escapeChars[key]] = key; reversedEscapeChars["'"] = '#39'; // sprintf() for JavaScript 0.7-beta1 // http://www.diveintojavascript.com/projects/javascript-sprintf // // Copyright (c) Alexandru Marasteanu // All rights reserved. var sprintf = (function() { function get_type(variable) { return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase(); } var str_repeat = strRepeat; var str_format = function() { if (!str_format.cache.hasOwnProperty(arguments[0])) { str_format.cache[arguments[0]] = str_format.parse(arguments[0]); } return str_format.format.call(null, str_format.cache[arguments[0]], arguments); }; str_format.format = function(parse_tree, argv) { var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length; for (i = 0; i < tree_length; i++) { node_type = get_type(parse_tree[i]); if (node_type === 'string') { output.push(parse_tree[i]); } else if (node_type === 'array') { match = parse_tree[i]; // convenience purposes only if (match[2]) { // keyword argument arg = argv[cursor]; for (k = 0; k < match[2].length; k++) { if (!arg.hasOwnProperty(match[2][k])) { throw new Error(sprintf('[_.sprintf] property "%s" does not exist', match[2][k])); } arg = arg[match[2][k]]; } } else if (match[1]) { // positional argument (explicit) arg = argv[match[1]]; } else { // positional argument (implicit) arg = argv[cursor++]; } if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) { throw new Error(sprintf('[_.sprintf] expecting number but found %s', get_type(arg))); } switch (match[8]) { case 'b': arg = arg.toString(2); break; case 'c': arg = String.fromCharCode(arg); break; case 'd': arg = parseInt(arg, 10); break; case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break; case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break; case 'o': arg = arg.toString(8); break; case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break; case 'u': arg = Math.abs(arg); break; case 'x': arg = arg.toString(16); break; case 'X': arg = arg.toString(16).toUpperCase(); break; } arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg); pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' '; pad_length = match[6] - String(arg).length; pad = match[6] ? str_repeat(pad_character, pad_length) : ''; output.push(match[5] ? arg + pad : pad + arg); } } return output.join(''); }; str_format.cache = {}; str_format.parse = function(fmt) { var _fmt = fmt, match = [], parse_tree = [], arg_names = 0; while (_fmt) { if ((match = /^[^\x25]+/.exec(_fmt)) !== null) { parse_tree.push(match[0]); } else if ((match = /^\x25{2}/.exec(_fmt)) !== null) { parse_tree.push('%'); } else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) { if (match[2]) { arg_names |= 1; var field_list = [], replacement_field = match[2], field_match = []; if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) { field_list.push(field_match[1]); while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') { if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) { field_list.push(field_match[1]); } else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) { field_list.push(field_match[1]); } else { throw new Error('[_.sprintf] huh?'); } } } else { throw new Error('[_.sprintf] huh?'); } match[2] = field_list; } else { arg_names |= 2; } if (arg_names === 3) { throw new Error('[_.sprintf] mixing positional and named placeholders is not (yet) supported'); } parse_tree.push(match); } else { throw new Error('[_.sprintf] huh?'); } _fmt = _fmt.substring(match[0].length); } return parse_tree; }; return str_format; })(); // Defining underscore.string var _s = { VERSION: '2.3.0', isBlank: function(str){ if (str == null) str = ''; return (/^\s*$/).test(str); }, stripTags: function(str){ if (str == null) return ''; return String(str).replace(/<\/?[^>]+>/g, ''); }, capitalize : function(str){ str = str == null ? '' : String(str); return str.charAt(0).toUpperCase() + str.slice(1); }, chop: function(str, step){ if (str == null) return []; str = String(str); step = ~~step; return step > 0 ? str.match(new RegExp('.{1,' + step + '}', 'g')) : [str]; }, clean: function(str){ return _s.strip(str).replace(/\s+/g, ' '); }, count: function(str, substr){ if (str == null || substr == null) return 0; str = String(str); substr = String(substr); var count = 0, pos = 0, length = substr.length; while (true) { pos = str.indexOf(substr, pos); if (pos === -1) break; count++; pos += length; } return count; }, chars: function(str) { if (str == null) return []; return String(str).split(''); }, swapCase: function(str) { if (str == null) return ''; return String(str).replace(/\S/g, function(c){ return c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase(); }); }, escapeHTML: function(str) { if (str == null) return ''; return String(str).replace(/[&<>"']/g, function(m){ return '&' + reversedEscapeChars[m] + ';'; }); }, unescapeHTML: function(str) { if (str == null) return ''; return String(str).replace(/\&([^;]+);/g, function(entity, entityCode){ var match; if (entityCode in escapeChars) { return escapeChars[entityCode]; } else if (match = entityCode.match(/^#x([\da-fA-F]+)$/)) { return String.fromCharCode(parseInt(match[1], 16)); } else if (match = entityCode.match(/^#(\d+)$/)) { return String.fromCharCode(~~match[1]); } else { return entity; } }); }, escapeRegExp: function(str){ if (str == null) return ''; return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1'); }, splice: function(str, i, howmany, substr){ var arr = _s.chars(str); arr.splice(~~i, ~~howmany, substr); return arr.join(''); }, insert: function(str, i, substr){ return _s.splice(str, i, 0, substr); }, include: function(str, needle){ if (needle === '') return true; if (str == null) return false; return String(str).indexOf(needle) !== -1; }, join: function() { var args = slice.call(arguments), separator = args.shift(); if (separator == null) separator = ''; return args.join(separator); }, lines: function(str) { if (str == null) return []; return String(str).split("\n"); }, reverse: function(str){ return _s.chars(str).reverse().join(''); }, startsWith: function(str, starts){ if (starts === '') return true; if (str == null || starts == null) return false; str = String(str); starts = String(starts); return str.length >= starts.length && str.slice(0, starts.length) === starts; }, endsWith: function(str, ends){ if (ends === '') return true; if (str == null || ends == null) return false; str = String(str); ends = String(ends); return str.length >= ends.length && str.slice(str.length - ends.length) === ends; }, succ: function(str){ if (str == null) return ''; str = String(str); return str.slice(0, -1) + String.fromCharCode(str.charCodeAt(str.length-1) + 1); }, titleize: function(str){ if (str == null) return ''; str = String(str).toLowerCase(); return str.replace(/(?:^|\s|-)\S/g, function(c){ return c.toUpperCase(); }); }, camelize: function(str){ return _s.trim(str).replace(/[-_\s]+(.)?/g, function(match, c){ return c ? c.toUpperCase() : ""; }); }, underscored: function(str){ return _s.trim(str).replace(/([a-z\d])([A-Z]+)/g, '$1_$2').replace(/[-\s]+/g, '_').toLowerCase(); }, dasherize: function(str){ return _s.trim(str).replace(/([A-Z])/g, '-$1').replace(/[-_\s]+/g, '-').toLowerCase(); }, classify: function(str){ return _s.titleize(String(str).replace(/[\W_]/g, ' ')).replace(/\s/g, ''); }, humanize: function(str){ return _s.capitalize(_s.underscored(str).replace(/_id$/,'').replace(/_/g, ' ')); }, trim: function(str, characters){ if (str == null) return ''; if (!characters && nativeTrim) return nativeTrim.call(str); characters = defaultToWhiteSpace(characters); return String(str).replace(new RegExp('\^' + characters + '+|' + characters + '+$', 'g'), ''); }, ltrim: function(str, characters){ if (str == null) return ''; if (!characters && nativeTrimLeft) return nativeTrimLeft.call(str); characters = defaultToWhiteSpace(characters); return String(str).replace(new RegExp('^' + characters + '+'), ''); }, rtrim: function(str, characters){ if (str == null) return ''; if (!characters && nativeTrimRight) return nativeTrimRight.call(str); characters = defaultToWhiteSpace(characters); return String(str).replace(new RegExp(characters + '+$'), ''); }, truncate: function(str, length, truncateStr){ if (str == null) return ''; str = String(str); truncateStr = truncateStr || '...'; length = ~~length; return str.length > length ? str.slice(0, length) + truncateStr : str; }, /** * _s.prune: a more elegant version of truncate * prune extra chars, never leaving a half-chopped word. * @author github.com/rwz */ prune: function(str, length, pruneStr){ if (str == null) return ''; str = String(str); length = ~~length; pruneStr = pruneStr != null ? String(pruneStr) : '...'; if (str.length <= length) return str; var tmpl = function(c){ return c.toUpperCase() !== c.toLowerCase() ? 'A' : ' '; }, template = str.slice(0, length+1).replace(/.(?=\W*\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA' if (template.slice(template.length-2).match(/\w\w/)) template = template.replace(/\s*\S+$/, ''); else template = _s.rtrim(template.slice(0, template.length-1)); return (template+pruneStr).length > str.length ? str : str.slice(0, template.length)+pruneStr; }, words: function(str, delimiter) { if (_s.isBlank(str)) return []; return _s.trim(str, delimiter).split(delimiter || /\s+/); }, pad: function(str, length, padStr, type) { str = str == null ? '' : String(str); length = ~~length; var padlen = 0; if (!padStr) padStr = ' '; else if (padStr.length > 1) padStr = padStr.charAt(0); switch(type) { case 'right': padlen = length - str.length; return str + strRepeat(padStr, padlen); case 'both': padlen = length - str.length; return strRepeat(padStr, Math.ceil(padlen/2)) + str + strRepeat(padStr, Math.floor(padlen/2)); default: // 'left' padlen = length - str.length; return strRepeat(padStr, padlen) + str; } }, lpad: function(str, length, padStr) { return _s.pad(str, length, padStr); }, rpad: function(str, length, padStr) { return _s.pad(str, length, padStr, 'right'); }, lrpad: function(str, length, padStr) { return _s.pad(str, length, padStr, 'both'); }, sprintf: sprintf, vsprintf: function(fmt, argv){ argv.unshift(fmt); return sprintf.apply(null, argv); }, toNumber: function(str, decimals) { if (!str) return 0; str = _s.trim(str); if (!str.match(/^-?\d+(?:\.\d+)?$/)) return NaN; return parseNumber(parseNumber(str).toFixed(~~decimals)); }, numberFormat : function(number, dec, dsep, tsep) { if (isNaN(number) || number == null) return ''; number = number.toFixed(~~dec); tsep = typeof tsep == 'string' ? tsep : ','; var parts = number.split('.'), fnums = parts[0], decimals = parts[1] ? (dsep || '.') + parts[1] : ''; return fnums.replace(/(\d)(?=(?:\d{3})+$)/g, '$1' + tsep) + decimals; }, strRight: function(str, sep){ if (str == null) return ''; str = String(str); sep = sep != null ? String(sep) : sep; var pos = !sep ? -1 : str.indexOf(sep); return ~pos ? str.slice(pos+sep.length, str.length) : str; }, strRightBack: function(str, sep){ if (str == null) return ''; str = String(str); sep = sep != null ? String(sep) : sep; var pos = !sep ? -1 : str.lastIndexOf(sep); return ~pos ? str.slice(pos+sep.length, str.length) : str; }, strLeft: function(str, sep){ if (str == null) return ''; str = String(str); sep = sep != null ? String(sep) : sep; var pos = !sep ? -1 : str.indexOf(sep); return ~pos ? str.slice(0, pos) : str; }, strLeftBack: function(str, sep){ if (str == null) return ''; str += ''; sep = sep != null ? ''+sep : sep; var pos = str.lastIndexOf(sep); return ~pos ? str.slice(0, pos) : str; }, toSentence: function(array, separator, lastSeparator, serial) { separator = separator || ', '; lastSeparator = lastSeparator || ' and '; var a = array.slice(), lastMember = a.pop(); if (array.length > 2 && serial) lastSeparator = _s.rtrim(separator) + lastSeparator; return a.length ? a.join(separator) + lastSeparator + lastMember : lastMember; }, toSentenceSerial: function() { var args = slice.call(arguments); args[3] = true; return _s.toSentence.apply(_s, args); }, slugify: function(str) { if (str == null) return ''; var from = "ąàáäâãåæăćęèéëêìíïîłńòóöôõøśșțùúüûñçżź", to = "aaaaaaaaaceeeeeiiiilnoooooosstuuuunczz", regex = new RegExp(defaultToWhiteSpace(from), 'g'); str = String(str).toLowerCase().replace(regex, function(c){ var index = from.indexOf(c); return to.charAt(index) || '-'; }); return _s.dasherize(str.replace(/[^\w\s-]/g, '')); }, surround: function(str, wrapper) { return [wrapper, str, wrapper].join(''); }, quote: function(str, quoteChar) { return _s.surround(str, quoteChar || '"'); }, unquote: function(str, quoteChar) { quoteChar = quoteChar || '"'; if (str[0] === quoteChar && str[str.length-1] === quoteChar) return str.slice(1,str.length-1); else return str; }, exports: function() { var result = {}; for (var prop in this) { if (!this.hasOwnProperty(prop) || prop.match(/^(?:include|contains|reverse)$/)) continue; result[prop] = this[prop]; } return result; }, repeat: function(str, qty, separator){ if (str == null) return ''; qty = ~~qty; // using faster implementation if separator is not needed; if (separator == null) return strRepeat(String(str), qty); // this one is about 300x slower in Google Chrome for (var repeat = []; qty > 0; repeat[--qty] = str) {} return repeat.join(separator); }, naturalCmp: function(str1, str2){ if (str1 == str2) return 0; if (!str1) return -1; if (!str2) return 1; var cmpRegex = /(\.\d+)|(\d+)|(\D+)/g, tokens1 = String(str1).toLowerCase().match(cmpRegex), tokens2 = String(str2).toLowerCase().match(cmpRegex), count = Math.min(tokens1.length, tokens2.length); for(var i = 0; i < count; i++) { var a = tokens1[i], b = tokens2[i]; if (a !== b){ var num1 = parseInt(a, 10); if (!isNaN(num1)){ var num2 = parseInt(b, 10); if (!isNaN(num2) && num1 - num2) return num1 - num2; } return a < b ? -1 : 1; } } if (tokens1.length === tokens2.length) return tokens1.length - tokens2.length; return str1 < str2 ? -1 : 1; }, levenshtein: function(str1, str2) { if (str1 == null && str2 == null) return 0; if (str1 == null) return String(str2).length; if (str2 == null) return String(str1).length; str1 = String(str1); str2 = String(str2); var current = [], prev, value; for (var i = 0; i <= str2.length; i++) for (var j = 0; j <= str1.length; j++) { if (i && j) if (str1.charAt(j - 1) === str2.charAt(i - 1)) value = prev; else value = Math.min(current[j], current[j - 1], prev) + 1; else value = i + j; prev = current[j]; current[j] = value; } return current.pop(); }, toBoolean: function(str, trueValues, falseValues) { if (typeof str === "number") str = "" + str; if (typeof str !== "string") return !!str; str = _s.trim(str); if (boolMatch(str, trueValues || ["true", "1"])) return true; if (boolMatch(str, falseValues || ["false", "0"])) return false; } }; // Aliases _s.strip = _s.trim; _s.lstrip = _s.ltrim; _s.rstrip = _s.rtrim; _s.center = _s.lrpad; _s.rjust = _s.lpad; _s.ljust = _s.rpad; _s.contains = _s.include; _s.q = _s.quote; _s.toBool = _s.toBoolean; // Exporting // CommonJS module is defined if (typeof exports !== 'undefined') { if (typeof module !== 'undefined' && module.exports) module.exports = _s; exports._s = _s; } // Register as a named module with AMD. if (typeof define === 'function' && define.amd) define('underscore.string', [], function(){ return _s; }); // Integrate with Underscore.js if defined // or create our own underscore object. root._ = root._ || {}; root._.string = root._.str = _s; }(this, String); ; /* /web/static/lib/moment/moment.js defined in bundle 'web.assetsCommon' */ //! moment.js //! version : 2.17.1 //! authors : Tim Wood, Iskren Chernev, Moment.js contributors //! license : MIT //! momentjs.com ;(function (global, factory) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.moment = factory() }(this, (function () { 'use strict'; var hookCallback; function hooks () { return hookCallback.apply(null, arguments); } // This is done to register the method called with moment() // without creating circular dependencies. function setHookCallback (callback) { hookCallback = callback; } function isArray(input) { return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]'; } function isObject(input) { // IE8 will treat undefined and null as object if it wasn't for // input != null return input != null && Object.prototype.toString.call(input) === '[object Object]'; } function isObjectEmpty(obj) { var k; for (k in obj) { // even if its not own property I'd still call it non-empty return false; } return true; } function isNumber(input) { return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]'; } function isDate(input) { return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]'; } function map(arr, fn) { var res = [], i; for (i = 0; i < arr.length; ++i) { res.push(fn(arr[i], i)); } return res; } function hasOwnProp(a, b) { return Object.prototype.hasOwnProperty.call(a, b); } function extend(a, b) { for (var i in b) { if (hasOwnProp(b, i)) { a[i] = b[i]; } } if (hasOwnProp(b, 'toString')) { a.toString = b.toString; } if (hasOwnProp(b, 'valueOf')) { a.valueOf = b.valueOf; } return a; } function createUTC (input, format, locale, strict) { return createLocalOrUTC(input, format, locale, strict, true).utc(); } function defaultParsingFlags() { // We need to deep clone this object. return { empty : false, unusedTokens : [], unusedInput : [], overflow : -2, charsLeftOver : 0, nullInput : false, invalidMonth : null, invalidFormat : false, userInvalidated : false, iso : false, parsedDateParts : [], meridiem : null }; } function getParsingFlags(m) { if (m._pf == null) { m._pf = defaultParsingFlags(); } return m._pf; } var some; if (Array.prototype.some) { some = Array.prototype.some; } else { some = function (fun) { var t = Object(this); var len = t.length >>> 0; for (var i = 0; i < len; i++) { if (i in t && fun.call(this, t[i], i, t)) { return true; } } return false; }; } var some$1 = some; function isValid(m) { if (m._isValid == null) { var flags = getParsingFlags(m); var parsedParts = some$1.call(flags.parsedDateParts, function (i) { return i != null; }); var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || (flags.meridiem && parsedParts)); if (m._strict) { isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined; } if (Object.isFrozen == null || !Object.isFrozen(m)) { m._isValid = isNowValid; } else { return isNowValid; } } return m._isValid; } function createInvalid (flags) { var m = createUTC(NaN); if (flags != null) { extend(getParsingFlags(m), flags); } else { getParsingFlags(m).userInvalidated = true; } return m; } function isUndefined(input) { return input === void 0; } // Plugins that add properties should also add the key here (null value), // so we can properly clone ourselves. var momentProperties = hooks.momentProperties = []; function copyConfig(to, from) { var i, prop, val; if (!isUndefined(from._isAMomentObject)) { to._isAMomentObject = from._isAMomentObject; } if (!isUndefined(from._i)) { to._i = from._i; } if (!isUndefined(from._f)) { to._f = from._f; } if (!isUndefined(from._l)) { to._l = from._l; } if (!isUndefined(from._strict)) { to._strict = from._strict; } if (!isUndefined(from._tzm)) { to._tzm = from._tzm; } if (!isUndefined(from._isUTC)) { to._isUTC = from._isUTC; } if (!isUndefined(from._offset)) { to._offset = from._offset; } if (!isUndefined(from._pf)) { to._pf = getParsingFlags(from); } if (!isUndefined(from._locale)) { to._locale = from._locale; } if (momentProperties.length > 0) { for (i in momentProperties) { prop = momentProperties[i]; val = from[prop]; if (!isUndefined(val)) { to[prop] = val; } } } return to; } var updateInProgress = false; // Moment prototype object function Moment(config) { copyConfig(this, config); this._d = new Date(config._d != null ? config._d.getTime() : NaN); if (!this.isValid()) { this._d = new Date(NaN); } // Prevent infinite loop in case updateOffset creates new moment // objects. if (updateInProgress === false) { updateInProgress = true; hooks.updateOffset(this); updateInProgress = false; } } function isMoment (obj) { return obj instanceof Moment || (obj != null && obj._isAMomentObject != null); } function absFloor (number) { if (number < 0) { // -0 -> 0 return Math.ceil(number) || 0; } else { return Math.floor(number); } } function toInt(argumentForCoercion) { var coercedNumber = +argumentForCoercion, value = 0; if (coercedNumber !== 0 && isFinite(coercedNumber)) { value = absFloor(coercedNumber); } return value; } // compare two arrays, return the number of differences function compareArrays(array1, array2, dontConvert) { var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i; for (i = 0; i < len; i++) { if ((dontConvert && array1[i] !== array2[i]) || (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) { diffs++; } } return diffs + lengthDiff; } function warn(msg) { if (hooks.suppressDeprecationWarnings === false && (typeof console !== 'undefined') && console.warn) { console.warn('Deprecation warning: ' + msg); } } function deprecate(msg, fn) { var firstTime = true; return extend(function () { if (hooks.deprecationHandler != null) { hooks.deprecationHandler(null, msg); } if (firstTime) { var args = []; var arg; for (var i = 0; i < arguments.length; i++) { arg = ''; if (typeof arguments[i] === 'object') { arg += '\n[' + i + '] '; for (var key in arguments[0]) { arg += key + ': ' + arguments[0][key] + ', '; } arg = arg.slice(0, -2); // Remove trailing comma and space } else { arg = arguments[i]; } args.push(arg); } warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack); firstTime = false; } return fn.apply(this, arguments); }, fn); } var deprecations = {}; function deprecateSimple(name, msg) { if (hooks.deprecationHandler != null) { hooks.deprecationHandler(name, msg); } if (!deprecations[name]) { warn(msg); deprecations[name] = true; } } hooks.suppressDeprecationWarnings = false; hooks.deprecationHandler = null; function isFunction(input) { return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]'; } function set (config) { var prop, i; for (i in config) { prop = config[i]; if (isFunction(prop)) { this[i] = prop; } else { this['_' + i] = prop; } } this._config = config; // Lenient ordinal parsing accepts just a number in addition to // number + (possibly) stuff coming from _ordinalParseLenient. this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source); } function mergeConfigs(parentConfig, childConfig) { var res = extend({}, parentConfig), prop; for (prop in childConfig) { if (hasOwnProp(childConfig, prop)) { if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) { res[prop] = {}; extend(res[prop], parentConfig[prop]); extend(res[prop], childConfig[prop]); } else if (childConfig[prop] != null) { res[prop] = childConfig[prop]; } else { delete res[prop]; } } } for (prop in parentConfig) { if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) { // make sure changes to properties don't modify parent config res[prop] = extend({}, res[prop]); } } return res; } function Locale(config) { if (config != null) { this.set(config); } } var keys; if (Object.keys) { keys = Object.keys; } else { keys = function (obj) { var i, res = []; for (i in obj) { if (hasOwnProp(obj, i)) { res.push(i); } } return res; }; } var keys$1 = keys; var defaultCalendar = { sameDay : '[Today at] LT', nextDay : '[Tomorrow at] LT', nextWeek : 'dddd [at] LT', lastDay : '[Yesterday at] LT', lastWeek : '[Last] dddd [at] LT', sameElse : 'L' }; function calendar (key, mom, now) { var output = this._calendar[key] || this._calendar['sameElse']; return isFunction(output) ? output.call(mom, now) : output; } var defaultLongDateFormat = { LTS : 'h:mm:ss A', LT : 'h:mm A', L : 'MM/DD/YYYY', LL : 'MMMM D, YYYY', LLL : 'MMMM D, YYYY h:mm A', LLLL : 'dddd, MMMM D, YYYY h:mm A' }; function longDateFormat (key) { var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()]; if (format || !formatUpper) { return format; } this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) { return val.slice(1); }); return this._longDateFormat[key]; } var defaultInvalidDate = 'Invalid date'; function invalidDate () { return this._invalidDate; } var defaultOrdinal = '%d'; var defaultOrdinalParse = /\d{1,2}/; function ordinal (number) { return this._ordinal.replace('%d', number); } var defaultRelativeTime = { future : 'in %s', past : '%s ago', s : 'a few seconds', m : 'a minute', mm : '%d minutes', h : 'an hour', hh : '%d hours', d : 'a day', dd : '%d days', M : 'a month', MM : '%d months', y : 'a year', yy : '%d years' }; function relativeTime (number, withoutSuffix, string, isFuture) { var output = this._relativeTime[string]; return (isFunction(output)) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number); } function pastFuture (diff, output) { var format = this._relativeTime[diff > 0 ? 'future' : 'past']; return isFunction(format) ? format(output) : format.replace(/%s/i, output); } var aliases = {}; function addUnitAlias (unit, shorthand) { var lowerCase = unit.toLowerCase(); aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit; } function normalizeUnits(units) { return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined; } function normalizeObjectUnits(inputObject) { var normalizedInput = {}, normalizedProp, prop; for (prop in inputObject) { if (hasOwnProp(inputObject, prop)) { normalizedProp = normalizeUnits(prop); if (normalizedProp) { normalizedInput[normalizedProp] = inputObject[prop]; } } } return normalizedInput; } var priorities = {}; function addUnitPriority(unit, priority) { priorities[unit] = priority; } function getPrioritizedUnits(unitsObj) { var units = []; for (var u in unitsObj) { units.push({unit: u, priority: priorities[u]}); } units.sort(function (a, b) { return a.priority - b.priority; }); return units; } function makeGetSet (unit, keepTime) { return function (value) { if (value != null) { set$1(this, unit, value); hooks.updateOffset(this, keepTime); return this; } else { return get(this, unit); } }; } function get (mom, unit) { return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN; } function set$1 (mom, unit, value) { if (mom.isValid()) { mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value); } } // MOMENTS function stringGet (units) { units = normalizeUnits(units); if (isFunction(this[units])) { return this[units](); } return this; } function stringSet (units, value) { if (typeof units === 'object') { units = normalizeObjectUnits(units); var prioritized = getPrioritizedUnits(units); for (var i = 0; i < prioritized.length; i++) { this[prioritized[i].unit](units[prioritized[i].unit]); } } else { units = normalizeUnits(units); if (isFunction(this[units])) { return this[units](value); } } return this; } function zeroFill(number, targetLength, forceSign) { var absNumber = '' + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign = number >= 0; return (sign ? (forceSign ? '+' : '') : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber; } var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g; var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g; var formatFunctions = {}; var formatTokenFunctions = {}; // token: 'M' // padded: ['MM', 2] // ordinal: 'Mo' // callback: function () { this.month() + 1 } function addFormatToken (token, padded, ordinal, callback) { var func = callback; if (typeof callback === 'string') { func = function () { return this[callback](); }; } if (token) { formatTokenFunctions[token] = func; } if (padded) { formatTokenFunctions[padded[0]] = function () { return zeroFill(func.apply(this, arguments), padded[1], padded[2]); }; } if (ordinal) { formatTokenFunctions[ordinal] = function () { return this.localeData().ordinal(func.apply(this, arguments), token); }; } } function removeFormattingTokens(input) { if (input.match(/\[[\s\S]/)) { return input.replace(/^\[|\]$/g, ''); } return input.replace(/\\/g, ''); } function makeFormatFunction(format) { var array = format.match(formattingTokens), i, length; for (i = 0, length = array.length; i < length; i++) { if (formatTokenFunctions[array[i]]) { array[i] = formatTokenFunctions[array[i]]; } else { array[i] = removeFormattingTokens(array[i]); } } return function (mom) { var output = '', i; for (i = 0; i < length; i++) { output += array[i] instanceof Function ? array[i].call(mom, format) : array[i]; } return output; }; } // format date using native date object function formatMoment(m, format) { if (!m.isValid()) { return m.localeData().invalidDate(); } format = expandFormat(format, m.localeData()); formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format); return formatFunctions[format](m); } function expandFormat(format, locale) { var i = 5; function replaceLongDateFormatTokens(input) { return locale.longDateFormat(input) || input; } localFormattingTokens.lastIndex = 0; while (i >= 0 && localFormattingTokens.test(format)) { format = format.replace(localFormattingTokens, replaceLongDateFormatTokens); localFormattingTokens.lastIndex = 0; i -= 1; } return format; } var match1 = /\d/; // 0 - 9 var match2 = /\d\d/; // 00 - 99 var match3 = /\d{3}/; // 000 - 999 var match4 = /\d{4}/; // 0000 - 9999 var match6 = /[+-]?\d{6}/; // -999999 - 999999 var match1to2 = /\d\d?/; // 0 - 99 var match3to4 = /\d\d\d\d?/; // 999 - 9999 var match5to6 = /\d\d\d\d\d\d?/; // 99999 - 999999 var match1to3 = /\d{1,3}/; // 0 - 999 var match1to4 = /\d{1,4}/; // 0 - 9999 var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999 var matchUnsigned = /\d+/; // 0 - inf var matchSigned = /[+-]?\d+/; // -inf - inf var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123 // any word (or two) characters or numbers including two/three word month in arabic. // includes scottish gaelic two word and hyphenated months var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i; var regexes = {}; function addRegexToken (token, regex, strictRegex) { regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) { return (isStrict && strictRegex) ? strictRegex : regex; }; } function getParseRegexForToken (token, config) { if (!hasOwnProp(regexes, token)) { return new RegExp(unescapeFormat(token)); } return regexes[token](config._strict, config._locale); } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript function unescapeFormat(s) { return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) { return p1 || p2 || p3 || p4; })); } function regexEscape(s) { return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'); } var tokens = {}; function addParseToken (token, callback) { var i, func = callback; if (typeof token === 'string') { token = [token]; } if (isNumber(callback)) { func = function (input, array) { array[callback] = toInt(input); }; } for (i = 0; i < token.length; i++) { tokens[token[i]] = func; } } function addWeekParseToken (token, callback) { addParseToken(token, function (input, array, config, token) { config._w = config._w || {}; callback(input, config._w, config, token); }); } function addTimeToArrayFromToken(token, input, config) { if (input != null && hasOwnProp(tokens, token)) { tokens[token](input, config._a, config, token); } } var YEAR = 0; var MONTH = 1; var DATE = 2; var HOUR = 3; var MINUTE = 4; var SECOND = 5; var MILLISECOND = 6; var WEEK = 7; var WEEKDAY = 8; var indexOf; if (Array.prototype.indexOf) { indexOf = Array.prototype.indexOf; } else { indexOf = function (o) { // I know var i; for (i = 0; i < this.length; ++i) { if (this[i] === o) { return i; } } return -1; }; } var indexOf$1 = indexOf; function daysInMonth(year, month) { return new Date(Date.UTC(year, month + 1, 0)).getUTCDate(); } // FORMATTING addFormatToken('M', ['MM', 2], 'Mo', function () { return this.month() + 1; }); addFormatToken('MMM', 0, 0, function (format) { return this.localeData().monthsShort(this, format); }); addFormatToken('MMMM', 0, 0, function (format) { return this.localeData().months(this, format); }); // ALIASES addUnitAlias('month', 'M'); // PRIORITY addUnitPriority('month', 8); // PARSING addRegexToken('M', match1to2); addRegexToken('MM', match1to2, match2); addRegexToken('MMM', function (isStrict, locale) { return locale.monthsShortRegex(isStrict); }); addRegexToken('MMMM', function (isStrict, locale) { return locale.monthsRegex(isStrict); }); addParseToken(['M', 'MM'], function (input, array) { array[MONTH] = toInt(input) - 1; }); addParseToken(['MMM', 'MMMM'], function (input, array, config, token) { var month = config._locale.monthsParse(input, token, config._strict); // if we didn't find a month name, mark the date as invalid. if (month != null) { array[MONTH] = month; } else { getParsingFlags(config).invalidMonth = input; } }); // LOCALES var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/; var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'); function localeMonths (m, format) { if (!m) { return this._months; } return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()]; } var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'); function localeMonthsShort (m, format) { if (!m) { return this._monthsShort; } return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()]; } function handleStrictParse(monthName, format, strict) { var i, ii, mom, llc = monthName.toLocaleLowerCase(); if (!this._monthsParse) { // this is not used this._monthsParse = []; this._longMonthsParse = []; this._shortMonthsParse = []; for (i = 0; i < 12; ++i) { mom = createUTC([2000, i]); this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase(); this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase(); } } if (strict) { if (format === 'MMM') { ii = indexOf$1.call(this._shortMonthsParse, llc); return ii !== -1 ? ii : null; } else { ii = indexOf$1.call(this._longMonthsParse, llc); return ii !== -1 ? ii : null; } } else { if (format === 'MMM') { ii = indexOf$1.call(this._shortMonthsParse, llc); if (ii !== -1) { return ii; } ii = indexOf$1.call(this._longMonthsParse, llc); return ii !== -1 ? ii : null; } else { ii = indexOf$1.call(this._longMonthsParse, llc); if (ii !== -1) { return ii; } ii = indexOf$1.call(this._shortMonthsParse, llc); return ii !== -1 ? ii : null; } } } function localeMonthsParse (monthName, format, strict) { var i, mom, regex; if (this._monthsParseExact) { return handleStrictParse.call(this, monthName, format, strict); } if (!this._monthsParse) { this._monthsParse = []; this._longMonthsParse = []; this._shortMonthsParse = []; } // TODO: add sorting // Sorting makes sure if one month (or abbr) is a prefix of another // see sorting in computeMonthsParse for (i = 0; i < 12; i++) { // make the regex if we don't have it already mom = createUTC([2000, i]); if (strict && !this._longMonthsParse[i]) { this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i'); this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i'); } if (!strict && !this._monthsParse[i]) { regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, ''); this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i'); } // test the regex if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) { return i; } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) { return i; } else if (!strict && this._monthsParse[i].test(monthName)) { return i; } } } // MOMENTS function setMonth (mom, value) { var dayOfMonth; if (!mom.isValid()) { // No op return mom; } if (typeof value === 'string') { if (/^\d+$/.test(value)) { value = toInt(value); } else { value = mom.localeData().monthsParse(value); // TODO: Another silent failure? if (!isNumber(value)) { return mom; } } } dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value)); mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth); return mom; } function getSetMonth (value) { if (value != null) { setMonth(this, value); hooks.updateOffset(this, true); return this; } else { return get(this, 'Month'); } } function getDaysInMonth () { return daysInMonth(this.year(), this.month()); } var defaultMonthsShortRegex = matchWord; function monthsShortRegex (isStrict) { if (this._monthsParseExact) { if (!hasOwnProp(this, '_monthsRegex')) { computeMonthsParse.call(this); } if (isStrict) { return this._monthsShortStrictRegex; } else { return this._monthsShortRegex; } } else { if (!hasOwnProp(this, '_monthsShortRegex')) { this._monthsShortRegex = defaultMonthsShortRegex; } return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex; } } var defaultMonthsRegex = matchWord; function monthsRegex (isStrict) { if (this._monthsParseExact) { if (!hasOwnProp(this, '_monthsRegex')) { computeMonthsParse.call(this); } if (isStrict) { return this._monthsStrictRegex; } else { return this._monthsRegex; } } else { if (!hasOwnProp(this, '_monthsRegex')) { this._monthsRegex = defaultMonthsRegex; } return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex; } } function computeMonthsParse () { function cmpLenRev(a, b) { return b.length - a.length; } var shortPieces = [], longPieces = [], mixedPieces = [], i, mom; for (i = 0; i < 12; i++) { // make the regex if we don't have it already mom = createUTC([2000, i]); shortPieces.push(this.monthsShort(mom, '')); longPieces.push(this.months(mom, '')); mixedPieces.push(this.months(mom, '')); mixedPieces.push(this.monthsShort(mom, '')); } // Sorting makes sure if one month (or abbr) is a prefix of another it // will match the longer piece. shortPieces.sort(cmpLenRev); longPieces.sort(cmpLenRev); mixedPieces.sort(cmpLenRev); for (i = 0; i < 12; i++) { shortPieces[i] = regexEscape(shortPieces[i]); longPieces[i] = regexEscape(longPieces[i]); } for (i = 0; i < 24; i++) { mixedPieces[i] = regexEscape(mixedPieces[i]); } this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i'); this._monthsShortRegex = this._monthsRegex; this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i'); this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i'); } // FORMATTING addFormatToken('Y', 0, 0, function () { var y = this.year(); return y <= 9999 ? '' + y : '+' + y; }); addFormatToken(0, ['YY', 2], 0, function () { return this.year() % 100; }); addFormatToken(0, ['YYYY', 4], 0, 'year'); addFormatToken(0, ['YYYYY', 5], 0, 'year'); addFormatToken(0, ['YYYYYY', 6, true], 0, 'year'); // ALIASES addUnitAlias('year', 'y'); // PRIORITIES addUnitPriority('year', 1); // PARSING addRegexToken('Y', matchSigned); addRegexToken('YY', match1to2, match2); addRegexToken('YYYY', match1to4, match4); addRegexToken('YYYYY', match1to6, match6); addRegexToken('YYYYYY', match1to6, match6); addParseToken(['YYYYY', 'YYYYYY'], YEAR); addParseToken('YYYY', function (input, array) { array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input); }); addParseToken('YY', function (input, array) { array[YEAR] = hooks.parseTwoDigitYear(input); }); addParseToken('Y', function (input, array) { array[YEAR] = parseInt(input, 10); }); // HELPERS function daysInYear(year) { return isLeapYear(year) ? 366 : 365; } function isLeapYear(year) { return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0; } // HOOKS hooks.parseTwoDigitYear = function (input) { return toInt(input) + (toInt(input) > 68 ? 1900 : 2000); }; // MOMENTS var getSetYear = makeGetSet('FullYear', true); function getIsLeapYear () { return isLeapYear(this.year()); } function createDate (y, m, d, h, M, s, ms) { //can't just apply() to create a date: //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply var date = new Date(y, m, d, h, M, s, ms); //the date constructor remaps years 0-99 to 1900-1999 if (y < 100 && y >= 0 && isFinite(date.getFullYear())) { date.setFullYear(y); } return date; } function createUTCDate (y) { var date = new Date(Date.UTC.apply(null, arguments)); //the Date.UTC function remaps years 0-99 to 1900-1999 if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) { date.setUTCFullYear(y); } return date; } // start-of-first-week - start-of-year function firstWeekOffset(year, dow, doy) { var // first-week day -- which january is always in the first week (4 for iso, 1 for other) fwd = 7 + dow - doy, // first-week day local weekday -- which local weekday is fwd fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7; return -fwdlw + fwd - 1; } //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday function dayOfYearFromWeeks(year, week, weekday, dow, doy) { var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear; if (dayOfYear <= 0) { resYear = year - 1; resDayOfYear = daysInYear(resYear) + dayOfYear; } else if (dayOfYear > daysInYear(year)) { resYear = year + 1; resDayOfYear = dayOfYear - daysInYear(year); } else { resYear = year; resDayOfYear = dayOfYear; } return { year: resYear, dayOfYear: resDayOfYear }; } function weekOfYear(mom, dow, doy) { var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear; if (week < 1) { resYear = mom.year() - 1; resWeek = week + weeksInYear(resYear, dow, doy); } else if (week > weeksInYear(mom.year(), dow, doy)) { resWeek = week - weeksInYear(mom.year(), dow, doy); resYear = mom.year() + 1; } else { resYear = mom.year(); resWeek = week; } return { week: resWeek, year: resYear }; } function weeksInYear(year, dow, doy) { var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy); return (daysInYear(year) - weekOffset + weekOffsetNext) / 7; } // FORMATTING addFormatToken('w', ['ww', 2], 'wo', 'week'); addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'); // ALIASES addUnitAlias('week', 'w'); addUnitAlias('isoWeek', 'W'); // PRIORITIES addUnitPriority('week', 5); addUnitPriority('isoWeek', 5); // PARSING addRegexToken('w', match1to2); addRegexToken('ww', match1to2, match2); addRegexToken('W', match1to2); addRegexToken('WW', match1to2, match2); addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) { week[token.substr(0, 1)] = toInt(input); }); // HELPERS // LOCALES function localeWeek (mom) { return weekOfYear(mom, this._week.dow, this._week.doy).week; } var defaultLocaleWeek = { dow : 0, // Sunday is the first day of the week. doy : 6 // The week that contains Jan 1st is the first week of the year. }; function localeFirstDayOfWeek () { return this._week.dow; } function localeFirstDayOfYear () { return this._week.doy; } // MOMENTS function getSetWeek (input) { var week = this.localeData().week(this); return input == null ? week : this.add((input - week) * 7, 'd'); } function getSetISOWeek (input) { var week = weekOfYear(this, 1, 4).week; return input == null ? week : this.add((input - week) * 7, 'd'); } // FORMATTING addFormatToken('d', 0, 'do', 'day'); addFormatToken('dd', 0, 0, function (format) { return this.localeData().weekdaysMin(this, format); }); addFormatToken('ddd', 0, 0, function (format) { return this.localeData().weekdaysShort(this, format); }); addFormatToken('dddd', 0, 0, function (format) { return this.localeData().weekdays(this, format); }); addFormatToken('e', 0, 0, 'weekday'); addFormatToken('E', 0, 0, 'isoWeekday'); // ALIASES addUnitAlias('day', 'd'); addUnitAlias('weekday', 'e'); addUnitAlias('isoWeekday', 'E'); // PRIORITY addUnitPriority('day', 11); addUnitPriority('weekday', 11); addUnitPriority('isoWeekday', 11); // PARSING addRegexToken('d', match1to2); addRegexToken('e', match1to2); addRegexToken('E', match1to2); addRegexToken('dd', function (isStrict, locale) { return locale.weekdaysMinRegex(isStrict); }); addRegexToken('ddd', function (isStrict, locale) { return locale.weekdaysShortRegex(isStrict); }); addRegexToken('dddd', function (isStrict, locale) { return locale.weekdaysRegex(isStrict); }); addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) { var weekday = config._locale.weekdaysParse(input, token, config._strict); // if we didn't get a weekday name, mark the date as invalid if (weekday != null) { week.d = weekday; } else { getParsingFlags(config).invalidWeekday = input; } }); addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) { week[token] = toInt(input); }); // HELPERS function parseWeekday(input, locale) { if (typeof input !== 'string') { return input; } if (!isNaN(input)) { return parseInt(input, 10); } input = locale.weekdaysParse(input); if (typeof input === 'number') { return input; } return null; } function parseIsoWeekday(input, locale) { if (typeof input === 'string') { return locale.weekdaysParse(input) % 7 || 7; } return isNaN(input) ? null : input; } // LOCALES var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'); function localeWeekdays (m, format) { if (!m) { return this._weekdays; } return isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()]; } var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'); function localeWeekdaysShort (m) { return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort; } var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'); function localeWeekdaysMin (m) { return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin; } function handleStrictParse$1(weekdayName, format, strict) { var i, ii, mom, llc = weekdayName.toLocaleLowerCase(); if (!this._weekdaysParse) { this._weekdaysParse = []; this._shortWeekdaysParse = []; this._minWeekdaysParse = []; for (i = 0; i < 7; ++i) { mom = createUTC([2000, 1]).day(i); this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase(); this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase(); this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase(); } } if (strict) { if (format === 'dddd') { ii = indexOf$1.call(this._weekdaysParse, llc); return ii !== -1 ? ii : null; } else if (format === 'ddd') { ii = indexOf$1.call(this._shortWeekdaysParse, llc); return ii !== -1 ? ii : null; } else { ii = indexOf$1.call(this._minWeekdaysParse, llc); return ii !== -1 ? ii : null; } } else { if (format === 'dddd') { ii = indexOf$1.call(this._weekdaysParse, llc); if (ii !== -1) { return ii; } ii = indexOf$1.call(this._shortWeekdaysParse, llc); if (ii !== -1) { return ii; } ii = indexOf$1.call(this._minWeekdaysParse, llc); return ii !== -1 ? ii : null; } else if (format === 'ddd') { ii = indexOf$1.call(this._shortWeekdaysParse, llc); if (ii !== -1) { return ii; } ii = indexOf$1.call(this._weekdaysParse, llc); if (ii !== -1) { return ii; } ii = indexOf$1.call(this._minWeekdaysParse, llc); return ii !== -1 ? ii : null; } else { ii = indexOf$1.call(this._minWeekdaysParse, llc); if (ii !== -1) { return ii; } ii = indexOf$1.call(this._weekdaysParse, llc); if (ii !== -1) { return ii; } ii = indexOf$1.call(this._shortWeekdaysParse, llc); return ii !== -1 ? ii : null; } } } function localeWeekdaysParse (weekdayName, format, strict) { var i, mom, regex; if (this._weekdaysParseExact) { return handleStrictParse$1.call(this, weekdayName, format, strict); } if (!this._weekdaysParse) { this._weekdaysParse = []; this._minWeekdaysParse = []; this._shortWeekdaysParse = []; this._fullWeekdaysParse = []; } for (i = 0; i < 7; i++) { // make the regex if we don't have it already mom = createUTC([2000, 1]).day(i); if (strict && !this._fullWeekdaysParse[i]) { this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i'); this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i'); this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i'); } if (!this._weekdaysParse[i]) { regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, ''); this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i'); } // test the regex if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) { return i; } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) { return i; } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) { return i; } else if (!strict && this._weekdaysParse[i].test(weekdayName)) { return i; } } } // MOMENTS function getSetDayOfWeek (input) { if (!this.isValid()) { return input != null ? this : NaN; } var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay(); if (input != null) { input = parseWeekday(input, this.localeData()); return this.add(input - day, 'd'); } else { return day; } } function getSetLocaleDayOfWeek (input) { if (!this.isValid()) { return input != null ? this : NaN; } var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7; return input == null ? weekday : this.add(input - weekday, 'd'); } function getSetISODayOfWeek (input) { if (!this.isValid()) { return input != null ? this : NaN; } // behaves the same as moment#day except // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6) // as a setter, sunday should belong to the previous week. if (input != null) { var weekday = parseIsoWeekday(input, this.localeData()); return this.day(this.day() % 7 ? weekday : weekday - 7); } else { return this.day() || 7; } } var defaultWeekdaysRegex = matchWord; function weekdaysRegex (isStrict) { if (this._weekdaysParseExact) { if (!hasOwnProp(this, '_weekdaysRegex')) { computeWeekdaysParse.call(this); } if (isStrict) { return this._weekdaysStrictRegex; } else { return this._weekdaysRegex; } } else { if (!hasOwnProp(this, '_weekdaysRegex')) { this._weekdaysRegex = defaultWeekdaysRegex; } return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex; } } var defaultWeekdaysShortRegex = matchWord; function weekdaysShortRegex (isStrict) { if (this._weekdaysParseExact) { if (!hasOwnProp(this, '_weekdaysRegex')) { computeWeekdaysParse.call(this); } if (isStrict) { return this._weekdaysShortStrictRegex; } else { return this._weekdaysShortRegex; } } else { if (!hasOwnProp(this, '_weekdaysShortRegex')) { this._weekdaysShortRegex = defaultWeekdaysShortRegex; } return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex; } } var defaultWeekdaysMinRegex = matchWord; function weekdaysMinRegex (isStrict) { if (this._weekdaysParseExact) { if (!hasOwnProp(this, '_weekdaysRegex')) { computeWeekdaysParse.call(this); } if (isStrict) { return this._weekdaysMinStrictRegex; } else { return this._weekdaysMinRegex; } } else { if (!hasOwnProp(this, '_weekdaysMinRegex')) { this._weekdaysMinRegex = defaultWeekdaysMinRegex; } return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex; } } function computeWeekdaysParse () { function cmpLenRev(a, b) { return b.length - a.length; } var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp; for (i = 0; i < 7; i++) { // make the regex if we don't have it already mom = createUTC([2000, 1]).day(i); minp = this.weekdaysMin(mom, ''); shortp = this.weekdaysShort(mom, ''); longp = this.weekdays(mom, ''); minPieces.push(minp); shortPieces.push(shortp); longPieces.push(longp); mixedPieces.push(minp); mixedPieces.push(shortp); mixedPieces.push(longp); } // Sorting makes sure if one weekday (or abbr) is a prefix of another it // will match the longer piece. minPieces.sort(cmpLenRev); shortPieces.sort(cmpLenRev); longPieces.sort(cmpLenRev); mixedPieces.sort(cmpLenRev); for (i = 0; i < 7; i++) { shortPieces[i] = regexEscape(shortPieces[i]); longPieces[i] = regexEscape(longPieces[i]); mixedPieces[i] = regexEscape(mixedPieces[i]); } this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i'); this._weekdaysShortRegex = this._weekdaysRegex; this._weekdaysMinRegex = this._weekdaysRegex; this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i'); this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i'); this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i'); } // FORMATTING function hFormat() { return this.hours() % 12 || 12; } function kFormat() { return this.hours() || 24; } addFormatToken('H', ['HH', 2], 0, 'hour'); addFormatToken('h', ['hh', 2], 0, hFormat); addFormatToken('k', ['kk', 2], 0, kFormat); addFormatToken('hmm', 0, 0, function () { return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2); }); addFormatToken('hmmss', 0, 0, function () { return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2); }); addFormatToken('Hmm', 0, 0, function () { return '' + this.hours() + zeroFill(this.minutes(), 2); }); addFormatToken('Hmmss', 0, 0, function () { return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2); }); function meridiem (token, lowercase) { addFormatToken(token, 0, 0, function () { return this.localeData().meridiem(this.hours(), this.minutes(), lowercase); }); } meridiem('a', true); meridiem('A', false); // ALIASES addUnitAlias('hour', 'h'); // PRIORITY addUnitPriority('hour', 13); // PARSING function matchMeridiem (isStrict, locale) { return locale._meridiemParse; } addRegexToken('a', matchMeridiem); addRegexToken('A', matchMeridiem); addRegexToken('H', match1to2); addRegexToken('h', match1to2); addRegexToken('HH', match1to2, match2); addRegexToken('hh', match1to2, match2); addRegexToken('hmm', match3to4); addRegexToken('hmmss', match5to6); addRegexToken('Hmm', match3to4); addRegexToken('Hmmss', match5to6); addParseToken(['H', 'HH'], HOUR); addParseToken(['a', 'A'], function (input, array, config) { config._isPm = config._locale.isPM(input); config._meridiem = input; }); addParseToken(['h', 'hh'], function (input, array, config) { array[HOUR] = toInt(input); getParsingFlags(config).bigHour = true; }); addParseToken('hmm', function (input, array, config) { var pos = input.length - 2; array[HOUR] = toInt(input.substr(0, pos)); array[MINUTE] = toInt(input.substr(pos)); getParsingFlags(config).bigHour = true; }); addParseToken('hmmss', function (input, array, config) { var pos1 = input.length - 4; var pos2 = input.length - 2; array[HOUR] = toInt(input.substr(0, pos1)); array[MINUTE] = toInt(input.substr(pos1, 2)); array[SECOND] = toInt(input.substr(pos2)); getParsingFlags(config).bigHour = true; }); addParseToken('Hmm', function (input, array, config) { var pos = input.length - 2; array[HOUR] = toInt(input.substr(0, pos)); array[MINUTE] = toInt(input.substr(pos)); }); addParseToken('Hmmss', function (input, array, config) { var pos1 = input.length - 4; var pos2 = input.length - 2; array[HOUR] = toInt(input.substr(0, pos1)); array[MINUTE] = toInt(input.substr(pos1, 2)); array[SECOND] = toInt(input.substr(pos2)); }); // LOCALES function localeIsPM (input) { // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays // Using charAt should be more compatible. return ((input + '').toLowerCase().charAt(0) === 'p'); } var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i; function localeMeridiem (hours, minutes, isLower) { if (hours > 11) { return isLower ? 'pm' : 'PM'; } else { return isLower ? 'am' : 'AM'; } } // MOMENTS // Setting the hour should keep the time, because the user explicitly // specified which hour he wants. So trying to maintain the same hour (in // a new timezone) makes sense. Adding/subtracting hours does not follow // this rule. var getSetHour = makeGetSet('Hours', true); // months // week // weekdays // meridiem var baseConfig = { calendar: defaultCalendar, longDateFormat: defaultLongDateFormat, invalidDate: defaultInvalidDate, ordinal: defaultOrdinal, ordinalParse: defaultOrdinalParse, relativeTime: defaultRelativeTime, months: defaultLocaleMonths, monthsShort: defaultLocaleMonthsShort, week: defaultLocaleWeek, weekdays: defaultLocaleWeekdays, weekdaysMin: defaultLocaleWeekdaysMin, weekdaysShort: defaultLocaleWeekdaysShort, meridiemParse: defaultLocaleMeridiemParse }; // internal storage for locale config files var locales = {}; var localeFamilies = {}; var globalLocale; function normalizeLocale(key) { return key ? key.toLowerCase().replace('_', '-') : key; } // pick the locale from the array // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root function chooseLocale(names) { var i = 0, j, next, locale, split; while (i < names.length) { split = normalizeLocale(names[i]).split('-'); j = split.length; next = normalizeLocale(names[i + 1]); next = next ? next.split('-') : null; while (j > 0) { locale = loadLocale(split.slice(0, j).join('-')); if (locale) { return locale; } if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) { //the next array item is better than a shallower substring of this one break; } j--; } i++; } return null; } function loadLocale(name) { var oldLocale = null; // TODO: Find a better way to register and load all the locales in Node if (!locales[name] && (typeof module !== 'undefined') && module && module.exports) { try { oldLocale = globalLocale._abbr; require('./locale/' + name); // because defineLocale currently also sets the global locale, we // want to undo that for lazy loaded locales getSetGlobalLocale(oldLocale); } catch (e) { } } return locales[name]; } // This function will load locale and then set the global locale. If // no arguments are passed in, it will simply return the current global // locale key. function getSetGlobalLocale (key, values) { var data; if (key) { if (isUndefined(values)) { data = getLocale(key); } else { data = defineLocale(key, values); } if (data) { // moment.duration._locale = moment._locale = data; globalLocale = data; } } return globalLocale._abbr; } function defineLocale (name, config) { if (config !== null) { var parentConfig = baseConfig; config.abbr = name; if (locales[name] != null) { deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'); parentConfig = locales[name]._config; } else if (config.parentLocale != null) { if (locales[config.parentLocale] != null) { parentConfig = locales[config.parentLocale]._config; } else { if (!localeFamilies[config.parentLocale]) { localeFamilies[config.parentLocale] = []; } localeFamilies[config.parentLocale].push({ name: name, config: config }); return null; } } locales[name] = new Locale(mergeConfigs(parentConfig, config)); if (localeFamilies[name]) { localeFamilies[name].forEach(function (x) { defineLocale(x.name, x.config); }); } // backwards compat for now: also set the locale // make sure we set the locale AFTER all child locales have been // created, so we won't end up with the child locale set. getSetGlobalLocale(name); return locales[name]; } else { // useful for testing delete locales[name]; return null; } } function updateLocale(name, config) { if (config != null) { var locale, parentConfig = baseConfig; // MERGE if (locales[name] != null) { parentConfig = locales[name]._config; } config = mergeConfigs(parentConfig, config); locale = new Locale(config); locale.parentLocale = locales[name]; locales[name] = locale; // backwards compat for now: also set the locale getSetGlobalLocale(name); } else { // pass null for config to unupdate, useful for tests if (locales[name] != null) { if (locales[name].parentLocale != null) { locales[name] = locales[name].parentLocale; } else if (locales[name] != null) { delete locales[name]; } } } return locales[name]; } // returns locale data function getLocale (key) { var locale; if (key && key._locale && key._locale._abbr) { key = key._locale._abbr; } if (!key) { return globalLocale; } if (!isArray(key)) { //short-circuit everything else locale = loadLocale(key); if (locale) { return locale; } key = [key]; } return chooseLocale(key); } function listLocales() { return keys$1(locales); } function checkOverflow (m) { var overflow; var a = m._a; if (a && getParsingFlags(m).overflow === -2) { overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1; if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) { overflow = DATE; } if (getParsingFlags(m)._overflowWeeks && overflow === -1) { overflow = WEEK; } if (getParsingFlags(m)._overflowWeekday && overflow === -1) { overflow = WEEKDAY; } getParsingFlags(m).overflow = overflow; } return m; } // iso 8601 regex // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00) var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/; var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/; var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/; var isoDates = [ ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], // YYYYMM is NOT allowed by the standard ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/] ]; // iso time formats and regexes var isoTimes = [ ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/] ]; var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i; // date from iso format function configFromISO(config) { var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat; if (match) { getParsingFlags(config).iso = true; for (i = 0, l = isoDates.length; i < l; i++) { if (isoDates[i][1].exec(match[1])) { dateFormat = isoDates[i][0]; allowTime = isoDates[i][2] !== false; break; } } if (dateFormat == null) { config._isValid = false; return; } if (match[3]) { for (i = 0, l = isoTimes.length; i < l; i++) { if (isoTimes[i][1].exec(match[3])) { // match[2] should be 'T' or space timeFormat = (match[2] || ' ') + isoTimes[i][0]; break; } } if (timeFormat == null) { config._isValid = false; return; } } if (!allowTime && timeFormat != null) { config._isValid = false; return; } if (match[4]) { if (tzRegex.exec(match[4])) { tzFormat = 'Z'; } else { config._isValid = false; return; } } config._f = dateFormat + (timeFormat || '') + (tzFormat || ''); configFromStringAndFormat(config); } else { config._isValid = false; } } // date from iso format or fallback function configFromString(config) { var matched = aspNetJsonRegex.exec(config._i); if (matched !== null) { config._d = new Date(+matched[1]); return; } configFromISO(config); if (config._isValid === false) { delete config._isValid; hooks.createFromInputFallback(config); } } hooks.createFromInputFallback = deprecate( 'value provided is not in a recognized ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) { config._d = new Date(config._i + (config._useUTC ? ' UTC' : '')); } ); // Pick the first defined of two or three arguments. function defaults(a, b, c) { if (a != null) { return a; } if (b != null) { return b; } return c; } function currentDateArray(config) { // hooks is actually the exported moment object var nowValue = new Date(hooks.now()); if (config._useUTC) { return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()]; } return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()]; } // convert an array to a date. // the array should mirror the parameters below // note: all values past the year are optional and will default to the lowest possible value. // [year, month, day , hour, minute, second, millisecond] function configFromArray (config) { var i, date, input = [], currentDate, yearToUse; if (config._d) { return; } currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays if (config._w && config._a[DATE] == null && config._a[MONTH] == null) { dayOfYearFromWeekInfo(config); } //if the day of the year is set, figure out what it is if (config._dayOfYear) { yearToUse = defaults(config._a[YEAR], currentDate[YEAR]); if (config._dayOfYear > daysInYear(yearToUse)) { getParsingFlags(config)._overflowDayOfYear = true; } date = createUTCDate(yearToUse, 0, config._dayOfYear); config._a[MONTH] = date.getUTCMonth(); config._a[DATE] = date.getUTCDate(); } // Default to current date. // * if no year, month, day of month are given, default to today // * if day of month is given, default month and year // * if month is given, default only year // * if year is given, don't default anything for (i = 0; i < 3 && config._a[i] == null; ++i) { config._a[i] = input[i] = currentDate[i]; } // Zero out whatever was not defaulted, including time for (; i < 7; i++) { config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i]; } // Check for 24:00:00.000 if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) { config._nextDay = true; config._a[HOUR] = 0; } config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input); // Apply timezone offset from input. The actual utcOffset can be changed // with parseZone. if (config._tzm != null) { config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm); } if (config._nextDay) { config._a[HOUR] = 24; } } function dayOfYearFromWeekInfo(config) { var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow; w = config._w; if (w.GG != null || w.W != null || w.E != null) { dow = 1; doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on // how we interpret now (local, utc, fixed offset). So create // a now version of current config (take local/utc/offset flags, and // create now). weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year); week = defaults(w.W, 1); weekday = defaults(w.E, 1); if (weekday < 1 || weekday > 7) { weekdayOverflow = true; } } else { dow = config._locale._week.dow; doy = config._locale._week.doy; var curWeek = weekOfYear(createLocal(), dow, doy); weekYear = defaults(w.gg, config._a[YEAR], curWeek.year); // Default to current week. week = defaults(w.w, curWeek.week); if (w.d != null) { // weekday -- low day numbers are considered next week weekday = w.d; if (weekday < 0 || weekday > 6) { weekdayOverflow = true; } } else if (w.e != null) { // local weekday -- counting starts from beginning of week weekday = w.e + dow; if (w.e < 0 || w.e > 6) { weekdayOverflow = true; } } else { // default to beginning of week weekday = dow; } } if (week < 1 || week > weeksInYear(weekYear, dow, doy)) { getParsingFlags(config)._overflowWeeks = true; } else if (weekdayOverflow != null) { getParsingFlags(config)._overflowWeekday = true; } else { temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy); config._a[YEAR] = temp.year; config._dayOfYear = temp.dayOfYear; } } // constant that refers to the ISO standard hooks.ISO_8601 = function () {}; // date from string and format string function configFromStringAndFormat(config) { // TODO: Move this to another part of the creation flow to prevent circular deps if (config._f === hooks.ISO_8601) { configFromISO(config); return; } config._a = []; getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC` var string = '' + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0; tokens = expandFormat(config._f, config._locale).match(formattingTokens) || []; for (i = 0; i < tokens.length; i++) { token = tokens[i]; parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]; // console.log('token', token, 'parsedInput', parsedInput, // 'regex', getParseRegexForToken(token, config)); if (parsedInput) { skipped = string.substr(0, string.indexOf(parsedInput)); if (skipped.length > 0) { getParsingFlags(config).unusedInput.push(skipped); } string = string.slice(string.indexOf(parsedInput) + parsedInput.length); totalParsedInputLength += parsedInput.length; } // don't parse if it's not a known token if (formatTokenFunctions[token]) { if (parsedInput) { getParsingFlags(config).empty = false; } else { getParsingFlags(config).unusedTokens.push(token); } addTimeToArrayFromToken(token, parsedInput, config); } else if (config._strict && !parsedInput) { getParsingFlags(config).unusedTokens.push(token); } } // add remaining unparsed input length to the string getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength; if (string.length > 0) { getParsingFlags(config).unusedInput.push(string); } // clear _12h flag if hour is <= 12 if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) { getParsingFlags(config).bigHour = undefined; } getParsingFlags(config).parsedDateParts = config._a.slice(0); getParsingFlags(config).meridiem = config._meridiem; // handle meridiem config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem); configFromArray(config); checkOverflow(config); } function meridiemFixWrap (locale, hour, meridiem) { var isPm; if (meridiem == null) { // nothing to do return hour; } if (locale.meridiemHour != null) { return locale.meridiemHour(hour, meridiem); } else if (locale.isPM != null) { // Fallback isPm = locale.isPM(meridiem); if (isPm && hour < 12) { hour += 12; } if (!isPm && hour === 12) { hour = 0; } return hour; } else { // this is not supposed to happen return hour; } } // date from string and array of format strings function configFromStringAndArray(config) { var tempConfig, bestMoment, scoreToBeat, i, currentScore; if (config._f.length === 0) { getParsingFlags(config).invalidFormat = true; config._d = new Date(NaN); return; } for (i = 0; i < config._f.length; i++) { currentScore = 0; tempConfig = copyConfig({}, config); if (config._useUTC != null) { tempConfig._useUTC = config._useUTC; } tempConfig._f = config._f[i]; configFromStringAndFormat(tempConfig); if (!isValid(tempConfig)) { continue; } // if there is any input that was not parsed add a penalty for that format currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10; getParsingFlags(tempConfig).score = currentScore; if (scoreToBeat == null || currentScore < scoreToBeat) { scoreToBeat = currentScore; bestMoment = tempConfig; } } extend(config, bestMoment || tempConfig); } function configFromObject(config) { if (config._d) { return; } var i = normalizeObjectUnits(config._i); config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) { return obj && parseInt(obj, 10); }); configFromArray(config); } function createFromConfig (config) { var res = new Moment(checkOverflow(prepareConfig(config))); if (res._nextDay) { // Adding is smart enough around DST res.add(1, 'd'); res._nextDay = undefined; } return res; } function prepareConfig (config) { var input = config._i, format = config._f; config._locale = config._locale || getLocale(config._l); if (input === null || (format === undefined && input === '')) { return createInvalid({nullInput: true}); } if (typeof input === 'string') { config._i = input = config._locale.preparse(input); } if (isMoment(input)) { return new Moment(checkOverflow(input)); } else if (isDate(input)) { config._d = input; } else if (isArray(format)) { configFromStringAndArray(config); } else if (format) { configFromStringAndFormat(config); } else { configFromInput(config); } if (!isValid(config)) { config._d = null; } return config; } function configFromInput(config) { var input = config._i; if (input === undefined) { config._d = new Date(hooks.now()); } else if (isDate(input)) { config._d = new Date(input.valueOf()); } else if (typeof input === 'string') { configFromString(config); } else if (isArray(input)) { config._a = map(input.slice(0), function (obj) { return parseInt(obj, 10); }); configFromArray(config); } else if (typeof(input) === 'object') { configFromObject(config); } else if (isNumber(input)) { // from milliseconds config._d = new Date(input); } else { hooks.createFromInputFallback(config); } } function createLocalOrUTC (input, format, locale, strict, isUTC) { var c = {}; if (locale === true || locale === false) { strict = locale; locale = undefined; } if ((isObject(input) && isObjectEmpty(input)) || (isArray(input) && input.length === 0)) { input = undefined; } // object construction must be done this way. // https://github.com/moment/moment/issues/1423 c._isAMomentObject = true; c._useUTC = c._isUTC = isUTC; c._l = locale; c._i = input; c._f = format; c._strict = strict; return createFromConfig(c); } function createLocal (input, format, locale, strict) { return createLocalOrUTC(input, format, locale, strict, false); } var prototypeMin = deprecate( 'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () { var other = createLocal.apply(null, arguments); if (this.isValid() && other.isValid()) { return other < this ? this : other; } else { return createInvalid(); } } ); var prototypeMax = deprecate( 'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () { var other = createLocal.apply(null, arguments); if (this.isValid() && other.isValid()) { return other > this ? this : other; } else { return createInvalid(); } } ); // Pick a moment m from moments so that m[fn](other) is true for all // other. This relies on the function fn to be transitive. // // moments should either be an array of moment objects or an array, whose // first element is an array of moment objects. function pickBy(fn, moments) { var res, i; if (moments.length === 1 && isArray(moments[0])) { moments = moments[0]; } if (!moments.length) { return createLocal(); } res = moments[0]; for (i = 1; i < moments.length; ++i) { if (!moments[i].isValid() || moments[i][fn](res)) { res = moments[i]; } } return res; } // TODO: Use [].sort instead? function min () { var args = [].slice.call(arguments, 0); return pickBy('isBefore', args); } function max () { var args = [].slice.call(arguments, 0); return pickBy('isAfter', args); } var now = function () { return Date.now ? Date.now() : +(new Date()); }; function Duration (duration) { var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0; // representation for dateAddRemove this._milliseconds = +milliseconds + seconds * 1e3 + // 1000 minutes * 6e4 + // 1000 * 60 hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978 // Because of dateAddRemove treats 24 hours as different from a // day when working around DST, we need to store them separately this._days = +days + weeks * 7; // It is impossible translate months into days without knowing // which months you are are talking about, so we have to store // it separately. this._months = +months + quarters * 3 + years * 12; this._data = {}; this._locale = getLocale(); this._bubble(); } function isDuration (obj) { return obj instanceof Duration; } function absRound (number) { if (number < 0) { return Math.round(-1 * number) * -1; } else { return Math.round(number); } } // FORMATTING function offset (token, separator) { addFormatToken(token, 0, 0, function () { var offset = this.utcOffset(); var sign = '+'; if (offset < 0) { offset = -offset; sign = '-'; } return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2); }); } offset('Z', ':'); offset('ZZ', ''); // PARSING addRegexToken('Z', matchShortOffset); addRegexToken('ZZ', matchShortOffset); addParseToken(['Z', 'ZZ'], function (input, array, config) { config._useUTC = true; config._tzm = offsetFromString(matchShortOffset, input); }); // HELPERS // timezone chunker // '+10:00' > ['10', '00'] // '-1530' > ['-15', '30'] var chunkOffset = /([\+\-]|\d\d)/gi; function offsetFromString(matcher, string) { var matches = (string || '').match(matcher); if (matches === null) { return null; } var chunk = matches[matches.length - 1] || []; var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0]; var minutes = +(parts[1] * 60) + toInt(parts[2]); return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes; } // Return a moment from input, that is local/utc/zone equivalent to model. function cloneWithOffset(input, model) { var res, diff; if (model._isUTC) { res = model.clone(); diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api. res._d.setTime(res._d.valueOf() + diff); hooks.updateOffset(res, false); return res; } else { return createLocal(input).local(); } } function getDateOffset (m) { // On Firefox.24 Date#getTimezoneOffset returns a floating point. // https://github.com/moment/moment/pull/1871 return -Math.round(m._d.getTimezoneOffset() / 15) * 15; } // HOOKS // This function will be called whenever a moment is mutated. // It is intended to keep the offset in sync with the timezone. hooks.updateOffset = function () {}; // MOMENTS // keepLocalTime = true means only change the timezone, without // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]--> // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset // +0200, so we adjust the time as needed, to be valid. // // Keeping the time actually adds/subtracts (one hour) // from the actual represented time. That is why we call updateOffset // a second time. In case it wants us to change the offset again // _changeInProgress == true case, then we have to adjust, because // there is no such time in the given timezone. function getSetOffset (input, keepLocalTime) { var offset = this._offset || 0, localAdjust; if (!this.isValid()) { return input != null ? this : NaN; } if (input != null) { if (typeof input === 'string') { input = offsetFromString(matchShortOffset, input); if (input === null) { return this; } } else if (Math.abs(input) < 16) { input = input * 60; } if (!this._isUTC && keepLocalTime) { localAdjust = getDateOffset(this); } this._offset = input; this._isUTC = true; if (localAdjust != null) { this.add(localAdjust, 'm'); } if (offset !== input) { if (!keepLocalTime || this._changeInProgress) { addSubtract(this, createDuration(input - offset, 'm'), 1, false); } else if (!this._changeInProgress) { this._changeInProgress = true; hooks.updateOffset(this, true); this._changeInProgress = null; } } return this; } else { return this._isUTC ? offset : getDateOffset(this); } } function getSetZone (input, keepLocalTime) { if (input != null) { if (typeof input !== 'string') { input = -input; } this.utcOffset(input, keepLocalTime); return this; } else { return -this.utcOffset(); } } function setOffsetToUTC (keepLocalTime) { return this.utcOffset(0, keepLocalTime); } function setOffsetToLocal (keepLocalTime) { if (this._isUTC) { this.utcOffset(0, keepLocalTime); this._isUTC = false; if (keepLocalTime) { this.subtract(getDateOffset(this), 'm'); } } return this; } function setOffsetToParsedOffset () { if (this._tzm != null) { this.utcOffset(this._tzm); } else if (typeof this._i === 'string') { var tZone = offsetFromString(matchOffset, this._i); if (tZone != null) { this.utcOffset(tZone); } else { this.utcOffset(0, true); } } return this; } function hasAlignedHourOffset (input) { if (!this.isValid()) { return false; } input = input ? createLocal(input).utcOffset() : 0; return (this.utcOffset() - input) % 60 === 0; } function isDaylightSavingTime () { return ( this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset() ); } function isDaylightSavingTimeShifted () { if (!isUndefined(this._isDSTShifted)) { return this._isDSTShifted; } var c = {}; copyConfig(c, this); c = prepareConfig(c); if (c._a) { var other = c._isUTC ? createUTC(c._a) : createLocal(c._a); this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0; } else { this._isDSTShifted = false; } return this._isDSTShifted; } function isLocal () { return this.isValid() ? !this._isUTC : false; } function isUtcOffset () { return this.isValid() ? this._isUTC : false; } function isUtc () { return this.isValid() ? this._isUTC && this._offset === 0 : false; } // ASP.NET json date format regex var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/; // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere // and further modified to allow for strings containing both week and day var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/; function createDuration (input, key) { var duration = input, // matching against regexp is expensive, do it on demand match = null, sign, ret, diffRes; if (isDuration(input)) { duration = { ms : input._milliseconds, d : input._days, M : input._months }; } else if (isNumber(input)) { duration = {}; if (key) { duration[key] = input; } else { duration.milliseconds = input; } } else if (!!(match = aspNetRegex.exec(input))) { sign = (match[1] === '-') ? -1 : 1; duration = { y : 0, d : toInt(match[DATE]) * sign, h : toInt(match[HOUR]) * sign, m : toInt(match[MINUTE]) * sign, s : toInt(match[SECOND]) * sign, ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match }; } else if (!!(match = isoRegex.exec(input))) { sign = (match[1] === '-') ? -1 : 1; duration = { y : parseIso(match[2], sign), M : parseIso(match[3], sign), w : parseIso(match[4], sign), d : parseIso(match[5], sign), h : parseIso(match[6], sign), m : parseIso(match[7], sign), s : parseIso(match[8], sign) }; } else if (duration == null) {// checks for null or undefined duration = {}; } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) { diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to)); duration = {}; duration.ms = diffRes.milliseconds; duration.M = diffRes.months; } ret = new Duration(duration); if (isDuration(input) && hasOwnProp(input, '_locale')) { ret._locale = input._locale; } return ret; } createDuration.fn = Duration.prototype; function parseIso (inp, sign) { // We'd normally use ~~inp for this, but unfortunately it also // converts floats to ints. // inp may be undefined, so careful calling replace on it. var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it return (isNaN(res) ? 0 : res) * sign; } function positiveMomentsDifference(base, other) { var res = {milliseconds: 0, months: 0}; res.months = other.month() - base.month() + (other.year() - base.year()) * 12; if (base.clone().add(res.months, 'M').isAfter(other)) { --res.months; } res.milliseconds = +other - +(base.clone().add(res.months, 'M')); return res; } function momentsDifference(base, other) { var res; if (!(base.isValid() && other.isValid())) { return {milliseconds: 0, months: 0}; } other = cloneWithOffset(other, base); if (base.isBefore(other)) { res = positiveMomentsDifference(base, other); } else { res = positiveMomentsDifference(other, base); res.milliseconds = -res.milliseconds; res.months = -res.months; } return res; } // TODO: remove 'name' arg after deprecation is removed function createAdder(direction, name) { return function (val, period) { var dur, tmp; //invert the arguments, but complain about it if (period !== null && !isNaN(+period)) { deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'); tmp = val; val = period; period = tmp; } val = typeof val === 'string' ? +val : val; dur = createDuration(val, period); addSubtract(this, dur, direction); return this; }; } function addSubtract (mom, duration, isAdding, updateOffset) { var milliseconds = duration._milliseconds, days = absRound(duration._days), months = absRound(duration._months); if (!mom.isValid()) { // No op return; } updateOffset = updateOffset == null ? true : updateOffset; if (milliseconds) { mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding); } if (days) { set$1(mom, 'Date', get(mom, 'Date') + days * isAdding); } if (months) { setMonth(mom, get(mom, 'Month') + months * isAdding); } if (updateOffset) { hooks.updateOffset(mom, days || months); } } var add = createAdder(1, 'add'); var subtract = createAdder(-1, 'subtract'); function getCalendarFormat(myMoment, now) { var diff = myMoment.diff(now, 'days', true); return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse'; } function calendar$1 (time, formats) { // We want to compare the start of today, vs this. // Getting start-of-today depends on whether we're local/utc/offset or not. var now = time || createLocal(), sod = cloneWithOffset(now, this).startOf('day'), format = hooks.calendarFormat(this, sod) || 'sameElse'; var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]); return this.format(output || this.localeData().calendar(format, this, createLocal(now))); } function clone () { return new Moment(this); } function isAfter (input, units) { var localInput = isMoment(input) ? input : createLocal(input); if (!(this.isValid() && localInput.isValid())) { return false; } units = normalizeUnits(!isUndefined(units) ? units : 'millisecond'); if (units === 'millisecond') { return this.valueOf() > localInput.valueOf(); } else { return localInput.valueOf() < this.clone().startOf(units).valueOf(); } } function isBefore (input, units) { var localInput = isMoment(input) ? input : createLocal(input); if (!(this.isValid() && localInput.isValid())) { return false; } units = normalizeUnits(!isUndefined(units) ? units : 'millisecond'); if (units === 'millisecond') { return this.valueOf() < localInput.valueOf(); } else { return this.clone().endOf(units).valueOf() < localInput.valueOf(); } } function isBetween (from, to, units, inclusivity) { inclusivity = inclusivity || '()'; return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) && (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units)); } function isSame (input, units) { var localInput = isMoment(input) ? input : createLocal(input), inputMs; if (!(this.isValid() && localInput.isValid())) { return false; } units = normalizeUnits(units || 'millisecond'); if (units === 'millisecond') { return this.valueOf() === localInput.valueOf(); } else { inputMs = localInput.valueOf(); return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf(); } } function isSameOrAfter (input, units) { return this.isSame(input, units) || this.isAfter(input,units); } function isSameOrBefore (input, units) { return this.isSame(input, units) || this.isBefore(input,units); } function diff (input, units, asFloat) { var that, zoneDelta, delta, output; if (!this.isValid()) { return NaN; } that = cloneWithOffset(input, this); if (!that.isValid()) { return NaN; } zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4; units = normalizeUnits(units); if (units === 'year' || units === 'month' || units === 'quarter') { output = monthDiff(this, that); if (units === 'quarter') { output = output / 3; } else if (units === 'year') { output = output / 12; } } else { delta = this - that; output = units === 'second' ? delta / 1e3 : // 1000 units === 'minute' ? delta / 6e4 : // 1000 * 60 units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60 units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst delta; } return asFloat ? output : absFloor(output); } function monthDiff (a, b) { // difference in months var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()), // b is in (anchor - 1 month, anchor + 1 month) anchor = a.clone().add(wholeMonthDiff, 'months'), anchor2, adjust; if (b - anchor < 0) { anchor2 = a.clone().add(wholeMonthDiff - 1, 'months'); // linear across the month adjust = (b - anchor) / (anchor - anchor2); } else { anchor2 = a.clone().add(wholeMonthDiff + 1, 'months'); // linear across the month adjust = (b - anchor) / (anchor2 - anchor); } //check for negative zero, return zero if negative zero return -(wholeMonthDiff + adjust) || 0; } hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ'; hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]'; function toString () { return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ'); } function toISOString () { var m = this.clone().utc(); if (0 < m.year() && m.year() <= 9999) { if (isFunction(Date.prototype.toISOString)) { // native implementation is ~50x faster, use it when we can return this.toDate().toISOString(); } else { return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]'); } } else { return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'); } } /** * Return a human readable representation of a moment that can * also be evaluated to get a new moment which is the same * * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects */ function inspect () { if (!this.isValid()) { return 'moment.invalid(/* ' + this._i + ' */)'; } var func = 'moment'; var zone = ''; if (!this.isLocal()) { func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone'; zone = 'Z'; } var prefix = '[' + func + '("]'; var year = (0 < this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY'; var datetime = '-MM-DD[T]HH:mm:ss.SSS'; var suffix = zone + '[")]'; return this.format(prefix + year + datetime + suffix); } function format (inputString) { if (!inputString) { inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat; } var output = formatMoment(this, inputString); return this.localeData().postformat(output); } function from (time, withoutSuffix) { if (this.isValid() && ((isMoment(time) && time.isValid()) || createLocal(time).isValid())) { return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix); } else { return this.localeData().invalidDate(); } } function fromNow (withoutSuffix) { return this.from(createLocal(), withoutSuffix); } function to (time, withoutSuffix) { if (this.isValid() && ((isMoment(time) && time.isValid()) || createLocal(time).isValid())) { return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix); } else { return this.localeData().invalidDate(); } } function toNow (withoutSuffix) { return this.to(createLocal(), withoutSuffix); } // If passed a locale key, it will set the locale for this // instance. Otherwise, it will return the locale configuration // variables for this instance. function locale (key) { var newLocaleData; if (key === undefined) { return this._locale._abbr; } else { newLocaleData = getLocale(key); if (newLocaleData != null) { this._locale = newLocaleData; } return this; } } var lang = deprecate( 'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) { if (key === undefined) { return this.localeData(); } else { return this.locale(key); } } ); function localeData () { return this._locale; } function startOf (units) { units = normalizeUnits(units); // the following switch intentionally omits break keywords // to utilize falling through the cases. switch (units) { case 'year': this.month(0); /* falls through */ case 'quarter': case 'month': this.date(1); /* falls through */ case 'week': case 'isoWeek': case 'day': case 'date': this.hours(0); /* falls through */ case 'hour': this.minutes(0); /* falls through */ case 'minute': this.seconds(0); /* falls through */ case 'second': this.milliseconds(0); } // weeks are a special case if (units === 'week') { this.weekday(0); } if (units === 'isoWeek') { this.isoWeekday(1); } // quarters are also special if (units === 'quarter') { this.month(Math.floor(this.month() / 3) * 3); } return this; } function endOf (units) { units = normalizeUnits(units); if (units === undefined || units === 'millisecond') { return this; } // 'date' is an alias for 'day', so it should be considered as such. if (units === 'date') { units = 'day'; } return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms'); } function valueOf () { return this._d.valueOf() - ((this._offset || 0) * 60000); } function unix () { return Math.floor(this.valueOf() / 1000); } function toDate () { return new Date(this.valueOf()); } function toArray () { var m = this; return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()]; } function toObject () { var m = this; return { years: m.year(), months: m.month(), date: m.date(), hours: m.hours(), minutes: m.minutes(), seconds: m.seconds(), milliseconds: m.milliseconds() }; } function toJSON () { // new Date(NaN).toJSON() === null return this.isValid() ? this.toISOString() : null; } function isValid$1 () { return isValid(this); } function parsingFlags () { return extend({}, getParsingFlags(this)); } function invalidAt () { return getParsingFlags(this).overflow; } function creationData() { return { input: this._i, format: this._f, locale: this._locale, isUTC: this._isUTC, strict: this._strict }; } // FORMATTING addFormatToken(0, ['gg', 2], 0, function () { return this.weekYear() % 100; }); addFormatToken(0, ['GG', 2], 0, function () { return this.isoWeekYear() % 100; }); function addWeekYearFormatToken (token, getter) { addFormatToken(0, [token, token.length], 0, getter); } addWeekYearFormatToken('gggg', 'weekYear'); addWeekYearFormatToken('ggggg', 'weekYear'); addWeekYearFormatToken('GGGG', 'isoWeekYear'); addWeekYearFormatToken('GGGGG', 'isoWeekYear'); // ALIASES addUnitAlias('weekYear', 'gg'); addUnitAlias('isoWeekYear', 'GG'); // PRIORITY addUnitPriority('weekYear', 1); addUnitPriority('isoWeekYear', 1); // PARSING addRegexToken('G', matchSigned); addRegexToken('g', matchSigned); addRegexToken('GG', match1to2, match2); addRegexToken('gg', match1to2, match2); addRegexToken('GGGG', match1to4, match4); addRegexToken('gggg', match1to4, match4); addRegexToken('GGGGG', match1to6, match6); addRegexToken('ggggg', match1to6, match6); addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) { week[token.substr(0, 2)] = toInt(input); }); addWeekParseToken(['gg', 'GG'], function (input, week, config, token) { week[token] = hooks.parseTwoDigitYear(input); }); // MOMENTS function getSetWeekYear (input) { return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy); } function getSetISOWeekYear (input) { return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4); } function getISOWeeksInYear () { return weeksInYear(this.year(), 1, 4); } function getWeeksInYear () { var weekInfo = this.localeData()._week; return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy); } function getSetWeekYearHelper(input, week, weekday, dow, doy) { var weeksTarget; if (input == null) { return weekOfYear(this, dow, doy).year; } else { weeksTarget = weeksInYear(input, dow, doy); if (week > weeksTarget) { week = weeksTarget; } return setWeekAll.call(this, input, week, weekday, dow, doy); } } function setWeekAll(weekYear, week, weekday, dow, doy) { var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear); this.year(date.getUTCFullYear()); this.month(date.getUTCMonth()); this.date(date.getUTCDate()); return this; } // FORMATTING addFormatToken('Q', 0, 'Qo', 'quarter'); // ALIASES addUnitAlias('quarter', 'Q'); // PRIORITY addUnitPriority('quarter', 7); // PARSING addRegexToken('Q', match1); addParseToken('Q', function (input, array) { array[MONTH] = (toInt(input) - 1) * 3; }); // MOMENTS function getSetQuarter (input) { return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3); } // FORMATTING addFormatToken('D', ['DD', 2], 'Do', 'date'); // ALIASES addUnitAlias('date', 'D'); // PRIOROITY addUnitPriority('date', 9); // PARSING addRegexToken('D', match1to2); addRegexToken('DD', match1to2, match2); addRegexToken('Do', function (isStrict, locale) { return isStrict ? locale._ordinalParse : locale._ordinalParseLenient; }); addParseToken(['D', 'DD'], DATE); addParseToken('Do', function (input, array) { array[DATE] = toInt(input.match(match1to2)[0], 10); }); // MOMENTS var getSetDayOfMonth = makeGetSet('Date', true); // FORMATTING addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'); // ALIASES addUnitAlias('dayOfYear', 'DDD'); // PRIORITY addUnitPriority('dayOfYear', 4); // PARSING addRegexToken('DDD', match1to3); addRegexToken('DDDD', match3); addParseToken(['DDD', 'DDDD'], function (input, array, config) { config._dayOfYear = toInt(input); }); // HELPERS // MOMENTS function getSetDayOfYear (input) { var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1; return input == null ? dayOfYear : this.add((input - dayOfYear), 'd'); } // FORMATTING addFormatToken('m', ['mm', 2], 0, 'minute'); // ALIASES addUnitAlias('minute', 'm'); // PRIORITY addUnitPriority('minute', 14); // PARSING addRegexToken('m', match1to2); addRegexToken('mm', match1to2, match2); addParseToken(['m', 'mm'], MINUTE); // MOMENTS var getSetMinute = makeGetSet('Minutes', false); // FORMATTING addFormatToken('s', ['ss', 2], 0, 'second'); // ALIASES addUnitAlias('second', 's'); // PRIORITY addUnitPriority('second', 15); // PARSING addRegexToken('s', match1to2); addRegexToken('ss', match1to2, match2); addParseToken(['s', 'ss'], SECOND); // MOMENTS var getSetSecond = makeGetSet('Seconds', false); // FORMATTING addFormatToken('S', 0, 0, function () { return ~~(this.millisecond() / 100); }); addFormatToken(0, ['SS', 2], 0, function () { return ~~(this.millisecond() / 10); }); addFormatToken(0, ['SSS', 3], 0, 'millisecond'); addFormatToken(0, ['SSSS', 4], 0, function () { return this.millisecond() * 10; }); addFormatToken(0, ['SSSSS', 5], 0, function () { return this.millisecond() * 100; }); addFormatToken(0, ['SSSSSS', 6], 0, function () { return this.millisecond() * 1000; }); addFormatToken(0, ['SSSSSSS', 7], 0, function () { return this.millisecond() * 10000; }); addFormatToken(0, ['SSSSSSSS', 8], 0, function () { return this.millisecond() * 100000; }); addFormatToken(0, ['SSSSSSSSS', 9], 0, function () { return this.millisecond() * 1000000; }); // ALIASES addUnitAlias('millisecond', 'ms'); // PRIORITY addUnitPriority('millisecond', 16); // PARSING addRegexToken('S', match1to3, match1); addRegexToken('SS', match1to3, match2); addRegexToken('SSS', match1to3, match3); var token; for (token = 'SSSS'; token.length <= 9; token += 'S') { addRegexToken(token, matchUnsigned); } function parseMs(input, array) { array[MILLISECOND] = toInt(('0.' + input) * 1000); } for (token = 'S'; token.length <= 9; token += 'S') { addParseToken(token, parseMs); } // MOMENTS var getSetMillisecond = makeGetSet('Milliseconds', false); // FORMATTING addFormatToken('z', 0, 0, 'zoneAbbr'); addFormatToken('zz', 0, 0, 'zoneName'); // MOMENTS function getZoneAbbr () { return this._isUTC ? 'UTC' : ''; } function getZoneName () { return this._isUTC ? 'Coordinated Universal Time' : ''; } var proto = Moment.prototype; proto.add = add; proto.calendar = calendar$1; proto.clone = clone; proto.diff = diff; proto.endOf = endOf; proto.format = format; proto.from = from; proto.fromNow = fromNow; proto.to = to; proto.toNow = toNow; proto.get = stringGet; proto.invalidAt = invalidAt; proto.isAfter = isAfter; proto.isBefore = isBefore; proto.isBetween = isBetween; proto.isSame = isSame; proto.isSameOrAfter = isSameOrAfter; proto.isSameOrBefore = isSameOrBefore; proto.isValid = isValid$1; proto.lang = lang; proto.locale = locale; proto.localeData = localeData; proto.max = prototypeMax; proto.min = prototypeMin; proto.parsingFlags = parsingFlags; proto.set = stringSet; proto.startOf = startOf; proto.subtract = subtract; proto.toArray = toArray; proto.toObject = toObject; proto.toDate = toDate; proto.toISOString = toISOString; proto.inspect = inspect; proto.toJSON = toJSON; proto.toString = toString; proto.unix = unix; proto.valueOf = valueOf; proto.creationData = creationData; // Year proto.year = getSetYear; proto.isLeapYear = getIsLeapYear; // Week Year proto.weekYear = getSetWeekYear; proto.isoWeekYear = getSetISOWeekYear; // Quarter proto.quarter = proto.quarters = getSetQuarter; // Month proto.month = getSetMonth; proto.daysInMonth = getDaysInMonth; // Week proto.week = proto.weeks = getSetWeek; proto.isoWeek = proto.isoWeeks = getSetISOWeek; proto.weeksInYear = getWeeksInYear; proto.isoWeeksInYear = getISOWeeksInYear; // Day proto.date = getSetDayOfMonth; proto.day = proto.days = getSetDayOfWeek; proto.weekday = getSetLocaleDayOfWeek; proto.isoWeekday = getSetISODayOfWeek; proto.dayOfYear = getSetDayOfYear; // Hour proto.hour = proto.hours = getSetHour; // Minute proto.minute = proto.minutes = getSetMinute; // Second proto.second = proto.seconds = getSetSecond; // Millisecond proto.millisecond = proto.milliseconds = getSetMillisecond; // Offset proto.utcOffset = getSetOffset; proto.utc = setOffsetToUTC; proto.local = setOffsetToLocal; proto.parseZone = setOffsetToParsedOffset; proto.hasAlignedHourOffset = hasAlignedHourOffset; proto.isDST = isDaylightSavingTime; proto.isLocal = isLocal; proto.isUtcOffset = isUtcOffset; proto.isUtc = isUtc; proto.isUTC = isUtc; // Timezone proto.zoneAbbr = getZoneAbbr; proto.zoneName = getZoneName; // Deprecations proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth); proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth); proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear); proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone); proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted); function createUnix (input) { return createLocal(input * 1000); } function createInZone () { return createLocal.apply(null, arguments).parseZone(); } function preParsePostFormat (string) { return string; } var proto$1 = Locale.prototype; proto$1.calendar = calendar; proto$1.longDateFormat = longDateFormat; proto$1.invalidDate = invalidDate; proto$1.ordinal = ordinal; proto$1.preparse = preParsePostFormat; proto$1.postformat = preParsePostFormat; proto$1.relativeTime = relativeTime; proto$1.pastFuture = pastFuture; proto$1.set = set; // Month proto$1.months = localeMonths; proto$1.monthsShort = localeMonthsShort; proto$1.monthsParse = localeMonthsParse; proto$1.monthsRegex = monthsRegex; proto$1.monthsShortRegex = monthsShortRegex; // Week proto$1.week = localeWeek; proto$1.firstDayOfYear = localeFirstDayOfYear; proto$1.firstDayOfWeek = localeFirstDayOfWeek; // Day of Week proto$1.weekdays = localeWeekdays; proto$1.weekdaysMin = localeWeekdaysMin; proto$1.weekdaysShort = localeWeekdaysShort; proto$1.weekdaysParse = localeWeekdaysParse; proto$1.weekdaysRegex = weekdaysRegex; proto$1.weekdaysShortRegex = weekdaysShortRegex; proto$1.weekdaysMinRegex = weekdaysMinRegex; // Hours proto$1.isPM = localeIsPM; proto$1.meridiem = localeMeridiem; function get$1 (format, index, field, setter) { var locale = getLocale(); var utc = createUTC().set(setter, index); return locale[field](utc, format); } function listMonthsImpl (format, index, field) { if (isNumber(format)) { index = format; format = undefined; } format = format || ''; if (index != null) { return get$1(format, index, field, 'month'); } var i; var out = []; for (i = 0; i < 12; i++) { out[i] = get$1(format, i, field, 'month'); } return out; } // () // (5) // (fmt, 5) // (fmt) // (true) // (true, 5) // (true, fmt, 5) // (true, fmt) function listWeekdaysImpl (localeSorted, format, index, field) { if (typeof localeSorted === 'boolean') { if (isNumber(format)) { index = format; format = undefined; } format = format || ''; } else { format = localeSorted; index = format; localeSorted = false; if (isNumber(format)) { index = format; format = undefined; } format = format || ''; } var locale = getLocale(), shift = localeSorted ? locale._week.dow : 0; if (index != null) { return get$1(format, (index + shift) % 7, field, 'day'); } var i; var out = []; for (i = 0; i < 7; i++) { out[i] = get$1(format, (i + shift) % 7, field, 'day'); } return out; } function listMonths (format, index) { return listMonthsImpl(format, index, 'months'); } function listMonthsShort (format, index) { return listMonthsImpl(format, index, 'monthsShort'); } function listWeekdays (localeSorted, format, index) { return listWeekdaysImpl(localeSorted, format, index, 'weekdays'); } function listWeekdaysShort (localeSorted, format, index) { return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort'); } function listWeekdaysMin (localeSorted, format, index) { return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin'); } getSetGlobalLocale('en', { ordinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal : function (number) { var b = number % 10, output = (toInt(number % 100 / 10) === 1) ? 'th' : (b === 1) ? 'st' : (b === 2) ? 'nd' : (b === 3) ? 'rd' : 'th'; return number + output; } }); // Side effect imports hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale); hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale); var mathAbs = Math.abs; function abs () { var data = this._data; this._milliseconds = mathAbs(this._milliseconds); this._days = mathAbs(this._days); this._months = mathAbs(this._months); data.milliseconds = mathAbs(data.milliseconds); data.seconds = mathAbs(data.seconds); data.minutes = mathAbs(data.minutes); data.hours = mathAbs(data.hours); data.months = mathAbs(data.months); data.years = mathAbs(data.years); return this; } function addSubtract$1 (duration, input, value, direction) { var other = createDuration(input, value); duration._milliseconds += direction * other._milliseconds; duration._days += direction * other._days; duration._months += direction * other._months; return duration._bubble(); } // supports only 2.0-style add(1, 's') or add(duration) function add$1 (input, value) { return addSubtract$1(this, input, value, 1); } // supports only 2.0-style subtract(1, 's') or subtract(duration) function subtract$1 (input, value) { return addSubtract$1(this, input, value, -1); } function absCeil (number) { if (number < 0) { return Math.floor(number); } else { return Math.ceil(number); } } function bubble () { var milliseconds = this._milliseconds; var days = this._days; var months = this._months; var data = this._data; var seconds, minutes, hours, years, monthsFromDays; // if we have a mix of positive and negative values, bubble down first // check: https://github.com/moment/moment/issues/2166 if (!((milliseconds >= 0 && days >= 0 && months >= 0) || (milliseconds <= 0 && days <= 0 && months <= 0))) { milliseconds += absCeil(monthsToDays(months) + days) * 864e5; days = 0; months = 0; } // The following code bubbles up values, see the tests for // examples of what that means. data.milliseconds = milliseconds % 1000; seconds = absFloor(milliseconds / 1000); data.seconds = seconds % 60; minutes = absFloor(seconds / 60); data.minutes = minutes % 60; hours = absFloor(minutes / 60); data.hours = hours % 24; days += absFloor(hours / 24); // convert days to months monthsFromDays = absFloor(daysToMonths(days)); months += monthsFromDays; days -= absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year years = absFloor(months / 12); months %= 12; data.days = days; data.months = months; data.years = years; return this; } function daysToMonths (days) { // 400 years have 146097 days (taking into account leap year rules) // 400 years have 12 months === 4800 return days * 4800 / 146097; } function monthsToDays (months) { // the reverse of daysToMonths return months * 146097 / 4800; } function as (units) { var days; var months; var milliseconds = this._milliseconds; units = normalizeUnits(units); if (units === 'month' || units === 'year') { days = this._days + milliseconds / 864e5; months = this._months + daysToMonths(days); return units === 'month' ? months : months / 12; } else { // handle milliseconds separately because of floating point math errors (issue #1867) days = this._days + Math.round(monthsToDays(this._months)); switch (units) { case 'week' : return days / 7 + milliseconds / 6048e5; case 'day' : return days + milliseconds / 864e5; case 'hour' : return days * 24 + milliseconds / 36e5; case 'minute' : return days * 1440 + milliseconds / 6e4; case 'second' : return days * 86400 + milliseconds / 1000; // Math.floor prevents floating point math errors here case 'millisecond': return Math.floor(days * 864e5) + milliseconds; default: throw new Error('Unknown unit ' + units); } } } // TODO: Use this.as('ms')? function valueOf$1 () { return ( this._milliseconds + this._days * 864e5 + (this._months % 12) * 2592e6 + toInt(this._months / 12) * 31536e6 ); } function makeAs (alias) { return function () { return this.as(alias); }; } var asMilliseconds = makeAs('ms'); var asSeconds = makeAs('s'); var asMinutes = makeAs('m'); var asHours = makeAs('h'); var asDays = makeAs('d'); var asWeeks = makeAs('w'); var asMonths = makeAs('M'); var asYears = makeAs('y'); function get$2 (units) { units = normalizeUnits(units); return this[units + 's'](); } function makeGetter(name) { return function () { return this._data[name]; }; } var milliseconds = makeGetter('milliseconds'); var seconds = makeGetter('seconds'); var minutes = makeGetter('minutes'); var hours = makeGetter('hours'); var days = makeGetter('days'); var months = makeGetter('months'); var years = makeGetter('years'); function weeks () { return absFloor(this.days() / 7); } var round = Math.round; var thresholds = { s: 45, // seconds to minute m: 45, // minutes to hour h: 22, // hours to day d: 26, // days to month M: 11 // months to year }; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) { return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture); } function relativeTime$1 (posNegDuration, withoutSuffix, locale) { var duration = createDuration(posNegDuration).abs(); var seconds = round(duration.as('s')); var minutes = round(duration.as('m')); var hours = round(duration.as('h')); var days = round(duration.as('d')); var months = round(duration.as('M')); var years = round(duration.as('y')); var a = seconds < thresholds.s && ['s', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years]; a[2] = withoutSuffix; a[3] = +posNegDuration > 0; a[4] = locale; return substituteTimeAgo.apply(null, a); } // This function allows you to set the rounding function for relative time strings function getSetRelativeTimeRounding (roundingFunction) { if (roundingFunction === undefined) { return round; } if (typeof(roundingFunction) === 'function') { round = roundingFunction; return true; } return false; } // This function allows you to set a threshold for relative time strings function getSetRelativeTimeThreshold (threshold, limit) { if (thresholds[threshold] === undefined) { return false; } if (limit === undefined) { return thresholds[threshold]; } thresholds[threshold] = limit; return true; } function humanize (withSuffix) { var locale = this.localeData(); var output = relativeTime$1(this, !withSuffix, locale); if (withSuffix) { output = locale.pastFuture(+this, output); } return locale.postformat(output); } var abs$1 = Math.abs; function toISOString$1() { // for ISO strings we do not use the normal bubbling rules: // * milliseconds bubble up until they become hours // * days do not bubble at all // * months bubble up until they become years // This is because there is no context-free conversion between hours and days // (think of clock changes) // and also not between days and months (28-31 days per month) var seconds = abs$1(this._milliseconds) / 1000; var days = abs$1(this._days); var months = abs$1(this._months); var minutes, hours, years; // 3600 seconds -> 60 minutes -> 1 hour minutes = absFloor(seconds / 60); hours = absFloor(minutes / 60); seconds %= 60; minutes %= 60; // 12 months -> 1 year years = absFloor(months / 12); months %= 12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js var Y = years; var M = months; var D = days; var h = hours; var m = minutes; var s = seconds; var total = this.asSeconds(); if (!total) { // this is the same as C#'s (Noda) and javascript (isodate)... // but not other JS (goog.date) return 'P0D'; } return (total < 0 ? '-' : '') + 'P' + (Y ? Y + 'Y' : '') + (M ? M + 'M' : '') + (D ? D + 'D' : '') + ((h || m || s) ? 'T' : '') + (h ? h + 'H' : '') + (m ? m + 'M' : '') + (s ? s + 'S' : ''); } var proto$2 = Duration.prototype; proto$2.abs = abs; proto$2.add = add$1; proto$2.subtract = subtract$1; proto$2.as = as; proto$2.asMilliseconds = asMilliseconds; proto$2.asSeconds = asSeconds; proto$2.asMinutes = asMinutes; proto$2.asHours = asHours; proto$2.asDays = asDays; proto$2.asWeeks = asWeeks; proto$2.asMonths = asMonths; proto$2.asYears = asYears; proto$2.valueOf = valueOf$1; proto$2._bubble = bubble; proto$2.get = get$2; proto$2.milliseconds = milliseconds; proto$2.seconds = seconds; proto$2.minutes = minutes; proto$2.hours = hours; proto$2.days = days; proto$2.weeks = weeks; proto$2.months = months; proto$2.years = years; proto$2.humanize = humanize; proto$2.toISOString = toISOString$1; proto$2.toString = toISOString$1; proto$2.toJSON = toISOString$1; proto$2.locale = locale; proto$2.localeData = localeData; // Deprecations proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1); proto$2.lang = lang; // Side effect imports // FORMATTING addFormatToken('X', 0, 0, 'unix'); addFormatToken('x', 0, 0, 'valueOf'); // PARSING addRegexToken('x', matchSigned); addRegexToken('X', matchTimestamp); addParseToken('X', function (input, array, config) { config._d = new Date(parseFloat(input, 10) * 1000); }); addParseToken('x', function (input, array, config) { config._d = new Date(toInt(input)); }); // Side effect imports hooks.version = '2.17.1'; setHookCallback(createLocal); hooks.fn = proto; hooks.min = min; hooks.max = max; hooks.now = now; hooks.utc = createUTC; hooks.unix = createUnix; hooks.months = listMonths; hooks.isDate = isDate; hooks.locale = getSetGlobalLocale; hooks.invalid = createInvalid; hooks.duration = createDuration; hooks.isMoment = isMoment; hooks.weekdays = listWeekdays; hooks.parseZone = createInZone; hooks.localeData = getLocale; hooks.isDuration = isDuration; hooks.monthsShort = listMonthsShort; hooks.weekdaysMin = listWeekdaysMin; hooks.defineLocale = defineLocale; hooks.updateLocale = updateLocale; hooks.locales = listLocales; hooks.weekdaysShort = listWeekdaysShort; hooks.normalizeUnits = normalizeUnits; hooks.relativeTimeRounding = getSetRelativeTimeRounding; hooks.relativeTimeThreshold = getSetRelativeTimeThreshold; hooks.calendarFormat = getCalendarFormat; hooks.prototype = proto; return hooks; }))); ; /* /web/static/lib/owl/owl.js defined in bundle 'web.assetsCommon' */ (function (exports) { 'use strict'; /** * We define here a simple event bus: it can * - emit events * - add/remove listeners. * * This is a useful pattern of communication in many cases. For OWL, each * components and stores are event buses. */ //------------------------------------------------------------------------------ // EventBus //------------------------------------------------------------------------------ class EventBus { constructor() { this.subscriptions = {}; } /** * Add a listener for the 'eventType' events. * * Note that the 'owner' of this event can be anything, but will more likely * be a component or a class. The idea is that the callback will be called with * the proper owner bound. * * Also, the owner should be kind of unique. This will be used to remove the * listener. */ on(eventType, owner, callback) { if (!callback) { throw new Error("Missing callback"); } if (!this.subscriptions[eventType]) { this.subscriptions[eventType] = []; } this.subscriptions[eventType].push({ owner, callback, }); } /** * Remove a listener */ off(eventType, owner) { const subs = this.subscriptions[eventType]; if (subs) { this.subscriptions[eventType] = subs.filter((s) => s.owner !== owner); } } /** * Emit an event of type 'eventType'. Any extra arguments will be passed to * the listeners callback. */ trigger(eventType, ...args) { const subs = this.subscriptions[eventType] || []; for (let i = 0, iLen = subs.length; i < iLen; i++) { const sub = subs[i]; sub.callback.call(sub.owner, ...args); } } /** * Remove all subscriptions. */ clear() { this.subscriptions = {}; } } /** * Owl Observer * * This code contains the logic that allows Owl to observe and react to state * changes. * * This is a Observer class that can observe any JS values. The way it works * can be summarized thusly: * - primitive values are not observed at all * - Objects and arrays are observed by replacing them with a Proxy * - each object/array metadata are tracked in a weakmap, and keep a revision * number * * Note that this code is loosely inspired by Vue. */ //------------------------------------------------------------------------------ // Observer //------------------------------------------------------------------------------ class Observer { constructor() { this.rev = 1; this.allowMutations = true; this.weakMap = new WeakMap(); } notifyCB() { } observe(value, parent) { if (value === null || typeof value !== "object" || value instanceof Date || value instanceof Promise) { // fun fact: typeof null === 'object' return value; } let metadata = this.weakMap.get(value) || this._observe(value, parent); return metadata.proxy; } revNumber(value) { const metadata = this.weakMap.get(value); return metadata ? metadata.rev : 0; } _observe(value, parent) { var self = this; const proxy = new Proxy(value, { get(target, k) { const targetValue = target[k]; return self.observe(targetValue, value); }, set(target, key, newVal) { const value = target[key]; if (newVal !== value) { if (!self.allowMutations) { throw new Error(`Observed state cannot be changed here! (key: "${key}", val: "${newVal}")`); } self._updateRevNumber(target); target[key] = newVal; self.notifyCB(); } return true; }, deleteProperty(target, key) { if (key in target) { delete target[key]; self._updateRevNumber(target); self.notifyCB(); } return true; }, }); const metadata = { value, proxy, rev: this.rev, parent, }; this.weakMap.set(value, metadata); this.weakMap.set(metadata.proxy, metadata); return metadata; } _updateRevNumber(target) { this.rev++; let metadata = this.weakMap.get(target); let parent = target; do { metadata = this.weakMap.get(parent); metadata.rev++; } while ((parent = metadata.parent) && parent !== target); } } /** * Owl QWeb Expression Parser * * Owl needs in various contexts to be able to understand the structure of a * string representing a javascript expression. The usual goal is to be able * to rewrite some variables. For example, if a template has * * ```xml * ... * ``` * * this needs to be translated in something like this: * * ```js * if (context["computeSomething"]({val: context["state"].val})) { ... } * ``` * * This file contains the implementation of an extremely naive tokenizer/parser * and evaluator for javascript expressions. The supported grammar is basically * only expressive enough to understand the shape of objects, of arrays, and * various operators. */ //------------------------------------------------------------------------------ // Misc types, constants and helpers //------------------------------------------------------------------------------ const RESERVED_WORDS = "true,false,NaN,null,undefined,debugger,console,window,in,instanceof,new,function,return,this,eval,void,Math,RegExp,Array,Object,Date".split(","); const WORD_REPLACEMENT = Object.assign(Object.create(null), { and: "&&", or: "||", gt: ">", gte: ">=", lt: "<", lte: "<=", }); const STATIC_TOKEN_MAP = Object.assign(Object.create(null), { "{": "LEFT_BRACE", "}": "RIGHT_BRACE", "[": "LEFT_BRACKET", "]": "RIGHT_BRACKET", ":": "COLON", ",": "COMMA", "(": "LEFT_PAREN", ")": "RIGHT_PAREN", }); // note that the space after typeof is relevant. It makes sure that the formatted // expression has a space after typeof const OPERATORS = "...,.,===,==,+,!==,!=,!,||,&&,>=,>,<=,<,?,-,*,/,%,typeof ,=>,=,;,in ".split(","); let tokenizeString = function (expr) { let s = expr[0]; let start = s; if (s !== "'" && s !== '"' && s !== "`") { return false; } let i = 1; let cur; while (expr[i] && expr[i] !== start) { cur = expr[i]; s += cur; if (cur === "\\") { i++; cur = expr[i]; if (!cur) { throw new Error("Invalid expression"); } s += cur; } i++; } if (expr[i] !== start) { throw new Error("Invalid expression"); } s += start; if (start === "`") { return { type: "TEMPLATE_STRING", value: s, replace(replacer) { return s.replace(/\$\{(.*?)\}/g, (match, group) => { return "${" + replacer(group) + "}"; }); }, }; } return { type: "VALUE", value: s }; }; let tokenizeNumber = function (expr) { let s = expr[0]; if (s && s.match(/[0-9]/)) { let i = 1; while (expr[i] && expr[i].match(/[0-9]|\./)) { s += expr[i]; i++; } return { type: "VALUE", value: s }; } else { return false; } }; let tokenizeSymbol = function (expr) { let s = expr[0]; if (s && s.match(/[a-zA-Z_\$]/)) { let i = 1; while (expr[i] && expr[i].match(/\w/)) { s += expr[i]; i++; } if (s in WORD_REPLACEMENT) { return { type: "OPERATOR", value: WORD_REPLACEMENT[s], size: s.length }; } return { type: "SYMBOL", value: s }; } else { return false; } }; const tokenizeStatic = function (expr) { const char = expr[0]; if (char && char in STATIC_TOKEN_MAP) { return { type: STATIC_TOKEN_MAP[char], value: char }; } return false; }; const tokenizeOperator = function (expr) { for (let op of OPERATORS) { if (expr.startsWith(op)) { return { type: "OPERATOR", value: op }; } } return false; }; const TOKENIZERS = [ tokenizeString, tokenizeNumber, tokenizeOperator, tokenizeSymbol, tokenizeStatic, ]; /** * Convert a javascript expression (as a string) into a list of tokens. For * example: `tokenize("1 + b")` will return: * ```js * [ * {type: "VALUE", value: "1"}, * {type: "OPERATOR", value: "+"}, * {type: "SYMBOL", value: "b"} * ] * ``` */ function tokenize(expr) { const result = []; let token = true; while (token) { expr = expr.trim(); if (expr) { for (let tokenizer of TOKENIZERS) { token = tokenizer(expr); if (token) { result.push(token); expr = expr.slice(token.size || token.value.length); break; } } } else { token = false; } } if (expr.length) { throw new Error(`Tokenizer error: could not tokenize "${expr}"`); } return result; } //------------------------------------------------------------------------------ // Expression "evaluator" //------------------------------------------------------------------------------ const isLeftSeparator = (token) => token && (token.type === "LEFT_BRACE" || token.type === "COMMA"); const isRightSeparator = (token) => token && (token.type === "RIGHT_BRACE" || token.type === "COMMA"); /** * This is the main function exported by this file. This is the code that will * process an expression (given as a string) and returns another expression with * proper lookups in the context. * * Usually, this kind of code would be very simple to do if we had an AST (so, * if we had a javascript parser), since then, we would only need to find the * variables and replace them. However, a parser is more complicated, and there * are no standard builtin parser API. * * Since this method is applied to simple javasript expressions, and the work to * be done is actually quite simple, we actually can get away with not using a * parser, which helps with the code size. * * Here is the heuristic used by this method to determine if a token is a * variable: * - by default, all symbols are considered a variable * - unless the previous token is a dot (in that case, this is a property: `a.b`) * - or if the previous token is a left brace or a comma, and the next token is * a colon (in that case, this is an object key: `{a: b}`) * * Some specific code is also required to support arrow functions. If we detect * the arrow operator, then we add the current (or some previous tokens) token to * the list of variables so it does not get replaced by a lookup in the context */ function compileExprToArray(expr, scope) { const localVars = new Set(); scope = Object.create(scope); const tokens = tokenize(expr); let i = 0; let stack = []; // to track last opening [ or { while (i < tokens.length) { let token = tokens[i]; let prevToken = tokens[i - 1]; let nextToken = tokens[i + 1]; let groupType = stack[stack.length - 1]; switch (token.type) { case "LEFT_BRACE": case "LEFT_BRACKET": stack.push(token.type); break; case "RIGHT_BRACE": case "RIGHT_BRACKET": stack.pop(); } let isVar = token.type === "SYMBOL" && !RESERVED_WORDS.includes(token.value); if (token.type === "SYMBOL" && !RESERVED_WORDS.includes(token.value)) { if (prevToken) { // normalize missing tokens: {a} should be equivalent to {a:a} if (groupType === "LEFT_BRACE" && isLeftSeparator(prevToken) && isRightSeparator(nextToken)) { tokens.splice(i + 1, 0, { type: "COLON", value: ":" }, Object.assign({}, token)); nextToken = tokens[i + 1]; } if (prevToken.type === "OPERATOR" && prevToken.value === ".") { isVar = false; } else if (prevToken.type === "LEFT_BRACE" || prevToken.type === "COMMA") { if (nextToken && nextToken.type === "COLON") { isVar = false; } } } } if (token.type === "TEMPLATE_STRING") { token.value = token.replace((expr) => compileExpr(expr, scope)); } if (nextToken && nextToken.type === "OPERATOR" && nextToken.value === "=>") { if (token.type === "RIGHT_PAREN") { let j = i - 1; while (j > 0 && tokens[j].type !== "LEFT_PAREN") { if (tokens[j].type === "SYMBOL" && tokens[j].originalValue) { tokens[j].value = tokens[j].originalValue; scope[tokens[j].value] = { id: tokens[j].value, expr: tokens[j].value }; localVars.add(tokens[j].value); } j--; } } else { scope[token.value] = { id: token.value, expr: token.value }; localVars.add(token.value); } } if (isVar) { token.varName = token.value; if (token.value in scope && "id" in scope[token.value]) { token.value = scope[token.value].expr; } else { token.originalValue = token.value; token.value = `scope['${token.value}']`; } } i++; } // Mark all variables that have been used locally. // This assumes the expression has only one scope (incorrect but "good enough for now") for (const token of tokens) { if (token.type === "SYMBOL" && localVars.has(token.value)) { token.isLocal = true; } } return tokens; } function compileExpr(expr, scope) { return compileExprToArray(expr, scope) .map((t) => t.value) .join(""); } const INTERP_REGEXP = /\{\{.*?\}\}/g; //------------------------------------------------------------------------------ // Compilation Context //------------------------------------------------------------------------------ class CompilationContext { constructor(name) { this.code = []; this.variables = {}; this.escaping = false; this.parentNode = null; this.parentTextNode = null; this.rootNode = null; this.indentLevel = 0; this.shouldDefineParent = false; this.shouldDefineScope = false; this.protectedScopeNumber = 0; this.shouldDefineQWeb = false; this.shouldDefineUtils = false; this.shouldDefineRefs = false; this.shouldDefineResult = true; this.loopNumber = 0; this.inPreTag = false; this.allowMultipleRoots = false; this.hasParentWidget = false; this.hasKey0 = false; this.keyStack = []; this.rootContext = this; this.templateName = name || "noname"; this.addLine("let h = this.h;"); } generateID() { return CompilationContext.nextID++; } /** * This method generates a "template key", which is basically a unique key * which depends on the currently set keys, and on the iteration numbers (if * we are in a loop). * * Such a key is necessary when we need to associate an id to some element * generated by a template (for example, a component) */ generateTemplateKey(prefix = "") { const id = this.generateID(); if (this.loopNumber === 0 && !this.hasKey0) { return `'${prefix}__${id}__'`; } let key = `\`${prefix}__${id}__`; let start = this.hasKey0 ? 0 : 1; for (let i = start; i < this.loopNumber + 1; i++) { key += `\${key${i}}__`; } this.addLine(`let k${id} = ${key}\`;`); return `k${id}`; } generateCode() { if (this.shouldDefineResult) { this.code.unshift(" let result;"); } if (this.shouldDefineScope) { this.code.unshift(" let scope = Object.create(context);"); } if (this.shouldDefineRefs) { this.code.unshift(" context.__owl__.refs = context.__owl__.refs || {};"); } if (this.shouldDefineParent) { if (this.hasParentWidget) { this.code.unshift(" let parent = extra.parent;"); } else { this.code.unshift(" let parent = context;"); } } if (this.shouldDefineQWeb) { this.code.unshift(" let QWeb = this.constructor;"); } if (this.shouldDefineUtils) { this.code.unshift(" let utils = this.constructor.utils;"); } return this.code; } withParent(node) { if (!this.allowMultipleRoots && this === this.rootContext && (this.parentNode || this.parentTextNode)) { throw new Error("A template should not have more than one root node"); } if (!this.rootContext.rootNode) { this.rootContext.rootNode = node; } if (!this.parentNode && this.rootContext.shouldDefineResult) { this.addLine(`result = vn${node};`); } return this.subContext("parentNode", node); } subContext(key, value) { const newContext = Object.create(this); newContext[key] = value; return newContext; } indent() { this.rootContext.indentLevel++; } dedent() { this.rootContext.indentLevel--; } addLine(line) { const prefix = new Array(this.indentLevel + 2).join(" "); this.code.push(prefix + line); return this.code.length - 1; } addIf(condition) { this.addLine(`if (${condition}) {`); this.indent(); } addElse() { this.dedent(); this.addLine("} else {"); this.indent(); } closeIf() { this.dedent(); this.addLine("}"); } getValue(val) { return val in this.variables ? this.getValue(this.variables[val]) : val; } /** * Prepare an expression for being consumed at render time. Its main job * is to * - replace unknown variables by a lookup in the context * - replace already defined variables by their internal name */ formatExpression(expr) { this.rootContext.shouldDefineScope = true; return compileExpr(expr, this.variables); } captureExpression(expr) { this.rootContext.shouldDefineScope = true; const argId = this.generateID(); const tokens = compileExprToArray(expr, this.variables); const done = new Set(); return tokens .map((tok, i) => { // "this" in captured expressions should be the current component if (tok.value === "this") { if (!done.has("this")) { done.add("this"); this.addLine(`const this_${argId} = utils.getComponent(context);`); } tok.value = `this_${argId}`; } // Variables that should be looked up in the scope. isLocal is for arrow // function arguments that should stay untouched (eg "ev => ev" should // not become "const ev_1 = scope['ev']; ev_1 => ev_1") if (tok.varName && !tok.isLocal && // HACK: for backwards compatibility, we don't capture bare methods // this allows them to be called with the rendering context/scope // as their this value. (!tokens[i + 1] || tokens[i + 1].type !== "LEFT_PAREN")) { if (!done.has(tok.varName)) { done.add(tok.varName); this.addLine(`const ${tok.varName}_${argId} = ${tok.value};`); } tok.value = `${tok.varName}_${argId}`; } return tok.value; }) .join(""); } /** * Perform string interpolation on the given string. Note that if the whole * string is an expression, it simply returns it (formatted and enclosed in * parentheses). * For instance: * 'Hello {{x}}!' -> `Hello ${x}` * '{{x ? 'a': 'b'}}' -> (x ? 'a' : 'b') */ interpolate(s) { let matches = s.match(INTERP_REGEXP); if (matches && matches[0].length === s.length) { return `(${this.formatExpression(s.slice(2, -2))})`; } let r = s.replace(/\{\{.*?\}\}/g, (s) => "${" + this.formatExpression(s.slice(2, -2)) + "}"); return "`" + r + "`"; } startProtectScope(codeBlock) { const protectID = this.generateID(); this.rootContext.protectedScopeNumber++; this.rootContext.shouldDefineScope = true; const scopeExpr = `Object.create(scope);`; this.addLine(`let _origScope${protectID} = scope;`); this.addLine(`scope = ${scopeExpr}`); if (!codeBlock) { this.addLine(`scope.__access_mode__ = 'ro';`); } return protectID; } stopProtectScope(protectID) { this.rootContext.protectedScopeNumber--; this.addLine(`scope = _origScope${protectID};`); } } CompilationContext.nextID = 1; //------------------------------------------------------------------------------ // module/props.ts //------------------------------------------------------------------------------ function updateProps(oldVnode, vnode) { var key, cur, old, elm = vnode.elm, oldProps = oldVnode.data.props, props = vnode.data.props; if (!oldProps && !props) return; if (oldProps === props) return; oldProps = oldProps || {}; props = props || {}; for (key in oldProps) { if (!props[key]) { delete elm[key]; } } for (key in props) { cur = props[key]; old = oldProps[key]; if (old !== cur && (key !== "value" || elm[key] !== cur)) { elm[key] = cur; } } } const propsModule = { create: updateProps, update: updateProps, }; //------------------------------------------------------------------------------ // module/eventlisteners.ts //------------------------------------------------------------------------------ function invokeHandler(handler, vnode, event) { if (typeof handler === "function") { // call function handler handler.call(vnode, event, vnode); } else if (typeof handler === "object") { // call handler with arguments if (typeof handler[0] === "function") { // special case for single argument for performance if (handler.length === 2) { handler[0].call(vnode, handler[1], event, vnode); } else { var args = handler.slice(1); args.push(event); args.push(vnode); handler[0].apply(vnode, args); } } else { // call multiple handlers for (let i = 0, iLen = handler.length; i < iLen; i++) { invokeHandler(handler[i], vnode, event); } } } } function handleEvent(event, vnode) { var name = event.type, on = vnode.data.on; // call event handler(s) if exists if (on) { if (on[name]) { invokeHandler(on[name], vnode, event); } else if (on["!" + name]) { invokeHandler(on["!" + name], vnode, event); } } } function createListener() { return function handler(event) { handleEvent(event, handler.vnode); }; } function updateEventListeners(oldVnode, vnode) { var oldOn = oldVnode.data.on, oldListener = oldVnode.listener, oldElm = oldVnode.elm, on = vnode && vnode.data.on, elm = (vnode && vnode.elm), name; // optimization for reused immutable handlers if (oldOn === on) { return; } // remove existing listeners which no longer used if (oldOn && oldListener) { // if element changed or deleted we remove all existing listeners unconditionally if (!on) { for (name in oldOn) { // remove listener if element was changed or existing listeners removed const capture = name.charAt(0) === "!"; name = capture ? name.slice(1) : name; oldElm.removeEventListener(name, oldListener, capture); } } else { for (name in oldOn) { // remove listener if existing listener removed if (!on[name]) { const capture = name.charAt(0) === "!"; name = capture ? name.slice(1) : name; oldElm.removeEventListener(name, oldListener, capture); } } } } // add new listeners which has not already attached if (on) { // reuse existing listener or create new var listener = (vnode.listener = oldVnode.listener || createListener()); // update vnode for listener listener.vnode = vnode; // if element changed or added we add all needed listeners unconditionally if (!oldOn) { for (name in on) { // add listener if element was changed or new listeners added const capture = name.charAt(0) === "!"; name = capture ? name.slice(1) : name; elm.addEventListener(name, listener, capture); } } else { for (name in on) { // add listener if new listener added if (!oldOn[name]) { const capture = name.charAt(0) === "!"; name = capture ? name.slice(1) : name; elm.addEventListener(name, listener, capture); } } } } } const eventListenersModule = { create: updateEventListeners, update: updateEventListeners, destroy: updateEventListeners, }; //------------------------------------------------------------------------------ // attributes.ts //------------------------------------------------------------------------------ const xlinkNS = "http://www.w3.org/1999/xlink"; const xmlNS = "http://www.w3.org/XML/1998/namespace"; const colonChar = 58; const xChar = 120; function updateAttrs(oldVnode, vnode) { var key, elm = vnode.elm, oldAttrs = oldVnode.data.attrs, attrs = vnode.data.attrs; if (!oldAttrs && !attrs) return; if (oldAttrs === attrs) return; oldAttrs = oldAttrs || {}; attrs = attrs || {}; // update modified attributes, add new attributes for (key in attrs) { const cur = attrs[key]; const old = oldAttrs[key]; if (old !== cur) { if (cur === true) { elm.setAttribute(key, ""); } else if (cur === false) { elm.removeAttribute(key); } else { if (key.charCodeAt(0) !== xChar) { elm.setAttribute(key, cur); } else if (key.charCodeAt(3) === colonChar) { // Assume xml namespace elm.setAttributeNS(xmlNS, key, cur); } else if (key.charCodeAt(5) === colonChar) { // Assume xlink namespace elm.setAttributeNS(xlinkNS, key, cur); } else { elm.setAttribute(key, cur); } } } } // remove removed attributes // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value) // the other option is to remove all attributes with value == undefined for (key in oldAttrs) { if (!(key in attrs)) { elm.removeAttribute(key); } } } const attrsModule = { create: updateAttrs, update: updateAttrs, }; //------------------------------------------------------------------------------ // class.ts //------------------------------------------------------------------------------ function updateClass(oldVnode, vnode) { var cur, name, elm, oldClass = oldVnode.data.class, klass = vnode.data.class; if (!oldClass && !klass) return; if (oldClass === klass) return; oldClass = oldClass || {}; klass = klass || {}; elm = vnode.elm; for (name in oldClass) { if (name && !klass[name] && !Object.prototype.hasOwnProperty.call(klass, name)) { // was `true` and now not provided elm.classList.remove(name); } } for (name in klass) { cur = klass[name]; if (cur !== oldClass[name]) { elm.classList[cur ? "add" : "remove"](name); } } } const classModule = { create: updateClass, update: updateClass }; /** * Owl VDOM * * This file contains an implementation of a virtual DOM, which is a system that * can generate in-memory representations of a DOM tree, compare them, and * eventually change a concrete DOM tree to match its representation, in an * hopefully efficient way. * * Note that this code is a fork of Snabbdom, slightly tweaked/optimized for our * needs (see https://github.com/snabbdom/snabbdom). * * The main exported values are: * - interface VNode * - h function (a helper function to generate a vnode) * - patch function (to apply a vnode to an actual DOM node) */ function vnode(sel, data, children, text, elm) { let key = data === undefined ? undefined : data.key; return { sel, data, children, text, elm, key }; } //------------------------------------------------------------------------------ // snabbdom.ts //------------------------------------------------------------------------------ function isUndef(s) { return s === undefined; } function isDef(s) { return s !== undefined; } const emptyNode = vnode("", {}, [], undefined, undefined); function sameVnode(vnode1, vnode2) { return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel; } function isVnode(vnode) { return vnode.sel !== undefined; } function createKeyToOldIdx(children, beginIdx, endIdx) { let i, map = {}, key, ch; for (i = beginIdx; i <= endIdx; ++i) { ch = children[i]; if (ch != null) { key = ch.key; if (key !== undefined) map[key] = i; } } return map; } const hooks$1 = ["create", "update", "remove", "destroy", "pre", "post"]; function init(modules, domApi) { let i, j, cbs = {}; const api = domApi !== undefined ? domApi : htmlDomApi; for (i = 0; i < hooks$1.length; ++i) { cbs[hooks$1[i]] = []; for (j = 0; j < modules.length; ++j) { const hook = modules[j][hooks$1[i]]; if (hook !== undefined) { cbs[hooks$1[i]].push(hook); } } } function emptyNodeAt(elm) { const id = elm.id ? "#" + elm.id : ""; const c = elm.className ? "." + elm.className.split(" ").join(".") : ""; return vnode(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm); } function createRmCb(childElm, listeners) { return function rmCb() { if (--listeners === 0) { const parent = api.parentNode(childElm); api.removeChild(parent, childElm); } }; } function createElm(vnode, insertedVnodeQueue) { let i, iLen, data = vnode.data; if (data !== undefined) { if (isDef((i = data.hook)) && isDef((i = i.init))) { i(vnode); data = vnode.data; } } let children = vnode.children, sel = vnode.sel; if (sel === "!") { if (isUndef(vnode.text)) { vnode.text = ""; } vnode.elm = api.createComment(vnode.text); } else if (sel !== undefined) { const elm = vnode.elm || (vnode.elm = isDef(data) && isDef((i = data.ns)) ? api.createElementNS(i, sel) : api.createElement(sel)); for (i = 0, iLen = cbs.create.length; i < iLen; ++i) cbs.create[i](emptyNode, vnode); if (array(children)) { for (i = 0, iLen = children.length; i < iLen; ++i) { const ch = children[i]; if (ch != null) { api.appendChild(elm, createElm(ch, insertedVnodeQueue)); } } } else if (primitive(vnode.text)) { api.appendChild(elm, api.createTextNode(vnode.text)); } i = vnode.data.hook; // Reuse variable if (isDef(i)) { if (i.create) i.create(emptyNode, vnode); if (i.insert) insertedVnodeQueue.push(vnode); } } else { vnode.elm = api.createTextNode(vnode.text); } return vnode.elm; } function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) { for (; startIdx <= endIdx; ++startIdx) { const ch = vnodes[startIdx]; if (ch != null) { api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before); } } } function invokeDestroyHook(vnode) { let i, iLen, j, jLen, data = vnode.data; if (data !== undefined) { if (isDef((i = data.hook)) && isDef((i = i.destroy))) i(vnode); for (i = 0, iLen = cbs.destroy.length; i < iLen; ++i) cbs.destroy[i](vnode); if (vnode.children !== undefined) { for (j = 0, jLen = vnode.children.length; j < jLen; ++j) { i = vnode.children[j]; if (i != null && typeof i !== "string") { invokeDestroyHook(i); } } } } } function removeVnodes(parentElm, vnodes, startIdx, endIdx) { for (; startIdx <= endIdx; ++startIdx) { let i, iLen, listeners, rm, ch = vnodes[startIdx]; if (ch != null) { if (isDef(ch.sel)) { invokeDestroyHook(ch); listeners = cbs.remove.length + 1; rm = createRmCb(ch.elm, listeners); for (i = 0, iLen = cbs.remove.length; i < iLen; ++i) cbs.remove[i](ch, rm); if (isDef((i = ch.data)) && isDef((i = i.hook)) && isDef((i = i.remove))) { i(ch, rm); } else { rm(); } } else { // Text node api.removeChild(parentElm, ch.elm); } } } } function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) { let oldStartIdx = 0, newStartIdx = 0; let oldEndIdx = oldCh.length - 1; let oldStartVnode = oldCh[0]; let oldEndVnode = oldCh[oldEndIdx]; let newEndIdx = newCh.length - 1; let newStartVnode = newCh[0]; let newEndVnode = newCh[newEndIdx]; let oldKeyToIdx; let idxInOld; let elmToMove; let before; while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) { if (oldStartVnode == null) { oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left } else if (oldEndVnode == null) { oldEndVnode = oldCh[--oldEndIdx]; } else if (newStartVnode == null) { newStartVnode = newCh[++newStartIdx]; } else if (newEndVnode == null) { newEndVnode = newCh[--newEndIdx]; } else if (sameVnode(oldStartVnode, newStartVnode)) { patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue); oldStartVnode = oldCh[++oldStartIdx]; newStartVnode = newCh[++newStartIdx]; } else if (sameVnode(oldEndVnode, newEndVnode)) { patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue); oldEndVnode = oldCh[--oldEndIdx]; newEndVnode = newCh[--newEndIdx]; } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue); api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm)); oldStartVnode = oldCh[++oldStartIdx]; newEndVnode = newCh[--newEndIdx]; } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue); api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm); oldEndVnode = oldCh[--oldEndIdx]; newStartVnode = newCh[++newStartIdx]; } else { if (oldKeyToIdx === undefined) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); } idxInOld = oldKeyToIdx[newStartVnode.key]; if (isUndef(idxInOld)) { // New element api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm); newStartVnode = newCh[++newStartIdx]; } else { elmToMove = oldCh[idxInOld]; if (elmToMove.sel !== newStartVnode.sel) { api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm); } else { patchVnode(elmToMove, newStartVnode, insertedVnodeQueue); oldCh[idxInOld] = undefined; api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm); } newStartVnode = newCh[++newStartIdx]; } } } if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) { if (oldStartIdx > oldEndIdx) { before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm; addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue); } else { removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx); } } } function patchVnode(oldVnode, vnode, insertedVnodeQueue) { let i, iLen, hook; if (isDef((i = vnode.data)) && isDef((hook = i.hook)) && isDef((i = hook.prepatch))) { i(oldVnode, vnode); } const elm = (vnode.elm = oldVnode.elm); let oldCh = oldVnode.children; let ch = vnode.children; if (oldVnode === vnode) return; if (vnode.data !== undefined) { for (i = 0, iLen = cbs.update.length; i < iLen; ++i) cbs.update[i](oldVnode, vnode); i = vnode.data.hook; if (isDef(i) && isDef((i = i.update))) i(oldVnode, vnode); } if (isUndef(vnode.text)) { if (isDef(oldCh) && isDef(ch)) { if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue); } else if (isDef(ch)) { if (isDef(oldVnode.text)) api.setTextContent(elm, ""); addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue); } else if (isDef(oldCh)) { removeVnodes(elm, oldCh, 0, oldCh.length - 1); } else if (isDef(oldVnode.text)) { api.setTextContent(elm, ""); } } else if (oldVnode.text !== vnode.text) { if (isDef(oldCh)) { removeVnodes(elm, oldCh, 0, oldCh.length - 1); } api.setTextContent(elm, vnode.text); } if (isDef(hook) && isDef((i = hook.postpatch))) { i(oldVnode, vnode); } } return function patch(oldVnode, vnode) { let i, iLen, elm, parent; const insertedVnodeQueue = []; for (i = 0, iLen = cbs.pre.length; i < iLen; ++i) cbs.pre[i](); if (!isVnode(oldVnode)) { oldVnode = emptyNodeAt(oldVnode); } if (sameVnode(oldVnode, vnode)) { patchVnode(oldVnode, vnode, insertedVnodeQueue); } else { elm = oldVnode.elm; parent = api.parentNode(elm); createElm(vnode, insertedVnodeQueue); if (parent !== null) { api.insertBefore(parent, vnode.elm, api.nextSibling(elm)); removeVnodes(parent, [oldVnode], 0, 0); } } for (i = 0, iLen = insertedVnodeQueue.length; i < iLen; ++i) { insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]); } for (i = 0, iLen = cbs.post.length; i < iLen; ++i) cbs.post[i](); return vnode; }; } //------------------------------------------------------------------------------ // is.ts //------------------------------------------------------------------------------ const array = Array.isArray; function primitive(s) { return typeof s === "string" || typeof s === "number"; } function createElement(tagName) { return document.createElement(tagName); } function createElementNS(namespaceURI, qualifiedName) { return document.createElementNS(namespaceURI, qualifiedName); } function createTextNode(text) { return document.createTextNode(text); } function createComment(text) { return document.createComment(text); } function insertBefore(parentNode, newNode, referenceNode) { parentNode.insertBefore(newNode, referenceNode); } function removeChild(node, child) { node.removeChild(child); } function appendChild(node, child) { node.appendChild(child); } function parentNode(node) { return node.parentNode; } function nextSibling(node) { return node.nextSibling; } function tagName(elm) { return elm.tagName; } function setTextContent(node, text) { node.textContent = text; } const htmlDomApi = { createElement, createElementNS, createTextNode, createComment, insertBefore, removeChild, appendChild, parentNode, nextSibling, tagName, setTextContent, }; function addNS(data, children, sel) { if (sel === "dummy") { // we do not need to add the namespace on dummy elements, they come from a // subcomponent, which will handle the namespace itself return; } data.ns = "http://www.w3.org/2000/svg"; if (sel !== "foreignObject" && children !== undefined) { for (let i = 0, iLen = children.length; i < iLen; ++i) { const child = children[i]; let childData = child.data; if (childData !== undefined) { addNS(childData, child.children, child.sel); } } } } function h(sel, b, c) { var data = {}, children, text, i, iLen; if (c !== undefined) { data = b; if (array(c)) { children = c; } else if (primitive(c)) { text = c; } else if (c && c.sel) { children = [c]; } } else if (b !== undefined) { if (array(b)) { children = b; } else if (primitive(b)) { text = b; } else if (b && b.sel) { children = [b]; } else { data = b; } } if (children !== undefined) { for (i = 0, iLen = children.length; i < iLen; ++i) { if (primitive(children[i])) children[i] = vnode(undefined, undefined, undefined, children[i], undefined); } } return vnode(sel, data, children, text, undefined); } const patch = init([eventListenersModule, attrsModule, propsModule, classModule]); let localStorage = null; const browser = { setTimeout: window.setTimeout.bind(window), clearTimeout: window.clearTimeout.bind(window), setInterval: window.setInterval.bind(window), clearInterval: window.clearInterval.bind(window), requestAnimationFrame: window.requestAnimationFrame.bind(window), random: Math.random, Date: window.Date, fetch: (window.fetch || (() => { })).bind(window), get localStorage() { return localStorage || window.localStorage; }, set localStorage(newLocalStorage) { localStorage = newLocalStorage; }, }; /** * Owl Utils * * We have here a small collection of utility functions: * * - whenReady * - loadJS * - loadFile * - escape * - debounce */ function whenReady(fn) { return new Promise(function (resolve) { if (document.readyState !== "loading") { resolve(); } else { document.addEventListener("DOMContentLoaded", resolve, false); } }).then(fn || function () { }); } const loadedScripts = {}; function loadJS(url) { if (url in loadedScripts) { return loadedScripts[url]; } const promise = new Promise(function (resolve, reject) { const script = document.createElement("script"); script.type = "text/javascript"; script.src = url; script.onload = function () { resolve(); }; script.onerror = function () { reject(`Error loading file '${url}'`); }; const head = document.head || document.getElementsByTagName("head")[0]; head.appendChild(script); }); loadedScripts[url] = promise; return promise; } async function loadFile(url) { const result = await browser.fetch(url); if (!result.ok) { throw new Error("Error while fetching xml templates"); } return await result.text(); } function escape(str) { if (str === undefined) { return ""; } if (typeof str === "number") { return String(str); } const p = document.createElement("p"); p.textContent = str; return p.innerHTML; } /** * Returns a function, that, as long as it continues to be invoked, will not * be triggered. The function will be called after it stops being called for * N milliseconds. If `immediate` is passed, trigger the function on the * leading edge, instead of the trailing. * * Inspired by https://davidwalsh.name/javascript-debounce-function */ function debounce(func, wait, immediate) { let timeout; return function () { const context = this; const args = arguments; function later() { timeout = null; if (!immediate) { func.apply(context, args); } } const callNow = immediate && !timeout; browser.clearTimeout(timeout); timeout = browser.setTimeout(later, wait); if (callNow) { func.apply(context, args); } }; } function shallowEqual(p1, p2) { for (let k in p1) { if (p1[k] !== p2[k]) { return false; } } return true; } var _utils = /*#__PURE__*/Object.freeze({ __proto__: null, whenReady: whenReady, loadJS: loadJS, loadFile: loadFile, escape: escape, debounce: debounce, shallowEqual: shallowEqual }); //------------------------------------------------------------------------------ // Const/global stuff/helpers //------------------------------------------------------------------------------ const TRANSLATABLE_ATTRS = ["label", "title", "placeholder", "alt"]; const lineBreakRE = /[\r\n]/; const whitespaceRE = /\s+/g; const translationRE = /^(\s*)([\s\S]+?)(\s*)$/; const NODE_HOOKS_PARAMS = { create: "(_, n)", insert: "vn", remove: "(vn, rm)", destroy: "()", }; function isComponent(obj) { return obj && obj.hasOwnProperty("__owl__"); } class VDomArray extends Array { toString() { return vDomToString(this); } } function vDomToString(vdom) { return vdom .map((vnode) => { if (vnode.sel) { const node = document.createElement(vnode.sel); const result = patch(node, vnode); return result.elm.outerHTML; } else { return vnode.text; } }) .join(""); } const UTILS = { zero: Symbol("zero"), toClassObj(expr) { const result = {}; if (typeof expr === "string") { // we transform here a list of classes into an object: // 'hey you' becomes {hey: true, you: true} expr = expr.trim(); if (!expr) { return {}; } let words = expr.split(/\s+/); for (let i = 0; i < words.length; i++) { result[words[i]] = true; } return result; } // this is already an object, but we may need to split keys: // {'a b': true, 'a c': false} should become {a: true, b: true, c: false} for (let key in expr) { const value = expr[key]; const words = key.split(/\s+/); for (let word of words) { result[word] = result[word] || value; } } return result; }, /** * This method combines the current context with the variables defined in a * scope for use in a slot. * * The implementation is kind of tricky because we want to preserve the * prototype chain structure of the cloned result. So we need to traverse the * prototype chain, cloning each level respectively. */ combine(context, scope) { let clone = context; const scopeStack = []; while (!isComponent(scope)) { scopeStack.push(scope); scope = scope.__proto__; } while (scopeStack.length) { let scope = scopeStack.pop(); clone = Object.create(clone); Object.assign(clone, scope); } return clone; }, shallowEqual, addNameSpace(vnode) { addNS(vnode.data, vnode.children, vnode.sel); }, VDomArray, vDomToString, getComponent(obj) { while (obj && !isComponent(obj)) { obj = obj.__proto__; } return obj; }, getScope(obj, property) { const obj0 = obj; while (obj && !obj.hasOwnProperty(property) && !(obj.hasOwnProperty("__access_mode__") && obj.__access_mode__ === "ro")) { const newObj = obj.__proto__; if (!newObj || isComponent(newObj)) { return obj0; } obj = newObj; } return obj; }, }; function parseXML(xml) { const parser = new DOMParser(); const doc = parser.parseFromString(xml, "text/xml"); if (doc.getElementsByTagName("parsererror").length) { let msg = "Invalid XML in template."; const parsererrorText = doc.getElementsByTagName("parsererror")[0].textContent; if (parsererrorText) { msg += "\nThe parser has produced the following error message:\n" + parsererrorText; const re = /\d+/g; const firstMatch = re.exec(parsererrorText); if (firstMatch) { const lineNumber = Number(firstMatch[0]); const line = xml.split("\n")[lineNumber - 1]; const secondMatch = re.exec(parsererrorText); if (line && secondMatch) { const columnIndex = Number(secondMatch[0]) - 1; if (line[columnIndex]) { msg += `\nThe error might be located at xml line ${lineNumber} column ${columnIndex}\n` + `${line}\n${"-".repeat(columnIndex - 1)}^`; } } } } throw new Error(msg); } return doc; } function escapeQuotes(str) { return str.replace(/\'/g, "\\'"); } //------------------------------------------------------------------------------ // QWeb rendering engine //------------------------------------------------------------------------------ class QWeb extends EventBus { constructor(config = {}) { super(); this.h = h; // subTemplates are stored in two objects: a (local) mapping from a name to an // id, and a (global) mapping from an id to the compiled function. This is // necessary to ensure that global templates can be called with more than one // QWeb instance. this.subTemplates = {}; this.isUpdating = false; this.templates = Object.create(QWeb.TEMPLATES); if (config.templates) { this.addTemplates(config.templates); } if (config.translateFn) { this.translateFn = config.translateFn; } } static addDirective(directive) { if (directive.name in QWeb.DIRECTIVE_NAMES) { throw new Error(`Directive "${directive.name} already registered`); } QWeb.DIRECTIVES.push(directive); QWeb.DIRECTIVE_NAMES[directive.name] = 1; QWeb.DIRECTIVES.sort((d1, d2) => d1.priority - d2.priority); if (directive.extraNames) { directive.extraNames.forEach((n) => (QWeb.DIRECTIVE_NAMES[n] = 1)); } } static registerComponent(name, Component) { if (QWeb.components[name]) { throw new Error(`Component '${name}' has already been registered`); } QWeb.components[name] = Component; } /** * Register globally a template. All QWeb instances will obtain their * templates from their own template map, and then, from the global static * TEMPLATES property. */ static registerTemplate(name, template) { if (QWeb.TEMPLATES[name]) { throw new Error(`Template '${name}' has already been registered`); } const qweb = new QWeb(); qweb.addTemplate(name, template); QWeb.TEMPLATES[name] = qweb.templates[name]; } /** * Add a template to the internal template map. Note that it is not * immediately compiled. */ addTemplate(name, xmlString, allowDuplicate) { if (allowDuplicate && name in this.templates) { return; } const doc = parseXML(xmlString); if (!doc.firstChild) { throw new Error("Invalid template (should not be empty)"); } this._addTemplate(name, doc.firstChild); } /** * Load templates from a xml (as a string or xml document). This will look up * for the first tag, and will consider each child of this as a * template, with the name given by the t-name attribute. */ addTemplates(xmlstr) { if (!xmlstr) { return; } const doc = typeof xmlstr === "string" ? parseXML(xmlstr) : xmlstr; const templates = doc.getElementsByTagName("templates")[0]; if (!templates) { return; } for (let elem of templates.children) { const name = elem.getAttribute("t-name"); this._addTemplate(name, elem); } } _addTemplate(name, elem) { if (name in this.templates) { throw new Error(`Template ${name} already defined`); } this._processTemplate(elem); const template = { elem, fn: function (context, extra) { const compiledFunction = this._compile(name); template.fn = compiledFunction; return compiledFunction.call(this, context, extra); }, }; this.templates[name] = template; } _processTemplate(elem) { let tbranch = elem.querySelectorAll("[t-elif], [t-else]"); for (let i = 0, ilen = tbranch.length; i < ilen; i++) { let node = tbranch[i]; let prevElem = node.previousElementSibling; let pattr = function (name) { return prevElem.getAttribute(name); }; let nattr = function (name) { return +!!node.getAttribute(name); }; if (prevElem && (pattr("t-if") || pattr("t-elif"))) { if (pattr("t-foreach")) { throw new Error("t-if cannot stay at the same level as t-foreach when using t-elif or t-else"); } if (["t-if", "t-elif", "t-else"].map(nattr).reduce(function (a, b) { return a + b; }) > 1) { throw new Error("Only one conditional branching directive is allowed per node"); } // All text (with only spaces) and comment nodes (nodeType 8) between // branch nodes are removed let textNode; while ((textNode = node.previousSibling) !== prevElem) { if (textNode.nodeValue.trim().length && textNode.nodeType !== 8) { throw new Error("text is not allowed between branching directives"); } textNode.remove(); } } else { throw new Error("t-elif and t-else directives must be preceded by a t-if or t-elif directive"); } } } /** * Render a template * * @param {string} name the template should already have been added */ render(name, context = {}, extra = null) { const template = this.templates[name]; if (!template) { throw new Error(`Template ${name} does not exist`); } return template.fn.call(this, context, extra); } /** * Render a template to a html string. * * Note that this is more limited than the `render` method: it is not suitable * to render a full component tree, since this is an asynchronous operation. * This method can only render templates without components. */ renderToString(name, context = {}, extra) { const vnode = this.render(name, context, extra); if (vnode.sel === undefined) { return vnode.text; } const node = document.createElement(vnode.sel); const result = patch(node, vnode); return result.elm.outerHTML; } /** * Force all widgets connected to this QWeb instance to rerender themselves. * * This method is mostly useful for external code that want to modify the * application in some cases. For example, a router plugin. */ forceUpdate() { this.isUpdating = true; Promise.resolve().then(() => { if (this.isUpdating) { this.isUpdating = false; this.trigger("update"); } }); } _compile(name, options = {}) { const elem = options.elem || this.templates[name].elem; const isDebug = elem.attributes.hasOwnProperty("t-debug"); const ctx = new CompilationContext(name); if (elem.tagName !== "t") { ctx.shouldDefineResult = false; } if (options.hasParent) { ctx.variables = Object.create(null); ctx.parentNode = ctx.generateID(); ctx.allowMultipleRoots = true; ctx.shouldDefineParent = true; ctx.hasParentWidget = true; ctx.shouldDefineResult = false; ctx.addLine(`let c${ctx.parentNode} = extra.parentNode;`); if (options.defineKey) { ctx.addLine(`let key0 = extra.key || "";`); ctx.hasKey0 = true; } } this._compileNode(elem, ctx); if (!options.hasParent) { if (ctx.shouldDefineResult) { ctx.addLine(`return result;`); } else { if (!ctx.rootNode) { throw new Error(`A template should have one root node (${ctx.templateName})`); } ctx.addLine(`return vn${ctx.rootNode};`); } } let code = ctx.generateCode(); const templateName = ctx.templateName.replace(/`/g, "'").slice(0, 200); code.unshift(` // Template name: "${templateName}"`); let template; try { template = new Function("context, extra", code.join("\n")); } catch (e) { console.groupCollapsed(`Invalid Code generated by ${templateName}`); console.warn(code.join("\n")); console.groupEnd(); throw new Error(`Invalid generated code while compiling template '${templateName}': ${e.message}`); } if (isDebug) { const tpl = this.templates[name]; if (tpl) { const msg = `Template: ${tpl.elem.outerHTML}\nCompiled code:\n${template.toString()}`; console.log(msg); } } return template; } /** * Generate code from an xml node * */ _compileNode(node, ctx) { if (!(node instanceof Element)) { // this is a text node, there are no directive to apply let text = node.textContent; if (!ctx.inPreTag) { if (lineBreakRE.test(text) && !text.trim()) { return; } text = text.replace(whitespaceRE, " "); } if (this.translateFn) { if (node.parentNode.getAttribute("t-translation") !== "off") { const match = translationRE.exec(text); text = match[1] + this.translateFn(match[2]) + match[3]; } } if (ctx.parentNode) { if (node.nodeType === 3) { ctx.addLine(`c${ctx.parentNode}.push({text: \`${text}\`});`); } else if (node.nodeType === 8) { ctx.addLine(`c${ctx.parentNode}.push(h('!', \`${text}\`));`); } } else if (ctx.parentTextNode) { ctx.addLine(`vn${ctx.parentTextNode}.text += \`${text}\`;`); } else { // this is an unusual situation: this text node is the result of the // template rendering. let nodeID = ctx.generateID(); ctx.addLine(`let vn${nodeID} = {text: \`${text}\`};`); ctx.addLine(`result = vn${nodeID};`); ctx.rootContext.rootNode = nodeID; ctx.rootContext.parentTextNode = nodeID; } return; } if (node.tagName !== "t" && node.hasAttribute("t-call")) { const tCallNode = document.implementation.createDocument("http://www.w3.org/1999/xhtml", "t", null).documentElement; tCallNode.setAttribute("t-call", node.getAttribute("t-call")); node.removeAttribute("t-call"); node.prepend(tCallNode); } const firstLetter = node.tagName[0]; if (firstLetter === firstLetter.toUpperCase()) { // this is a component, we modify in place the xml document to change // to node.setAttribute("t-component", node.tagName); } else if (node.tagName !== "t" && node.hasAttribute("t-component")) { throw new Error(`Directive 't-component' can only be used on nodes (used on a <${node.tagName}>)`); } const attributes = node.attributes; const validDirectives = []; const finalizers = []; // maybe this is not optimal: we iterate on all attributes here, and again // just after for each directive. for (let i = 0; i < attributes.length; i++) { let attrName = attributes[i].name; if (attrName.startsWith("t-")) { let dName = attrName.slice(2).split(/-|\./)[0]; if (!(dName in QWeb.DIRECTIVE_NAMES)) { throw new Error(`Unknown QWeb directive: '${attrName}'`); } if (node.tagName !== "t" && (attrName === "t-esc" || attrName === "t-raw")) { const tNode = document.implementation.createDocument("http://www.w3.org/1999/xhtml", "t", null).documentElement; tNode.setAttribute(attrName, node.getAttribute(attrName)); for (let child of Array.from(node.childNodes)) { tNode.appendChild(child); } node.appendChild(tNode); node.removeAttribute(attrName); } } } const DIR_N = QWeb.DIRECTIVES.length; const ATTR_N = attributes.length; let withHandlers = false; for (let i = 0; i < DIR_N; i++) { let directive = QWeb.DIRECTIVES[i]; let fullName; let value; for (let j = 0; j < ATTR_N; j++) { const name = attributes[j].name; if (name === "t-" + directive.name || name.startsWith("t-" + directive.name + "-") || name.startsWith("t-" + directive.name + ".")) { fullName = name; value = attributes[j].textContent; validDirectives.push({ directive, value, fullName }); if (directive.name === "on" || directive.name === "model") { withHandlers = true; } } } } for (let { directive, value, fullName } of validDirectives) { if (directive.finalize) { finalizers.push({ directive, value, fullName }); } if (directive.atNodeEncounter) { const isDone = directive.atNodeEncounter({ node, qweb: this, ctx, fullName, value, }); if (isDone) { for (let { directive, value, fullName } of finalizers) { directive.finalize({ node, qweb: this, ctx, fullName, value }); } return; } } } if (node.nodeName !== "t" || node.hasAttribute("t-tag")) { let nodeHooks = {}; let addNodeHook = function (hook, handler) { nodeHooks[hook] = nodeHooks[hook] || []; nodeHooks[hook].push(handler); }; if (node.tagName === "select" && node.hasAttribute("t-att-value")) { const value = node.getAttribute("t-att-value"); let exprId = ctx.generateID(); ctx.addLine(`let expr${exprId} = ${ctx.formatExpression(value)};`); let expr = `expr${exprId}`; node.setAttribute("t-att-value", expr); addNodeHook("create", `n.elm.value=${expr};`); } let nodeID = this._compileGenericNode(node, ctx, withHandlers); ctx = ctx.withParent(nodeID); for (let { directive, value, fullName } of validDirectives) { if (directive.atNodeCreation) { directive.atNodeCreation({ node, qweb: this, ctx, fullName, value, nodeID, addNodeHook, }); } } if (Object.keys(nodeHooks).length) { ctx.addLine(`p${nodeID}.hook = {`); for (let hook in nodeHooks) { ctx.addLine(` ${hook}: ${NODE_HOOKS_PARAMS[hook]} => {`); for (let handler of nodeHooks[hook]) { ctx.addLine(` ${handler}`); } ctx.addLine(` },`); } ctx.addLine(`};`); } } if (node.nodeName === "pre") { ctx = ctx.subContext("inPreTag", true); } this._compileChildren(node, ctx); // svg support // we hadd svg namespace if it is a svg or if it is a g, but only if it is // the root node. This is the easiest way to support svg sub components: // they need to have a g tag as root. Otherwise, we would need a complete // list of allowed svg tags. const shouldAddNS = node.nodeName === "svg" || (node.nodeName === "g" && ctx.rootNode === ctx.parentNode); if (shouldAddNS) { ctx.rootContext.shouldDefineUtils = true; ctx.addLine(`utils.addNameSpace(vn${ctx.parentNode});`); } for (let { directive, value, fullName } of finalizers) { directive.finalize({ node, qweb: this, ctx, fullName, value }); } } _compileGenericNode(node, ctx, withHandlers = true) { // nodeType 1 is generic tag if (node.nodeType !== 1) { throw new Error("unsupported node type"); } const attributes = node.attributes; const attrs = []; const props = []; const tattrs = []; function handleProperties(key, val) { let isProp = false; switch (node.nodeName) { case "input": let type = node.getAttribute("type"); if (type === "checkbox" || type === "radio") { if (key === "checked" || key === "indeterminate") { isProp = true; } } if (key === "value" || key === "readonly" || key === "disabled") { isProp = true; } break; case "option": isProp = key === "selected" || key === "disabled"; break; case "textarea": isProp = key === "readonly" || key === "disabled" || key === "value"; break; case "select": isProp = key === "disabled" || key === "value"; break; case "button": case "optgroup": isProp = key === "disabled"; break; } if (isProp) { props.push(`${key}: ${val}`); } } let classObj = ""; for (let i = 0; i < attributes.length; i++) { let name = attributes[i].name; let value = attributes[i].textContent; if (this.translateFn && TRANSLATABLE_ATTRS.includes(name)) { value = this.translateFn(value); } // regular attributes if (!name.startsWith("t-") && !node.getAttribute("t-attf-" + name)) { const attID = ctx.generateID(); if (name === "class") { if ((value = value.trim())) { let classDef = value .split(/\s+/) .map((a) => `'${escapeQuotes(a)}':true`) .join(","); if (classObj) { ctx.addLine(`Object.assign(${classObj}, {${classDef}})`); } else { classObj = `_${ctx.generateID()}`; ctx.addLine(`let ${classObj} = {${classDef}};`); } } } else { ctx.addLine(`let _${attID} = '${escapeQuotes(value)}';`); if (!name.match(/^[a-zA-Z]+$/)) { // attribute contains 'non letters' => we want to quote it name = '"' + name + '"'; } attrs.push(`${name}: _${attID}`); handleProperties(name, `_${attID}`); } } // dynamic attributes if (name.startsWith("t-att-")) { let attName = name.slice(6); const v = ctx.getValue(value); let formattedValue = typeof v === "string" ? ctx.formatExpression(v) : `scope.${v.id}`; if (attName === "class") { ctx.rootContext.shouldDefineUtils = true; formattedValue = `utils.toClassObj(${formattedValue})`; if (classObj) { ctx.addLine(`Object.assign(${classObj}, ${formattedValue})`); } else { classObj = `_${ctx.generateID()}`; ctx.addLine(`let ${classObj} = ${formattedValue};`); } } else { const attID = ctx.generateID(); if (!attName.match(/^[a-zA-Z]+$/)) { // attribute contains 'non letters' => we want to quote it attName = '"' + attName + '"'; } // we need to combine dynamic with non dynamic attributes: // class="a" t-att-class="'yop'" should be rendered as class="a yop" const attValue = node.getAttribute(attName); if (attValue) { const attValueID = ctx.generateID(); ctx.addLine(`let _${attValueID} = ${formattedValue};`); formattedValue = `'${attValue}' + (_${attValueID} ? ' ' + _${attValueID} : '')`; const attrIndex = attrs.findIndex((att) => att.startsWith(attName + ":")); attrs.splice(attrIndex, 1); } if (node.nodeName === "select" && attName === "value") { attrs.push(`${attName}: ${v}`); handleProperties(attName, v); } else { ctx.addLine(`let _${attID} = ${formattedValue};`); attrs.push(`${attName}: _${attID}`); handleProperties(attName, "_" + attID); } } } if (name.startsWith("t-attf-")) { let attName = name.slice(7); if (!attName.match(/^[a-zA-Z]+$/)) { // attribute contains 'non letters' => we want to quote it attName = '"' + attName + '"'; } const formattedExpr = ctx.interpolate(value); const attID = ctx.generateID(); let staticVal = node.getAttribute(attName); if (staticVal) { ctx.addLine(`let _${attID} = '${staticVal} ' + ${formattedExpr};`); } else { ctx.addLine(`let _${attID} = ${formattedExpr};`); } attrs.push(`${attName}: _${attID}`); } // t-att= attributes if (name === "t-att") { let id = ctx.generateID(); ctx.addLine(`let _${id} = ${ctx.formatExpression(value)};`); tattrs.push(id); } } let nodeID = ctx.generateID(); let key = ctx.loopNumber || ctx.hasKey0 ? `\`\${key${ctx.loopNumber}}_${nodeID}\`` : nodeID; const parts = [`key:${key}`]; if (attrs.length + tattrs.length > 0) { parts.push(`attrs:{${attrs.join(",")}}`); } if (props.length > 0) { parts.push(`props:{${props.join(",")}}`); } if (classObj) { parts.push(`class:${classObj}`); } if (withHandlers) { parts.push(`on:{}`); } ctx.addLine(`let c${nodeID} = [], p${nodeID} = {${parts.join(",")}};`); for (let id of tattrs) { ctx.addIf(`_${id} instanceof Array`); ctx.addLine(`p${nodeID}.attrs[_${id}[0]] = _${id}[1];`); ctx.addElse(); ctx.addLine(`for (let key in _${id}) {`); ctx.indent(); ctx.addLine(`p${nodeID}.attrs[key] = _${id}[key];`); ctx.dedent(); ctx.addLine(`}`); ctx.closeIf(); } let nodeName = `'${node.nodeName}'`; if (node.hasAttribute("t-tag")) { const tagExpr = node.getAttribute("t-tag"); node.removeAttribute("t-tag"); nodeName = `tag${ctx.generateID()}`; ctx.addLine(`let ${nodeName} = ${ctx.formatExpression(tagExpr)};`); } ctx.addLine(`let vn${nodeID} = h(${nodeName}, p${nodeID}, c${nodeID});`); if (ctx.parentNode) { ctx.addLine(`c${ctx.parentNode}.push(vn${nodeID});`); } else if (ctx.loopNumber || ctx.hasKey0) { ctx.rootContext.shouldDefineResult = true; ctx.addLine(`result = vn${nodeID};`); } return nodeID; } _compileChildren(node, ctx) { if (node.childNodes.length > 0) { for (let child of Array.from(node.childNodes)) { this._compileNode(child, ctx); } } } } QWeb.utils = UTILS; QWeb.components = Object.create(null); QWeb.DIRECTIVE_NAMES = { name: 1, att: 1, attf: 1, translation: 1, tag: 1, }; QWeb.DIRECTIVES = []; QWeb.TEMPLATES = {}; QWeb.nextId = 1; // dev mode enables better error messages or more costly validations QWeb.dev = false; QWeb.enableTransitions = true; // slots contains sub templates defined with t-set inside t-component nodes, and // are meant to be used by the t-slot directive. QWeb.slots = {}; QWeb.nextSlotId = 1; QWeb.subTemplates = {}; const parser = new DOMParser(); function htmlToVDOM(html) { const doc = parser.parseFromString(html, "text/html"); const result = []; for (let child of doc.body.childNodes) { result.push(htmlToVNode(child)); } return result; } function htmlToVNode(node) { if (!(node instanceof Element)) { if (node instanceof Comment) { return h("!", node.textContent); } return { text: node.textContent }; } const attrs = {}; for (let attr of node.attributes) { attrs[attr.name] = attr.textContent; } const children = []; for (let c of node.childNodes) { children.push(htmlToVNode(c)); } const vnode = h(node.tagName, { attrs }, children); if (vnode.sel === "svg") { addNS(vnode.data, vnode.children, vnode.sel); } return vnode; } /** * Owl QWeb Directives * * This file contains the implementation of most standard QWeb directives: * - t-esc * - t-raw * - t-set/t-value * - t-if/t-elif/t-else * - t-call * - t-foreach/t-as * - t-debug * - t-log */ //------------------------------------------------------------------------------ // t-esc and t-raw //------------------------------------------------------------------------------ QWeb.utils.htmlToVDOM = htmlToVDOM; function compileValueNode(value, node, qweb, ctx) { ctx.rootContext.shouldDefineScope = true; if (value === "0") { if (ctx.parentNode) { // the 'zero' magical symbol is where we can find the result of the rendering // of the body of the t-call. ctx.rootContext.shouldDefineUtils = true; const zeroArgs = ctx.escaping ? `{text: utils.vDomToString(scope[utils.zero])}` : `...scope[utils.zero]`; ctx.addLine(`c${ctx.parentNode}.push(${zeroArgs});`); } return; } let exprID; if (typeof value === "string") { exprID = `_${ctx.generateID()}`; ctx.addLine(`let ${exprID} = ${ctx.formatExpression(value)};`); } else { exprID = `scope.${value.id}`; } ctx.addIf(`${exprID} != null`); if (ctx.escaping) { let protectID; if (value.hasBody) { ctx.rootContext.shouldDefineUtils = true; protectID = ctx.startProtectScope(); ctx.addLine(`${exprID} = ${exprID} instanceof utils.VDomArray ? utils.vDomToString(${exprID}) : ${exprID};`); } if (ctx.parentTextNode) { ctx.addLine(`vn${ctx.parentTextNode}.text += ${exprID};`); } else if (ctx.parentNode) { ctx.addLine(`c${ctx.parentNode}.push({text: ${exprID}});`); } else { let nodeID = ctx.generateID(); ctx.rootContext.rootNode = nodeID; ctx.rootContext.parentTextNode = nodeID; ctx.addLine(`let vn${nodeID} = {text: ${exprID}};`); if (ctx.rootContext.shouldDefineResult) { ctx.addLine(`result = vn${nodeID}`); } } if (value.hasBody) { ctx.stopProtectScope(protectID); } } else { ctx.rootContext.shouldDefineUtils = true; if (value.hasBody) { ctx.addLine(`const vnodeArray = ${exprID} instanceof utils.VDomArray ? ${exprID} : utils.htmlToVDOM(${exprID});`); ctx.addLine(`c${ctx.parentNode}.push(...vnodeArray);`); } else { ctx.addLine(`c${ctx.parentNode}.push(...utils.htmlToVDOM(${exprID}));`); } } if (node.childNodes.length) { ctx.addElse(); qweb._compileChildren(node, ctx); } ctx.closeIf(); } QWeb.addDirective({ name: "esc", priority: 70, atNodeEncounter({ node, qweb, ctx }) { let value = ctx.getValue(node.getAttribute("t-esc")); compileValueNode(value, node, qweb, ctx.subContext("escaping", true)); return true; }, }); QWeb.addDirective({ name: "raw", priority: 80, atNodeEncounter({ node, qweb, ctx }) { let value = ctx.getValue(node.getAttribute("t-raw")); compileValueNode(value, node, qweb, ctx); return true; }, }); //------------------------------------------------------------------------------ // t-set //------------------------------------------------------------------------------ QWeb.addDirective({ name: "set", extraNames: ["value"], priority: 60, atNodeEncounter({ node, qweb, ctx }) { ctx.rootContext.shouldDefineScope = true; const variable = node.getAttribute("t-set"); let value = node.getAttribute("t-value"); ctx.variables[variable] = ctx.variables[variable] || {}; let qwebvar = ctx.variables[variable]; const hasBody = node.hasChildNodes(); qwebvar.id = variable; qwebvar.expr = `scope.${variable}`; if (value) { const formattedValue = ctx.formatExpression(value); let scopeExpr = `scope`; if (ctx.protectedScopeNumber) { ctx.rootContext.shouldDefineUtils = true; scopeExpr = `utils.getScope(scope, '${variable}')`; } ctx.addLine(`${scopeExpr}.${variable} = ${formattedValue};`); qwebvar.value = formattedValue; } if (hasBody) { ctx.rootContext.shouldDefineUtils = true; if (value) { ctx.addIf(`!(${qwebvar.expr})`); } const tempParentNodeID = ctx.generateID(); const _parentNode = ctx.parentNode; ctx.parentNode = tempParentNodeID; ctx.addLine(`let c${tempParentNodeID} = new utils.VDomArray();`); const nodeCopy = node.cloneNode(true); for (let attr of ["t-set", "t-value", "t-if", "t-else", "t-elif"]) { nodeCopy.removeAttribute(attr); } qweb._compileNode(nodeCopy, ctx); ctx.addLine(`${qwebvar.expr} = c${tempParentNodeID}`); qwebvar.value = `c${tempParentNodeID}`; qwebvar.hasBody = true; ctx.parentNode = _parentNode; if (value) { ctx.closeIf(); } } return true; }, }); //------------------------------------------------------------------------------ // t-if, t-elif, t-else //------------------------------------------------------------------------------ QWeb.addDirective({ name: "if", priority: 20, atNodeEncounter({ node, ctx }) { let cond = ctx.getValue(node.getAttribute("t-if")); ctx.addIf(typeof cond === "string" ? ctx.formatExpression(cond) : `scope.${cond.id}`); return false; }, finalize({ ctx }) { ctx.closeIf(); }, }); QWeb.addDirective({ name: "elif", priority: 30, atNodeEncounter({ node, ctx }) { let cond = ctx.getValue(node.getAttribute("t-elif")); ctx.addLine(`else if (${typeof cond === "string" ? ctx.formatExpression(cond) : `scope.${cond.id}`}) {`); ctx.indent(); return false; }, finalize({ ctx }) { ctx.closeIf(); }, }); QWeb.addDirective({ name: "else", priority: 40, atNodeEncounter({ ctx }) { ctx.addLine(`else {`); ctx.indent(); return false; }, finalize({ ctx }) { ctx.closeIf(); }, }); //------------------------------------------------------------------------------ // t-call //------------------------------------------------------------------------------ QWeb.addDirective({ name: "call", priority: 50, atNodeEncounter({ node, qweb, ctx }) { // Step 1: sanity checks // ------------------------------------------------ ctx.rootContext.shouldDefineScope = true; ctx.rootContext.shouldDefineUtils = true; const subTemplate = node.getAttribute("t-call"); const isDynamic = INTERP_REGEXP.test(subTemplate); const nodeTemplate = qweb.templates[subTemplate]; if (!isDynamic && !nodeTemplate) { throw new Error(`Cannot find template "${subTemplate}" (t-call)`); } // Step 2: compile target template in sub templates // ------------------------------------------------ let subIdstr; if (isDynamic) { const _id = ctx.generateID(); ctx.addLine(`let tname${_id} = ${ctx.interpolate(subTemplate)};`); ctx.addLine(`let tid${_id} = this.subTemplates[tname${_id}];`); ctx.addIf(`!tid${_id}`); ctx.addLine(`tid${_id} = this.constructor.nextId++;`); ctx.addLine(`this.subTemplates[tname${_id}] = tid${_id};`); ctx.addLine(`this.constructor.subTemplates[tid${_id}] = this._compile(tname${_id}, {hasParent: true, defineKey: true});`); ctx.closeIf(); subIdstr = `tid${_id}`; } else { let subId = qweb.subTemplates[subTemplate]; if (!subId) { subId = QWeb.nextId++; qweb.subTemplates[subTemplate] = subId; const subTemplateFn = qweb._compile(subTemplate, { hasParent: true, defineKey: true }); QWeb.subTemplates[subId] = subTemplateFn; } subIdstr = `'${subId}'`; } // Step 3: compile t-call body if necessary // ------------------------------------------------ let hasBody = node.hasChildNodes(); const protectID = ctx.startProtectScope(); if (hasBody) { // we add a sub scope to protect the ambient scope ctx.addLine(`{`); ctx.indent(); const nodeCopy = node.cloneNode(true); for (let attr of ["t-if", "t-else", "t-elif", "t-call"]) { nodeCopy.removeAttribute(attr); } // this local scope is intended to trap c__0 ctx.addLine(`{`); ctx.indent(); ctx.addLine("let c__0 = [];"); qweb._compileNode(nodeCopy, ctx.subContext("parentNode", "__0")); ctx.rootContext.shouldDefineUtils = true; ctx.addLine("scope[utils.zero] = c__0;"); ctx.dedent(); ctx.addLine(`}`); } // Step 4: add the appropriate function call to current component // ------------------------------------------------ const parentComponent = ctx.rootContext.shouldDefineParent ? `parent` : `utils.getComponent(context)`; const key = ctx.generateTemplateKey(); const parentNode = ctx.parentNode ? `c${ctx.parentNode}` : "result"; const extra = `Object.assign({}, extra, {parentNode: ${parentNode}, parent: ${parentComponent}, key: ${key}})`; if (ctx.parentNode) { ctx.addLine(`this.constructor.subTemplates[${subIdstr}].call(this, scope, ${extra});`); } else { // this is a t-call with no parentnode, we need to extract the result ctx.rootContext.shouldDefineResult = true; ctx.addLine(`result = []`); ctx.addLine(`this.constructor.subTemplates[${subIdstr}].call(this, scope, ${extra});`); ctx.addLine(`result = result[0]`); } // Step 5: restore previous scope // ------------------------------------------------ if (hasBody) { ctx.dedent(); ctx.addLine(`}`); } ctx.stopProtectScope(protectID); return true; }, }); //------------------------------------------------------------------------------ // t-foreach //------------------------------------------------------------------------------ QWeb.addDirective({ name: "foreach", extraNames: ["as"], priority: 10, atNodeEncounter({ node, qweb, ctx }) { ctx.rootContext.shouldDefineScope = true; ctx = ctx.subContext("loopNumber", ctx.loopNumber + 1); const elems = node.getAttribute("t-foreach"); const name = node.getAttribute("t-as"); let arrayID = ctx.generateID(); ctx.addLine(`let _${arrayID} = ${ctx.formatExpression(elems)};`); ctx.addLine(`if (!_${arrayID}) { throw new Error('QWeb error: Invalid loop expression')}`); let keysID = ctx.generateID(); let valuesID = ctx.generateID(); ctx.addLine(`let _${keysID} = _${arrayID};`); ctx.addLine(`let _${valuesID} = _${arrayID};`); ctx.addIf(`!(_${arrayID} instanceof Array)`); ctx.addLine(`_${keysID} = Object.keys(_${arrayID});`); ctx.addLine(`_${valuesID} = Object.values(_${arrayID});`); ctx.closeIf(); ctx.addLine(`let _length${keysID} = _${keysID}.length;`); let varsID = ctx.startProtectScope(true); const loopVar = `i${ctx.loopNumber}`; ctx.addLine(`for (let ${loopVar} = 0; ${loopVar} < _length${keysID}; ${loopVar}++) {`); ctx.indent(); ctx.addLine(`scope.${name}_first = ${loopVar} === 0`); ctx.addLine(`scope.${name}_last = ${loopVar} === _length${keysID} - 1`); ctx.addLine(`scope.${name}_index = ${loopVar}`); ctx.addLine(`scope.${name} = _${keysID}[${loopVar}]`); ctx.addLine(`scope.${name}_value = _${valuesID}[${loopVar}]`); const nodeCopy = node.cloneNode(true); let shouldWarn = !nodeCopy.hasAttribute("t-key") && node.children.length === 1 && node.children[0].tagName !== "t" && !node.children[0].hasAttribute("t-key"); if (shouldWarn) { console.warn(`Directive t-foreach should always be used with a t-key! (in template: '${ctx.templateName}')`); } if (nodeCopy.hasAttribute("t-key")) { const expr = ctx.formatExpression(nodeCopy.getAttribute("t-key")); ctx.addLine(`let key${ctx.loopNumber} = ${expr};`); nodeCopy.removeAttribute("t-key"); } else { ctx.addLine(`let key${ctx.loopNumber} = i${ctx.loopNumber};`); } nodeCopy.removeAttribute("t-foreach"); qweb._compileNode(nodeCopy, ctx); ctx.dedent(); ctx.addLine("}"); ctx.stopProtectScope(varsID); return true; }, }); //------------------------------------------------------------------------------ // t-debug //------------------------------------------------------------------------------ QWeb.addDirective({ name: "debug", priority: 1, atNodeEncounter({ ctx }) { ctx.addLine("debugger;"); }, }); //------------------------------------------------------------------------------ // t-log //------------------------------------------------------------------------------ QWeb.addDirective({ name: "log", priority: 1, atNodeEncounter({ ctx, value }) { const expr = ctx.formatExpression(value); ctx.addLine(`console.log(${expr})`); }, }); /** * Owl QWeb Extensions * * This file contains the implementation of non standard QWeb directives, added * by Owl and that will only work on Owl projects: * * - t-on * - t-ref * - t-transition * - t-mounted * - t-slot * - t-model */ //------------------------------------------------------------------------------ // t-on //------------------------------------------------------------------------------ // these are pieces of code that will be injected into the event handler if // modifiers are specified const MODS_CODE = { prevent: "e.preventDefault();", self: "if (e.target !== this.elm) {return}", stop: "e.stopPropagation();", }; const FNAMEREGEXP = /^[$A-Z_][0-9A-Z_$]*$/i; function makeHandlerCode(ctx, fullName, value, putInCache, modcodes = MODS_CODE) { let [event, ...mods] = fullName.slice(5).split("."); if (mods.includes("capture")) { event = "!" + event; } if (!event) { throw new Error("Missing event name with t-on directive"); } let code; // check if it is a method with no args, a method with args or an expression let args = ""; const name = value.replace(/\(.*\)/, function (_args) { args = _args.slice(1, -1); return ""; }); const isMethodCall = name.match(FNAMEREGEXP); // then generate code if (isMethodCall) { ctx.rootContext.shouldDefineUtils = true; const comp = `utils.getComponent(context)`; if (args) { const argId = ctx.generateID(); ctx.addLine(`let args${argId} = [${ctx.formatExpression(args)}];`); code = `${comp}['${name}'](...args${argId}, e);`; putInCache = false; } else { code = `${comp}['${name}'](e);`; } } else { // if we get here, then it is an expression // we need to capture every variable in it putInCache = false; code = ctx.captureExpression(value); code = `const res = (() => { return ${code} })(); if (typeof res === 'function') { res(e) }`; } const modCode = mods.map((mod) => modcodes[mod]).join(""); let handler = `function (e) {if (context.__owl__.status === ${5 /* DESTROYED */}){return}${modCode}${code}}`; if (putInCache) { const key = ctx.generateTemplateKey(event); ctx.addLine(`extra.handlers[${key}] = extra.handlers[${key}] || ${handler};`); handler = `extra.handlers[${key}]`; } return { event, handler }; } QWeb.addDirective({ name: "on", priority: 90, atNodeCreation({ ctx, fullName, value, nodeID }) { const { event, handler } = makeHandlerCode(ctx, fullName, value, true); ctx.addLine(`p${nodeID}.on['${event}'] = ${handler};`); }, }); //------------------------------------------------------------------------------ // t-ref //------------------------------------------------------------------------------ QWeb.addDirective({ name: "ref", priority: 95, atNodeCreation({ ctx, value, addNodeHook }) { ctx.rootContext.shouldDefineRefs = true; const refKey = `ref${ctx.generateID()}`; ctx.addLine(`const ${refKey} = ${ctx.interpolate(value)};`); addNodeHook("create", `context.__owl__.refs[${refKey}] = n.elm;`); addNodeHook("destroy", `delete context.__owl__.refs[${refKey}];`); }, }); //------------------------------------------------------------------------------ // t-transition //------------------------------------------------------------------------------ QWeb.utils.nextFrame = function (cb) { requestAnimationFrame(() => requestAnimationFrame(cb)); }; QWeb.utils.transitionInsert = function (vn, name) { const elm = vn.elm; // remove potential duplicated vnode that is currently being removed, to // prevent from having twice the same node in the DOM during an animation const dup = elm.parentElement && elm.parentElement.querySelector(`*[data-owl-key='${vn.key}']`); if (dup) { dup.remove(); } elm.classList.add(name + "-enter"); elm.classList.add(name + "-enter-active"); elm.classList.remove(name + "-leave-active"); elm.classList.remove(name + "-leave-to"); const finalize = () => { elm.classList.remove(name + "-enter-active"); elm.classList.remove(name + "-enter-to"); }; this.nextFrame(() => { elm.classList.remove(name + "-enter"); elm.classList.add(name + "-enter-to"); whenTransitionEnd(elm, finalize); }); }; QWeb.utils.transitionRemove = function (vn, name, rm) { const elm = vn.elm; elm.setAttribute("data-owl-key", vn.key); elm.classList.add(name + "-leave"); elm.classList.add(name + "-leave-active"); const finalize = () => { if (!elm.classList.contains(name + "-leave-active")) { return; } elm.classList.remove(name + "-leave-active"); elm.classList.remove(name + "-leave-to"); rm(); }; this.nextFrame(() => { elm.classList.remove(name + "-leave"); elm.classList.add(name + "-leave-to"); whenTransitionEnd(elm, finalize); }); }; function getTimeout(delays, durations) { /* istanbul ignore next */ while (delays.length < durations.length) { delays = delays.concat(delays); } return Math.max.apply(null, durations.map((d, i) => { return toMs(d) + toMs(delays[i]); })); } // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers // in a locale-dependent way, using a comma instead of a dot. // If comma is not replaced with a dot, the input will be rounded down (i.e. acting // as a floor function) causing unexpected behaviors function toMs(s) { return Number(s.slice(0, -1).replace(",", ".")) * 1000; } function whenTransitionEnd(elm, cb) { if (!elm.parentNode) { // if we get here, this means that the element was removed for some other // reasons, and in that case, we don't want to work on animation since nothing // will be displayed anyway. return; } const styles = window.getComputedStyle(elm); const delays = (styles.transitionDelay || "").split(", "); const durations = (styles.transitionDuration || "").split(", "); const timeout = getTimeout(delays, durations); if (timeout > 0) { const transitionEndCB = () => { if (!elm.parentNode) return; cb(); browser.clearTimeout(fallbackTimeout); elm.removeEventListener("transitionend", transitionEndCB); }; elm.addEventListener("transitionend", transitionEndCB, { once: true }); const fallbackTimeout = browser.setTimeout(transitionEndCB, timeout + 1); } else { cb(); } } QWeb.addDirective({ name: "transition", priority: 96, atNodeCreation({ ctx, value, addNodeHook }) { if (!QWeb.enableTransitions) { return; } ctx.rootContext.shouldDefineUtils = true; let name = value; const hooks = { insert: `utils.transitionInsert(vn, '${name}');`, remove: `utils.transitionRemove(vn, '${name}', rm);`, }; for (let hookName in hooks) { addNodeHook(hookName, hooks[hookName]); } }, }); //------------------------------------------------------------------------------ // t-slot //------------------------------------------------------------------------------ QWeb.addDirective({ name: "slot", priority: 80, atNodeEncounter({ ctx, value, node, qweb }) { const slotKey = ctx.generateID(); const valueExpr = value.match(INTERP_REGEXP) ? ctx.interpolate(value) : `'${value}'`; ctx.addLine(`const slot${slotKey} = this.constructor.slots[context.__owl__.slotId + '_' + ${valueExpr}];`); ctx.addIf(`slot${slotKey}`); let parentNode = `c${ctx.parentNode}`; if (!ctx.parentNode) { ctx.rootContext.shouldDefineResult = true; ctx.rootContext.shouldDefineUtils = true; parentNode = `children${ctx.generateID()}`; ctx.addLine(`let ${parentNode}= []`); ctx.addLine(`result = {}`); } ctx.addLine(`slot${slotKey}.call(this, context.__owl__.scope, Object.assign({}, extra, {parentNode: ${parentNode}, parent: extra.parent || context}));`); if (!ctx.parentNode) { ctx.addLine(`utils.defineProxy(result, ${parentNode}[0]);`); } if (node.hasChildNodes()) { ctx.addElse(); const nodeCopy = node.cloneNode(true); nodeCopy.removeAttribute("t-slot"); qweb._compileNode(nodeCopy, ctx); } ctx.closeIf(); return true; }, }); //------------------------------------------------------------------------------ // t-model //------------------------------------------------------------------------------ QWeb.utils.toNumber = function (val) { const n = parseFloat(val); return isNaN(n) ? val : n; }; const hasDotAtTheEnd = /\.[\w_]+\s*$/; const hasBracketsAtTheEnd = /\[[^\[]+\]\s*$/; QWeb.addDirective({ name: "model", priority: 42, atNodeCreation({ ctx, nodeID, value, node, fullName, addNodeHook }) { const type = node.getAttribute("type"); let handler; let event = fullName.includes(".lazy") ? "change" : "input"; // First step: we need to understand the structure of the expression, and // from it, extract a base expression (that we can capture, which is // important because it will be used in a handler later) and a formatted // expression (which uses the captured base expression) // // Also, we support 2 kinds of values: some.expr.value or some.expr[value] // For the first one, we have: // - base expression = scope[some].expr // - expression = exprX.value (where exprX is the var that captures the base expr) // and for the expression with brackets: // - base expression = scope[some].expr // - expression = exprX[keyX] (where exprX is the var that captures the base expr // and keyX captures scope[value]) let expr; let baseExpr; if (hasDotAtTheEnd.test(value)) { // we manage the case where the expr has a dot: some.expr.value const index = value.lastIndexOf("."); baseExpr = value.slice(0, index); ctx.addLine(`let expr${nodeID} = ${ctx.formatExpression(baseExpr)};`); expr = `expr${nodeID}${value.slice(index)}`; } else if (hasBracketsAtTheEnd.test(value)) { // we manage here the case where the expr ends in a bracket expression: // some.expr[value] const index = value.lastIndexOf("["); baseExpr = value.slice(0, index); ctx.addLine(`let expr${nodeID} = ${ctx.formatExpression(baseExpr)};`); let exprKey = value.trimRight().slice(index + 1, -1); ctx.addLine(`let exprKey${nodeID} = ${ctx.formatExpression(exprKey)};`); expr = `expr${nodeID}[exprKey${nodeID}]`; } else { throw new Error(`Invalid t-model expression: "${value}" (it should be assignable)`); } const key = ctx.generateTemplateKey(); if (node.tagName === "select") { ctx.addLine(`p${nodeID}.props = {value: ${expr}};`); addNodeHook("create", `n.elm.value=${expr};`); event = "change"; handler = `(ev) => {${expr} = ev.target.value}`; } else if (type === "checkbox") { ctx.addLine(`p${nodeID}.props = {checked: ${expr}};`); handler = `(ev) => {${expr} = ev.target.checked}`; } else if (type === "radio") { const nodeValue = node.getAttribute("value"); ctx.addLine(`p${nodeID}.props = {checked:${expr} === '${nodeValue}'};`); handler = `(ev) => {${expr} = ev.target.value}`; event = "click"; } else { ctx.addLine(`p${nodeID}.props = {value: ${expr}};`); const trimCode = fullName.includes(".trim") ? ".trim()" : ""; let valueCode = `ev.target.value${trimCode}`; if (fullName.includes(".number")) { ctx.rootContext.shouldDefineUtils = true; valueCode = `utils.toNumber(${valueCode})`; } handler = `(ev) => {${expr} = ${valueCode}}`; } ctx.addLine(`extra.handlers[${key}] = extra.handlers[${key}] || (${handler});`); ctx.addLine(`p${nodeID}.on['${event}'] = extra.handlers[${key}];`); }, }); //------------------------------------------------------------------------------ // t-key //------------------------------------------------------------------------------ QWeb.addDirective({ name: "key", priority: 45, atNodeEncounter({ ctx, value, node }) { if (ctx.loopNumber === 0) { ctx.keyStack.push(ctx.rootContext.hasKey0); ctx.rootContext.hasKey0 = true; } ctx.addLine("{"); ctx.indent(); ctx.addLine(`let key${ctx.loopNumber} = ${ctx.formatExpression(value)};`); }, finalize({ ctx }) { ctx.dedent(); ctx.addLine("}"); if (ctx.loopNumber === 0) { ctx.rootContext.hasKey0 = ctx.keyStack.pop(); } }, }); const config = { translatableAttributes: TRANSLATABLE_ATTRS, }; Object.defineProperty(config, "mode", { get() { return QWeb.dev ? "dev" : "prod"; }, set(mode) { QWeb.dev = mode === "dev"; if (QWeb.dev) { console.info(`Owl is running in 'dev' mode. This is not suitable for production use. See https://github.com/verp/owl/blob/master/doc/reference/config.md#mode for more information.`); } }, }); Object.defineProperty(config, "enableTransitions", { get() { return QWeb.enableTransitions; }, set(value) { QWeb.enableTransitions = value; }, }); /** * We define here OwlEvent, a subclass of CustomEvent, with an additional * attribute: * - originalComponent: the component that triggered the event */ class OwlEvent extends CustomEvent { constructor(component, eventType, options) { super(eventType, options); this.originalComponent = component; } } //------------------------------------------------------------------------------ // t-component //------------------------------------------------------------------------------ const T_COMPONENT_MODS_CODE = Object.assign({}, MODS_CODE, { self: "if (e.target !== vn.elm) {return}", }); QWeb.utils.defineProxy = function defineProxy(target, source) { for (let k in source) { Object.defineProperty(target, k, { get() { return source[k]; }, set(val) { source[k] = val; }, }); } }; QWeb.utils.assignHooks = function assignHooks(dataObj, hooks) { if ("hook" in dataObj) { const hookObject = dataObj.hook; for (let name in hooks) { const current = hookObject[name]; const fn = hooks[name]; if (current) { hookObject[name] = (...args) => { current(...args); fn(...args); }; } else { hookObject[name] = fn; } } } else { dataObj.hook = hooks; } }; /** * The t-component directive is certainly a complicated and hard to maintain piece * of code. To help you, fellow developer, if you have to maintain it, I offer * you this advice: Good luck... * * Since it is not 'direct' code, but rather code that generates other code, it * is not easy to understand. To help you, here is a detailed and commented * explanation of the code generated by the t-component directive for the following * situation: * ```xml * * ``` * * ```js * // we assign utils on top of the function because it will be useful for * // each components * let utils = this.utils; * * // this is the virtual node representing the parent div * let c1 = [], p1 = { key: 1 }; * var vn1 = h("div", p1, c1); * * // t-component directive: we start by evaluating the expression given by t-key: * let key5 = "somestring"; * * // def3 is the promise that will contain later either the new component * // creation, or the props update... * let def3; * * // this is kind of tricky: we need here to find if the component was already * // created by a previous rendering. This is done by checking the internal * // `cmap` (children map) of the parent component: it maps keys to component ids, * // and, then, if there is an id, we look into the children list to get the * // instance * let w4 = * key5 in context.__owl__.cmap * ? context.__owl__.children[context.__owl__.cmap[key5]] * : false; * * // We keep the index of the position of the component in the closure. We push * // null to reserve the slot, and will replace it later by the component vnode, * // when it will be ready (do not forget that preparing/rendering a component is * // asynchronous) * let _2_index = c1.length; * c1.push(null); * * // we evaluate here the props given to the component. It is done here to be * // able to easily reference it later, and also, it might be an expensive * // computation, so it is certainly better to do it only once * let props4 = { flag: context["state"].flag }; * * // If we have a component, currently rendering, but not ready yet, we do not want * // to wait for it to be ready if we can avoid it * if (w4 && w4.__owl__.renderPromise && !w4.__owl__.vnode) { * // we check if the props are the same. In that case, we can simply reuse * // the previous rendering and skip all useless work * if (utils.shallowEqual(props4, w4.__owl__.renderProps)) { * def3 = w4.__owl__.renderPromise; * } else { * // if the props are not the same, we destroy the component and starts anew. * // this will be faster than waiting for its rendering, then updating it * w4.destroy(); * w4 = false; * } * } * * if (!w4) { * // in this situation, we need to create a new component. First step is * // to get a reference to the class, then create an instance with * // current context as parent, and the props. * let W4 = context.component && context.components[componentKey4] || QWeb.component[componentKey4]; * if (!W4) { * throw new Error("Cannot find the definition of component 'child'"); * } * w4 = new W4(owner, props4); * * // Whenever we rerender the parent component, we need to be sure that we * // are able to find the component instance. To do that, we register it to * // the parent cmap (children map). Note that the 'template' key is * // used here, since this is what identify the component from the template * // perspective. * context.__owl__.cmap[key5] = w4.__owl__.id; * * // __prepare is called, to basically call willStart, then render the * // component * def3 = w4.__prepare(); * * def3 = def3.then(vnode => { * // we create here a virtual node for the parent (NOT the component). This * // means that the vdom of the parent will be stopped here, and from * // the parent's perspective, it simply is a vnode with no children. * // However, it shares the same dom element with the component root * // vnode. * let pvnode = h(vnode.sel, { key: key5 }); * * // we add hooks to the parent vnode so we can interact with the new * // component at the proper time * pvnode.data.hook = { * insert(vn) { * // the __mount method will patch the component vdom into the elm vn.elm, * // then call the mounted hooks. However, suprisingly, the snabbdom * // patch method actually replace the elm by a new elm, so we need * // to synchronise the pvnode elm with the resulting elm * let nvn = w4.__mount(vnode, vn.elm); * pvnode.elm = nvn.elm; * // what follows is only present if there are animations on the component * utils.transitionInsert(vn, "fade"); * }, * remove() { * // override with empty function to prevent from removing the node * // directly. It will be removed when destroy is called anyway, which * // delays the removal if there are animations. * }, * destroy() { * // if there are animations, we delay the call to destroy on the * // component, if not, we call it directly. * let finalize = () => { * w4.destroy(); * }; * utils.transitionRemove(vn, "fade", finalize); * } * }; * // the pvnode is inserted at the correct position in the div's children * c1[_2_index] = pvnode; * * // we keep here a reference to the parent vnode (representing the * // component, so we can reuse it later whenever we update the component * w4.__owl__.pvnode = pvnode; * }); * } else { * // this is the 'update' path of the directive. * // the call to __updateProps is the actual component update * // Note that we only update the props if we cannot reuse the previous * // rendering work (in the case it was rendered with the same props) * def3 = def3 || w4.__updateProps(props4, extra.forceUpdate, extra.patchQueue); * def3 = def3.then(() => { * // if component was destroyed in the meantime, we do nothing (so, this * // means that the parent's element children list will have a null in * // the component's position, which will cause the pvnode to be removed * // when it is patched. * if (w4.__owl__.isDestroyed) { * return; * } * // like above, we register the pvnode to the children list, so it * // will not be patched out of the dom. * let pvnode = w4.__owl__.pvnode; * c1[_2_index] = pvnode; * }); * } * * // we register the deferred here so the parent can coordinate its patch operation * // with all the children. * extra.promises.push(def3); * return vn1; * ``` */ QWeb.addDirective({ name: "component", extraNames: ["props"], priority: 100, atNodeEncounter({ ctx, value, node, qweb }) { ctx.addLine(`// Component '${value}'`); ctx.rootContext.shouldDefineQWeb = true; ctx.rootContext.shouldDefineParent = true; ctx.rootContext.shouldDefineUtils = true; ctx.rootContext.shouldDefineScope = true; let hasDynamicProps = node.getAttribute("t-props") ? true : false; // t-on- events and t-transition const events = []; let transition = ""; const attributes = node.attributes; const props = {}; for (let i = 0; i < attributes.length; i++) { const name = attributes[i].name; const value = attributes[i].textContent; if (name.startsWith("t-on-")) { events.push([name, value]); } else if (name === "t-transition") { if (QWeb.enableTransitions) { transition = value; } } else if (!name.startsWith("t-")) { if (name !== "class" && name !== "style") { // this is a prop! if (value.includes("=>")) { props[name] = ctx.captureExpression(value); } else { props[name] = ctx.formatExpression(value) || "undefined"; } } } } // computing the props string representing the props object let propStr = Object.keys(props) .map((k) => k + ":" + props[k]) .join(","); let componentID = ctx.generateID(); let hasDefinedKey = false; let templateKey; if (node.tagName === "t" && !node.hasAttribute("t-key") && value.match(INTERP_REGEXP)) { defineComponentKey(); const id = ctx.generateID(); // the ___ is to make sure we have no possible conflict with normal // template keys ctx.addLine(`let k${id} = '___' + componentKey${componentID}`); templateKey = `k${id}`; } else { templateKey = ctx.generateTemplateKey(); } let ref = node.getAttribute("t-ref"); let refExpr = ""; let refKey = ""; if (ref) { ctx.rootContext.shouldDefineRefs = true; refKey = `ref${ctx.generateID()}`; ctx.addLine(`const ${refKey} = ${ctx.interpolate(ref)};`); refExpr = `context.__owl__.refs[${refKey}] = w${componentID};`; } let finalizeComponentCode = `w${componentID}.destroy();`; if (ref) { finalizeComponentCode += `delete context.__owl__.refs[${refKey}];`; } if (transition) { finalizeComponentCode = `let finalize = () => { ${finalizeComponentCode} }; delete w${componentID}.__owl__.transitionInserted; utils.transitionRemove(vn, '${transition}', finalize);`; } let createHook = ""; let classAttr = node.getAttribute("class"); let tattClass = node.getAttribute("t-att-class"); let styleAttr = node.getAttribute("style"); let tattStyle = node.getAttribute("t-att-style"); if (tattStyle) { const attVar = `_${ctx.generateID()}`; ctx.addLine(`const ${attVar} = ${ctx.formatExpression(tattStyle)};`); tattStyle = attVar; } let classObj = ""; if (classAttr || tattClass || styleAttr || tattStyle || events.length) { if (classAttr) { let classDef = classAttr .trim() .split(/\s+/) .map((a) => `'${a}':true`) .join(","); classObj = `_${ctx.generateID()}`; ctx.addLine(`let ${classObj} = {${classDef}};`); } if (tattClass) { let tattExpr = ctx.formatExpression(tattClass); if (tattExpr[0] !== "{" || tattExpr[tattExpr.length - 1] !== "}") { tattExpr = `utils.toClassObj(${tattExpr})`; } if (classAttr) { ctx.addLine(`Object.assign(${classObj}, ${tattExpr})`); } else { classObj = `_${ctx.generateID()}`; ctx.addLine(`let ${classObj} = ${tattExpr};`); } } let eventsCode = events .map(function ([name, value]) { const capture = name.match(/\.capture/); name = capture ? name.replace(/\.capture/, "") : name; const { event, handler } = makeHandlerCode(ctx, name, value, false, T_COMPONENT_MODS_CODE); if (capture) { return `vn.elm.addEventListener('${event}', ${handler}, true);`; } return `vn.elm.addEventListener('${event}', ${handler});`; }) .join(""); const styleExpr = tattStyle || (styleAttr ? `'${styleAttr}'` : false); const styleCode = styleExpr ? `vn.elm.style = ${styleExpr};` : ""; createHook = `utils.assignHooks(vnode.data, {create(_, vn){${styleCode}${eventsCode}}});`; } ctx.addLine(`let w${componentID} = ${templateKey} in parent.__owl__.cmap ? parent.__owl__.children[parent.__owl__.cmap[${templateKey}]] : false;`); let shouldProxy = !ctx.parentNode; if (shouldProxy) { let id = ctx.generateID(); ctx.rootContext.rootNode = id; shouldProxy = true; ctx.rootContext.shouldDefineResult = true; ctx.addLine(`let vn${id} = {};`); ctx.addLine(`result = vn${id};`); } if (hasDynamicProps) { const dynamicProp = ctx.formatExpression(node.getAttribute("t-props")); ctx.addLine(`let props${componentID} = Object.assign({}, ${dynamicProp}, {${propStr}});`); } else { ctx.addLine(`let props${componentID} = {${propStr}};`); } ctx.addIf(`w${componentID} && w${componentID}.__owl__.currentFiber && !w${componentID}.__owl__.vnode`); ctx.addLine(`w${componentID}.destroy();`); ctx.addLine(`w${componentID} = false;`); ctx.closeIf(); let registerCode = ""; if (shouldProxy) { registerCode = `utils.defineProxy(vn${ctx.rootNode}, pvnode);`; } // SLOTS const hasSlots = node.childNodes.length; let scope = hasSlots ? `utils.combine(context, scope)` : "undefined"; ctx.addIf(`w${componentID}`); // need to update component let styleCode = ""; if (tattStyle) { styleCode = `.then(()=>{if (w${componentID}.__owl__.status === ${5 /* DESTROYED */}) {return};w${componentID}.el.style=${tattStyle};});`; } ctx.addLine(`w${componentID}.__updateProps(props${componentID}, extra.fiber, ${scope})${styleCode};`); ctx.addLine(`let pvnode = w${componentID}.__owl__.pvnode;`); if (registerCode) { ctx.addLine(registerCode); } if (ctx.parentNode) { ctx.addLine(`c${ctx.parentNode}.push(pvnode);`); } ctx.addElse(); // new component function defineComponentKey() { if (!hasDefinedKey) { const interpValue = ctx.interpolate(value); ctx.addLine(`let componentKey${componentID} = ${interpValue};`); hasDefinedKey = true; } } defineComponentKey(); const contextualValue = value.match(INTERP_REGEXP) ? "false" : ctx.formatExpression(value); ctx.addLine(`let W${componentID} = ${contextualValue} || context.constructor.components[componentKey${componentID}] || QWeb.components[componentKey${componentID}];`); // maybe only do this in dev mode... ctx.addLine(`if (!W${componentID}) {throw new Error('Cannot find the definition of component "' + componentKey${componentID} + '"')}`); ctx.addLine(`w${componentID} = new W${componentID}(parent, props${componentID});`); if (transition) { ctx.addLine(`const __patch${componentID} = w${componentID}.__patch;`); ctx.addLine(`w${componentID}.__patch = (t, vn) => {__patch${componentID}.call(w${componentID}, t, vn); if(!w${componentID}.__owl__.transitionInserted){w${componentID}.__owl__.transitionInserted = true;utils.transitionInsert(w${componentID}.__owl__.vnode, '${transition}');}};`); } ctx.addLine(`parent.__owl__.cmap[${templateKey}] = w${componentID}.__owl__.id;`); if (hasSlots) { const clone = node.cloneNode(true); // The next code is a fallback for compatibility reason. It accepts t-set // elements that are direct children with a non empty body as nodes defining // the content of a slot. // // This is wrong, but is necessary to prevent breaking all existing Owl // code using slots. This will be removed in v2.0 someday. Meanwhile, // please use t-set-slot everywhere you need to set the content of a // slot. for (let node of clone.children) { if (node.hasAttribute("t-set") && node.hasChildNodes()) { node.setAttribute("t-set-slot", node.getAttribute("t-set")); node.removeAttribute("t-set"); } } const slotNodes = Array.from(clone.querySelectorAll("[t-set-slot]")); const slotNames = new Set(); const slotId = QWeb.nextSlotId++; ctx.addLine(`w${componentID}.__owl__.slotId = ${slotId};`); if (slotNodes.length) { for (let i = 0, length = slotNodes.length; i < length; i++) { const slotNode = slotNodes[i]; // check if this is defined in a sub component (in which case it should // be ignored) let el = slotNode.parentElement; let isInSubComponent = false; while (el !== clone) { if (el.hasAttribute("t-component") || el.tagName[0] === el.tagName[0].toUpperCase()) { isInSubComponent = true; break; } el = el.parentElement; } if (isInSubComponent) { continue; } let key = slotNode.getAttribute("t-set-slot"); if (slotNames.has(key)) { continue; } slotNames.add(key); slotNode.removeAttribute("t-set-slot"); slotNode.parentElement.removeChild(slotNode); const slotFn = qweb._compile(`slot_${key}_template`, { elem: slotNode, hasParent: true }); QWeb.slots[`${slotId}_${key}`] = slotFn; } } if (clone.childNodes.length) { let hasContent = false; const t = clone.ownerDocument.createElement("t"); for (let child of Object.values(clone.childNodes)) { hasContent = hasContent || (child instanceof Text ? Boolean(child.textContent.trim().length) : true); t.appendChild(child); } if (hasContent) { const slotFn = qweb._compile(`slot_default_template`, { elem: t, hasParent: true }); QWeb.slots[`${slotId}_default`] = slotFn; } } } ctx.addLine(`let fiber = w${componentID}.__prepare(extra.fiber, ${scope}, () => { const vnode = fiber.vnode; pvnode.sel = vnode.sel; ${createHook}});`); // hack: specify empty remove hook to prevent the node from being removed from the DOM const insertHook = refExpr ? `insert(vn) {${refExpr}},` : ""; ctx.addLine(`let pvnode = h('dummy', {key: ${templateKey}, hook: {${insertHook}remove() {},destroy(vn) {${finalizeComponentCode}}}});`); if (registerCode) { ctx.addLine(registerCode); } if (ctx.parentNode) { ctx.addLine(`c${ctx.parentNode}.push(pvnode);`); } ctx.addLine(`w${componentID}.__owl__.pvnode = pvnode;`); ctx.closeIf(); if (classObj) { ctx.addLine(`w${componentID}.__owl__.classObj=${classObj};`); } ctx.addLine(`w${componentID}.__owl__.parentLastFiberId = extra.fiber.id;`); return true; }, }); class Scheduler { constructor(requestAnimationFrame) { this.tasks = []; this.isRunning = false; this.requestAnimationFrame = requestAnimationFrame; } start() { this.isRunning = true; this.scheduleTasks(); } stop() { this.isRunning = false; } addFiber(fiber) { // if the fiber was remapped into a larger rendering fiber, it may not be a // root fiber. But we only want to register root fibers fiber = fiber.root; return new Promise((resolve, reject) => { if (fiber.error) { return reject(fiber.error); } this.tasks.push({ fiber, callback: () => { if (fiber.error) { return reject(fiber.error); } resolve(); }, }); if (!this.isRunning) { this.start(); } }); } rejectFiber(fiber, reason) { fiber = fiber.root; const index = this.tasks.findIndex((t) => t.fiber === fiber); if (index >= 0) { const [task] = this.tasks.splice(index, 1); fiber.cancel(); fiber.error = new Error(reason); task.callback(); } } /** * Process all current tasks. This only applies to the fibers that are ready. * Other tasks are left unchanged. */ flush() { let tasks = this.tasks; this.tasks = []; tasks = tasks.filter((task) => { if (task.fiber.isCompleted) { task.callback(); return false; } if (task.fiber.counter === 0) { if (!task.fiber.error) { try { task.fiber.complete(); } catch (e) { task.fiber.handleError(e); } } task.callback(); return false; } return true; }); this.tasks = tasks.concat(this.tasks); if (this.tasks.length === 0) { this.stop(); } } scheduleTasks() { this.requestAnimationFrame(() => { this.flush(); if (this.isRunning) { this.scheduleTasks(); } }); } } const scheduler = new Scheduler(browser.requestAnimationFrame); /** * Owl Fiber Class * * Fibers are small abstractions designed to contain all the internal state * associated with a "rendering work unit", relative to a specific component. * * A rendering will cause the creation of a fiber for each impacted components. * * Fibers capture all that necessary information, which is critical to owl * asynchronous rendering pipeline. Fibers can be cancelled, can be in different * states and in general determine the state of the rendering. */ class Fiber { constructor(parent, component, force, target, position) { this.id = Fiber.nextId++; // isCompleted means that the rendering corresponding to this fiber's work is // done, either because the component has been mounted or patched, or because // fiber has been cancelled. this.isCompleted = false; // the fibers corresponding to component updates (updateProps) need to call // the willPatch and patched hooks from the corresponding component. However, // fibers corresponding to a new component do not need to do that. So, the // shouldPatch hook is the boolean that we check whenever we need to apply // a patch. this.shouldPatch = true; // isRendered is the last state of a fiber. If true, this means that it has // been rendered and is inert (so, it should not be taken into account when // counting the number of active fibers). this.isRendered = false; // the counter number is a critical information. It is only necessary for a // root fiber. For that fiber, this number counts the number of active sub // fibers. When that number reaches 0, the fiber can be applied by the // scheduler. this.counter = 0; this.vnode = null; this.child = null; this.sibling = null; this.lastChild = null; this.parent = null; this.component = component; this.force = force; this.target = target; this.position = position; const __owl__ = component.__owl__; this.scope = __owl__.scope; this.root = parent ? parent.root : this; this.parent = parent; let oldFiber = __owl__.currentFiber; if (oldFiber && !oldFiber.isCompleted) { this.force = true; if (oldFiber.root === oldFiber && !parent) { // both oldFiber and this fiber are root fibers this._reuseFiber(oldFiber); return oldFiber; } else { this._remapFiber(oldFiber); } } this.root.counter++; __owl__.currentFiber = this; } /** * When the oldFiber is not completed yet, and both oldFiber and this fiber * are root fibers, we want to reuse the oldFiber instead of creating a new * one. Doing so will guarantee that the initiator(s) of those renderings will * be notified (the promise will resolve) when the last rendering will be done. * * This function thus assumes that oldFiber is a root fiber. */ _reuseFiber(oldFiber) { oldFiber.cancel(); // cancel children fibers oldFiber.target = this.target || oldFiber.target; oldFiber.position = this.position || oldFiber.position; oldFiber.isCompleted = false; // keep the root fiber alive oldFiber.isRendered = false; // the fiber has to be re-rendered if (oldFiber.child) { // remove relation to children oldFiber.child.parent = null; oldFiber.child = null; oldFiber.lastChild = null; } oldFiber.counter = 1; // re-initialize counter oldFiber.id = Fiber.nextId++; } /** * In some cases, a rendering initiated at some component can detect that it * should be part of a larger rendering initiated somewhere up the component * tree. In that case, it needs to cancel the previous rendering and * remap itself as a part of the current parent rendering. */ _remapFiber(oldFiber) { oldFiber.cancel(); this.shouldPatch = oldFiber.shouldPatch; if (oldFiber === oldFiber.root) { oldFiber.counter++; } if (oldFiber.parent && !this.parent) { // re-map links this.parent = oldFiber.parent; this.root = this.parent.root; this.sibling = oldFiber.sibling; if (this.parent.lastChild === oldFiber) { this.parent.lastChild = this; } if (this.parent.child === oldFiber) { this.parent.child = this; } else { let current = this.parent.child; while (true) { if (current.sibling === oldFiber) { current.sibling = this; break; } current = current.sibling; } } } } /** * This function has been taken from * https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7 */ _walk(doWork) { let root = this; let current = this; while (true) { const child = doWork(current); if (child) { current = child; continue; } if (current === root) { return; } while (!current.sibling) { if (!current.parent || current.parent === root) { return; } current = current.parent; } current = current.sibling; } } /** * Successfully complete the work of the fiber: call the mount or patch hooks * and patch the DOM. This function is called once the fiber and its children * are ready, and the scheduler decides to process it. */ complete() { let component = this.component; this.isCompleted = true; const status = component.__owl__.status; if (status === 5 /* DESTROYED */) { return; } // build patchQueue const patchQueue = []; const doWork = function (f) { f.component.__owl__.currentFiber = null; patchQueue.push(f); return f.child; }; this._walk(doWork); const patchLen = patchQueue.length; // call willPatch hook on each fiber of patchQueue if (status === 3 /* MOUNTED */) { for (let i = 0; i < patchLen; i++) { const fiber = patchQueue[i]; if (fiber.shouldPatch) { component = fiber.component; if (component.__owl__.willPatchCB) { component.__owl__.willPatchCB(); } component.willPatch(); } } } // call __patch on each fiber of (reversed) patchQueue for (let i = patchLen - 1; i >= 0; i--) { const fiber = patchQueue[i]; component = fiber.component; if (fiber.target && i === 0) { let target; if (fiber.position === "self") { target = fiber.target; if (target.tagName.toLowerCase() !== fiber.vnode.sel) { throw new Error(`Cannot attach '${component.constructor.name}' to target node (not same tag name)`); } // In self mode, we *know* we are to take possession of the target // Hence we manually create the corresponding VNode and copy the "key" in data const selfVnodeData = fiber.vnode.data ? { key: fiber.vnode.data.key } : {}; const selfVnode = h(fiber.vnode.sel, selfVnodeData); selfVnode.elm = target; target = selfVnode; } else { target = component.__owl__.vnode || document.createElement(fiber.vnode.sel); } component.__patch(target, fiber.vnode); } else { const vnode = component.__owl__.vnode; if (fiber.shouldPatch && vnode) { component.__patch(vnode, fiber.vnode); // When updating a Component's props (in directive), // the component has a pvnode AND should be patched. // However, its pvnode.elm may have changed if it is a High Order Component if (component.__owl__.pvnode) { component.__owl__.pvnode.elm = component.__owl__.vnode.elm; } } else { component.__patch(document.createElement(fiber.vnode.sel), fiber.vnode); component.__owl__.pvnode.elm = component.__owl__.vnode.elm; } } } // insert into the DOM (mount case) let inDOM = false; if (this.target) { switch (this.position) { case "first-child": this.target.prepend(this.component.el); break; case "last-child": this.target.appendChild(this.component.el); break; } inDOM = document.body.contains(this.component.el); this.component.env.qweb.trigger("dom-appended"); } // call patched/mounted hook on each fiber of (reversed) patchQueue if (status === 3 /* MOUNTED */ || inDOM) { for (let i = patchLen - 1; i >= 0; i--) { const fiber = patchQueue[i]; component = fiber.component; if (fiber.shouldPatch && !this.target) { component.patched(); if (component.__owl__.patchedCB) { component.__owl__.patchedCB(); } } else { component.__callMounted(); } } } else { for (let i = patchLen - 1; i >= 0; i--) { const fiber = patchQueue[i]; component = fiber.component; component.__owl__.status = 4 /* UNMOUNTED */; } } } /** * Cancel a fiber and all its children. */ cancel() { this._walk((f) => { if (!f.isRendered) { f.root.counter--; } f.isCompleted = true; return f.child; }); } /** * This is the global error handler for errors occurring in Owl main lifecycle * methods. Caught errors are triggered on the QWeb instance, and are * potentially given to some parent component which implements `catchError`. * * If there are no such component, we destroy everything. This is better than * being in a corrupted state. */ handleError(error) { let component = this.component; this.vnode = component.__owl__.vnode || h("div"); const qweb = component.env.qweb; let root = component; function handle(error) { let canCatch = false; qweb.trigger("error", error); while (component && !(canCatch = !!component.catchError)) { root = component; component = component.__owl__.parent; } if (canCatch) { try { component.catchError(error); } catch (e) { root = component; component = component.__owl__.parent; return handle(e); } return true; } return false; } let isHandled = handle(error); if (!isHandled) { // the 3 next lines aim to mark the root fiber as being in error, and // to force it to end, without waiting for its children this.root.counter = 0; this.root.error = error; scheduler.flush(); // at this point, the state of the application is corrupted and we could // have a lot of issues or crashes. So we destroy the application in a try // catch and swallow these errors because the fiber is already in error, // and this is the actual issue that needs to be solved, not those followup // errors. try { root.destroy(); } catch (e) { } } } } Fiber.nextId = 1; //------------------------------------------------------------------------------ // Prop validation helper //------------------------------------------------------------------------------ /** * Validate the component props (or next props) against the (static) props * description. This is potentially an expensive operation: it may needs to * visit recursively the props and all the children to check if they are valid. * This is why it is only done in 'dev' mode. */ QWeb.utils.validateProps = function (Widget, props) { const propsDef = Widget.props; if (propsDef instanceof Array) { // list of strings (prop names) for (let i = 0, l = propsDef.length; i < l; i++) { const propName = propsDef[i]; if (propName[propName.length - 1] === "?") { // optional prop break; } if (!(propName in props)) { throw new Error(`Missing props '${propsDef[i]}' (component '${Widget.name}')`); } } for (let key in props) { if (!propsDef.includes(key) && !propsDef.includes(key + "?")) { throw new Error(`Unknown prop '${key}' given to component '${Widget.name}'`); } } } else if (propsDef) { // propsDef is an object now for (let propName in propsDef) { if (props[propName] === undefined) { if (propsDef[propName] && !propsDef[propName].optional) { throw new Error(`Missing props '${propName}' (component '${Widget.name}')`); } else { continue; } } let isValid; try { isValid = isValidProp(props[propName], propsDef[propName]); } catch (e) { e.message = `Invalid prop '${propName}' in component ${Widget.name} (${e.message})`; throw e; } if (!isValid) { throw new Error(`Invalid Prop '${propName}' in component '${Widget.name}'`); } } for (let propName in props) { if (!(propName in propsDef)) { throw new Error(`Unknown prop '${propName}' given to component '${Widget.name}'`); } } } }; /** * Check if an invidual prop value matches its (static) prop definition */ function isValidProp(prop, propDef) { if (propDef === true) { return true; } if (typeof propDef === "function") { // Check if a value is constructed by some Constructor. Note that there is a // slight abuse of language: we want to consider primitive values as well. // // So, even though 1 is not an instance of Number, we want to consider that // it is valid. if (typeof prop === "object") { return prop instanceof propDef; } return typeof prop === propDef.name.toLowerCase(); } else if (propDef instanceof Array) { // If this code is executed, this means that we want to check if a prop // matches at least one of its descriptor. let result = false; for (let i = 0, iLen = propDef.length; i < iLen; i++) { result = result || isValidProp(prop, propDef[i]); } return result; } // propsDef is an object if (propDef.optional && prop === undefined) { return true; } let result = propDef.type ? isValidProp(prop, propDef.type) : true; if (propDef.validate) { result = result && propDef.validate(prop); } if (propDef.type === Array && propDef.element) { for (let i = 0, iLen = prop.length; i < iLen; i++) { result = result && isValidProp(prop[i], propDef.element); } } if (propDef.type === Object && propDef.shape) { const shape = propDef.shape; for (let key in shape) { result = result && isValidProp(prop[key], shape[key]); } if (result) { for (let propName in prop) { if (!(propName in shape)) { throw new Error(`unknown prop '${propName}'`); } } } } return result; } /** * Owl Style System * * This files contains the Owl code related to processing (extended) css strings * and creating/adding " ).appendTo( body ); } if ( o.opacity ) { // opacity option if ( this.helper.css( "opacity" ) ) { this._storedOpacity = this.helper.css( "opacity" ); } this.helper.css( "opacity", o.opacity ); } if ( o.zIndex ) { // zIndex option if ( this.helper.css( "zIndex" ) ) { this._storedZIndex = this.helper.css( "zIndex" ); } this.helper.css( "zIndex", o.zIndex ); } //Prepare scrolling if ( this.scrollParent[ 0 ] !== this.document[ 0 ] && this.scrollParent[ 0 ].tagName !== "HTML" ) { this.overflowOffset = this.scrollParent.offset(); } //Call callbacks this._trigger( "start", event, this._uiHash() ); //Recache the helper size if ( !this._preserveHelperProportions ) { this._cacheHelperProportions(); } //Post "activate" events to possible containers if ( !noActivation ) { for ( i = this.containers.length - 1; i >= 0; i-- ) { this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) ); } } //Prepare possible droppables if ( $.ui.ddmanager ) { $.ui.ddmanager.current = this; } if ( $.ui.ddmanager && !o.dropBehaviour ) { $.ui.ddmanager.prepareOffsets( this, event ); } this.dragging = true; this._addClass( this.helper, "ui-sortable-helper" ); // Execute the drag once - this causes the helper not to be visiblebefore getting its // correct position this._mouseDrag( event ); return true; }, _mouseDrag: function( event ) { var i, item, itemElement, intersection, o = this.options, scrolled = false; //Compute the helpers position this.position = this._generatePosition( event ); this.positionAbs = this._convertPositionTo( "absolute" ); if ( !this.lastPositionAbs ) { this.lastPositionAbs = this.positionAbs; } //Do scrolling if ( this.options.scroll ) { if ( this.scrollParent[ 0 ] !== this.document[ 0 ] && this.scrollParent[ 0 ].tagName !== "HTML" ) { if ( ( this.overflowOffset.top + this.scrollParent[ 0 ].offsetHeight ) - event.pageY < o.scrollSensitivity ) { this.scrollParent[ 0 ].scrollTop = scrolled = this.scrollParent[ 0 ].scrollTop + o.scrollSpeed; } else if ( event.pageY - this.overflowOffset.top < o.scrollSensitivity ) { this.scrollParent[ 0 ].scrollTop = scrolled = this.scrollParent[ 0 ].scrollTop - o.scrollSpeed; } if ( ( this.overflowOffset.left + this.scrollParent[ 0 ].offsetWidth ) - event.pageX < o.scrollSensitivity ) { this.scrollParent[ 0 ].scrollLeft = scrolled = this.scrollParent[ 0 ].scrollLeft + o.scrollSpeed; } else if ( event.pageX - this.overflowOffset.left < o.scrollSensitivity ) { this.scrollParent[ 0 ].scrollLeft = scrolled = this.scrollParent[ 0 ].scrollLeft - o.scrollSpeed; } } else { if ( event.pageY - this.document.scrollTop() < o.scrollSensitivity ) { scrolled = this.document.scrollTop( this.document.scrollTop() - o.scrollSpeed ); } else if ( this.window.height() - ( event.pageY - this.document.scrollTop() ) < o.scrollSensitivity ) { scrolled = this.document.scrollTop( this.document.scrollTop() + o.scrollSpeed ); } if ( event.pageX - this.document.scrollLeft() < o.scrollSensitivity ) { scrolled = this.document.scrollLeft( this.document.scrollLeft() - o.scrollSpeed ); } else if ( this.window.width() - ( event.pageX - this.document.scrollLeft() ) < o.scrollSensitivity ) { scrolled = this.document.scrollLeft( this.document.scrollLeft() + o.scrollSpeed ); } } if ( scrolled !== false && $.ui.ddmanager && !o.dropBehaviour ) { $.ui.ddmanager.prepareOffsets( this, event ); } } //Regenerate the absolute position used for position checks this.positionAbs = this._convertPositionTo( "absolute" ); //Set the helper position if ( !this.options.axis || this.options.axis !== "y" ) { this.helper[ 0 ].style.left = this.position.left + "px"; } if ( !this.options.axis || this.options.axis !== "x" ) { this.helper[ 0 ].style.top = this.position.top + "px"; } //Rearrange for ( i = this.items.length - 1; i >= 0; i-- ) { //Cache variables and intersection, continue if no intersection item = this.items[ i ]; itemElement = item.item[ 0 ]; intersection = this._intersectsWithPointer( item ); if ( !intersection ) { continue; } // Only put the placeholder inside the current Container, skip all // items from other containers. This works because when moving // an item from one container to another the // currentContainer is switched before the placeholder is moved. // // Without this, moving items in "sub-sortables" can cause // the placeholder to jitter between the outer and inner container. if ( item.instance !== this.currentContainer ) { continue; } // Cannot intersect with itself // no useless actions that have been done before // no action if the item moved is the parent of the item checked if ( itemElement !== this.currentItem[ 0 ] && this.placeholder[ intersection === 1 ? "next" : "prev" ]()[ 0 ] !== itemElement && !$.contains( this.placeholder[ 0 ], itemElement ) && ( this.options.type === "semi-dynamic" ? !$.contains( this.element[ 0 ], itemElement ) : true ) ) { this.direction = intersection === 1 ? "down" : "up"; if ( this.options.tolerance === "pointer" || this._intersectsWithSides( item ) ) { this._rearrange( event, item ); } else { break; } this._trigger( "change", event, this._uiHash() ); break; } } //Post events to containers this._contactContainers( event ); //Interconnect with droppables if ( $.ui.ddmanager ) { $.ui.ddmanager.drag( this, event ); } //Call callbacks this._trigger( "sort", event, this._uiHash() ); this.lastPositionAbs = this.positionAbs; return false; }, _mouseStop: function( event, noPropagation ) { if ( !event ) { return; } //If we are using droppables, inform the manager about the drop if ( $.ui.ddmanager && !this.options.dropBehaviour ) { $.ui.ddmanager.drop( this, event ); } if ( this.options.revert ) { var that = this, cur = this.placeholder.offset(), axis = this.options.axis, animation = {}; if ( !axis || axis === "x" ) { animation.left = cur.left - this.offset.parent.left - this.margins.left + ( this.offsetParent[ 0 ] === this.document[ 0 ].body ? 0 : this.offsetParent[ 0 ].scrollLeft ); } if ( !axis || axis === "y" ) { animation.top = cur.top - this.offset.parent.top - this.margins.top + ( this.offsetParent[ 0 ] === this.document[ 0 ].body ? 0 : this.offsetParent[ 0 ].scrollTop ); } this.reverting = true; $( this.helper ).animate( animation, parseInt( this.options.revert, 10 ) || 500, function() { that._clear( event ); } ); } else { this._clear( event, noPropagation ); } return false; }, cancel: function() { if ( this.dragging ) { this._mouseUp( new $.Event( "mouseup", { target: null } ) ); if ( this.options.helper === "original" ) { this.currentItem.css( this._storedCSS ); this._removeClass( this.currentItem, "ui-sortable-helper" ); } else { this.currentItem.show(); } //Post deactivating events to containers for ( var i = this.containers.length - 1; i >= 0; i-- ) { this.containers[ i ]._trigger( "deactivate", null, this._uiHash( this ) ); if ( this.containers[ i ].containerCache.over ) { this.containers[ i ]._trigger( "out", null, this._uiHash( this ) ); this.containers[ i ].containerCache.over = 0; } } } if ( this.placeholder ) { //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, // it unbinds ALL events from the original node! if ( this.placeholder[ 0 ].parentNode ) { this.placeholder[ 0 ].parentNode.removeChild( this.placeholder[ 0 ] ); } if ( this.options.helper !== "original" && this.helper && this.helper[ 0 ].parentNode ) { this.helper.remove(); } $.extend( this, { helper: null, dragging: false, reverting: false, _noFinalSort: null } ); if ( this.domPosition.prev ) { $( this.domPosition.prev ).after( this.currentItem ); } else { $( this.domPosition.parent ).prepend( this.currentItem ); } } return this; }, serialize: function( o ) { var items = this._getItemsAsjQuery( o && o.connected ), str = []; o = o || {}; $( items ).each( function() { var res = ( $( o.item || this ).attr( o.attribute || "id" ) || "" ) .match( o.expression || ( /(.+)[\-=_](.+)/ ) ); if ( res ) { str.push( ( o.key || res[ 1 ] + "[]" ) + "=" + ( o.key && o.expression ? res[ 1 ] : res[ 2 ] ) ); } } ); if ( !str.length && o.key ) { str.push( o.key + "=" ); } return str.join( "&" ); }, toArray: function( o ) { var items = this._getItemsAsjQuery( o && o.connected ), ret = []; o = o || {}; items.each( function() { ret.push( $( o.item || this ).attr( o.attribute || "id" ) || "" ); } ); return ret; }, /* Be careful with the following core functions */ _intersectsWith: function( item ) { var x1 = this.positionAbs.left, x2 = x1 + this.helperProportions.width, y1 = this.positionAbs.top, y2 = y1 + this.helperProportions.height, l = item.left, r = l + item.width, t = item.top, b = t + item.height, dyClick = this.offset.click.top, dxClick = this.offset.click.left, isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t && ( y1 + dyClick ) < b ), isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l && ( x1 + dxClick ) < r ), isOverElement = isOverElementHeight && isOverElementWidth; if ( this.options.tolerance === "pointer" || this.options.forcePointerForContainers || ( this.options.tolerance !== "pointer" && this.helperProportions[ this.floating ? "width" : "height" ] > item[ this.floating ? "width" : "height" ] ) ) { return isOverElement; } else { return ( l < x1 + ( this.helperProportions.width / 2 ) && // Right Half x2 - ( this.helperProportions.width / 2 ) < r && // Left Half t < y1 + ( this.helperProportions.height / 2 ) && // Bottom Half y2 - ( this.helperProportions.height / 2 ) < b ); // Top Half } }, _intersectsWithPointer: function( item ) { var verticalDirection, horizontalDirection, isOverElementHeight = ( this.options.axis === "x" ) || this._isOverAxis( this.positionAbs.top + this.offset.click.top, item.top, item.height ), isOverElementWidth = ( this.options.axis === "y" ) || this._isOverAxis( this.positionAbs.left + this.offset.click.left, item.left, item.width ), isOverElement = isOverElementHeight && isOverElementWidth; if ( !isOverElement ) { return false; } verticalDirection = this._getDragVerticalDirection(); horizontalDirection = this._getDragHorizontalDirection(); return this.floating ? ( ( horizontalDirection === "right" || verticalDirection === "down" ) ? 2 : 1 ) : ( verticalDirection && ( verticalDirection === "down" ? 2 : 1 ) ); }, _intersectsWithSides: function( item ) { var isOverBottomHalf = this._isOverAxis( this.positionAbs.top + this.offset.click.top, item.top + ( item.height / 2 ), item.height ), isOverRightHalf = this._isOverAxis( this.positionAbs.left + this.offset.click.left, item.left + ( item.width / 2 ), item.width ), verticalDirection = this._getDragVerticalDirection(), horizontalDirection = this._getDragHorizontalDirection(); if ( this.floating && horizontalDirection ) { return ( ( horizontalDirection === "right" && isOverRightHalf ) || ( horizontalDirection === "left" && !isOverRightHalf ) ); } else { return verticalDirection && ( ( verticalDirection === "down" && isOverBottomHalf ) || ( verticalDirection === "up" && !isOverBottomHalf ) ); } }, _getDragVerticalDirection: function() { var delta = this.positionAbs.top - this.lastPositionAbs.top; return delta !== 0 && ( delta > 0 ? "down" : "up" ); }, _getDragHorizontalDirection: function() { var delta = this.positionAbs.left - this.lastPositionAbs.left; return delta !== 0 && ( delta > 0 ? "right" : "left" ); }, refresh: function( event ) { this._refreshItems( event ); this._setHandleClassName(); this.refreshPositions(); return this; }, _connectWith: function() { var options = this.options; return options.connectWith.constructor === String ? [ options.connectWith ] : options.connectWith; }, _getItemsAsjQuery: function( connected ) { var i, j, cur, inst, items = [], queries = [], connectWith = this._connectWith(); if ( connectWith && connected ) { for ( i = connectWith.length - 1; i >= 0; i-- ) { cur = $( connectWith[ i ], this.document[ 0 ] ); for ( j = cur.length - 1; j >= 0; j-- ) { inst = $.data( cur[ j ], this.widgetFullName ); if ( inst && inst !== this && !inst.options.disabled ) { queries.push( [ $.isFunction( inst.options.items ) ? inst.options.items.call( inst.element ) : $( inst.options.items, inst.element ) .not( ".ui-sortable-helper" ) .not( ".ui-sortable-placeholder" ), inst ] ); } } } } queries.push( [ $.isFunction( this.options.items ) ? this.options.items .call( this.element, null, { options: this.options, item: this.currentItem } ) : $( this.options.items, this.element ) .not( ".ui-sortable-helper" ) .not( ".ui-sortable-placeholder" ), this ] ); function addItems() { items.push( this ); } for ( i = queries.length - 1; i >= 0; i-- ) { queries[ i ][ 0 ].each( addItems ); } return $( items ); }, _removeCurrentsFromItems: function() { var list = this.currentItem.find( ":data(" + this.widgetName + "-item)" ); this.items = $.grep( this.items, function( item ) { for ( var j = 0; j < list.length; j++ ) { if ( list[ j ] === item.item[ 0 ] ) { return false; } } return true; } ); }, _refreshItems: function( event ) { this.items = []; this.containers = [ this ]; var i, j, cur, inst, targetData, _queries, item, queriesLength, items = this.items, queries = [ [ $.isFunction( this.options.items ) ? this.options.items.call( this.element[ 0 ], event, { item: this.currentItem } ) : $( this.options.items, this.element ), this ] ], connectWith = this._connectWith(); //Shouldn't be run the first time through due to massive slow-down if ( connectWith && this.ready ) { for ( i = connectWith.length - 1; i >= 0; i-- ) { cur = $( connectWith[ i ], this.document[ 0 ] ); for ( j = cur.length - 1; j >= 0; j-- ) { inst = $.data( cur[ j ], this.widgetFullName ); if ( inst && inst !== this && !inst.options.disabled ) { queries.push( [ $.isFunction( inst.options.items ) ? inst.options.items .call( inst.element[ 0 ], event, { item: this.currentItem } ) : $( inst.options.items, inst.element ), inst ] ); this.containers.push( inst ); } } } } for ( i = queries.length - 1; i >= 0; i-- ) { targetData = queries[ i ][ 1 ]; _queries = queries[ i ][ 0 ]; for ( j = 0, queriesLength = _queries.length; j < queriesLength; j++ ) { item = $( _queries[ j ] ); // Data for target checking (mouse manager) item.data( this.widgetName + "-item", targetData ); items.push( { item: item, instance: targetData, width: 0, height: 0, left: 0, top: 0 } ); } } }, refreshPositions: function( fast ) { // Determine whether items are being displayed horizontally this.floating = this.items.length ? this.options.axis === "x" || this._isFloating( this.items[ 0 ].item ) : false; //This has to be redone because due to the item being moved out/into the offsetParent, // the offsetParent's position will change if ( this.offsetParent && this.helper ) { this.offset.parent = this._getParentOffset(); } var i, item, t, p; for ( i = this.items.length - 1; i >= 0; i-- ) { item = this.items[ i ]; //We ignore calculating positions of all connected containers when we're not over them if ( item.instance !== this.currentContainer && this.currentContainer && item.item[ 0 ] !== this.currentItem[ 0 ] ) { continue; } t = this.options.toleranceElement ? $( this.options.toleranceElement, item.item ) : item.item; if ( !fast ) { item.width = t.outerWidth(); item.height = t.outerHeight(); } p = t.offset(); item.left = p.left; item.top = p.top; } if ( this.options.custom && this.options.custom.refreshContainers ) { this.options.custom.refreshContainers.call( this ); } else { for ( i = this.containers.length - 1; i >= 0; i-- ) { p = this.containers[ i ].element.offset(); this.containers[ i ].containerCache.left = p.left; this.containers[ i ].containerCache.top = p.top; this.containers[ i ].containerCache.width = this.containers[ i ].element.outerWidth(); this.containers[ i ].containerCache.height = this.containers[ i ].element.outerHeight(); } } return this; }, _createPlaceholder: function( that ) { that = that || this; var className, o = that.options; if ( !o.placeholder || o.placeholder.constructor === String ) { className = o.placeholder; o.placeholder = { element: function() { var nodeName = that.currentItem[ 0 ].nodeName.toLowerCase(), element = $( "<" + nodeName + ">", that.document[ 0 ] ); that._addClass( element, "ui-sortable-placeholder", className || that.currentItem[ 0 ].className ) ._removeClass( element, "ui-sortable-helper" ); if ( nodeName === "tbody" ) { that._createTrPlaceholder( that.currentItem.find( "tr" ).eq( 0 ), $( "", that.document[ 0 ] ).appendTo( element ) ); } else if ( nodeName === "tr" ) { that._createTrPlaceholder( that.currentItem, element ); } else if ( nodeName === "img" ) { element.attr( "src", that.currentItem.attr( "src" ) ); } if ( !className ) { element.css( "visibility", "hidden" ); } return element; }, update: function( container, p ) { // 1. If a className is set as 'placeholder option, we don't force sizes - // the class is responsible for that // 2. The option 'forcePlaceholderSize can be enabled to force it even if a // class name is specified if ( className && !o.forcePlaceholderSize ) { return; } //If the element doesn't have a actual height by itself (without styles coming // from a stylesheet), it receives the inline height from the dragged item if ( !p.height() ) { p.height( that.currentItem.innerHeight() - parseInt( that.currentItem.css( "paddingTop" ) || 0, 10 ) - parseInt( that.currentItem.css( "paddingBottom" ) || 0, 10 ) ); } if ( !p.width() ) { p.width( that.currentItem.innerWidth() - parseInt( that.currentItem.css( "paddingLeft" ) || 0, 10 ) - parseInt( that.currentItem.css( "paddingRight" ) || 0, 10 ) ); } } }; } //Create the placeholder that.placeholder = $( o.placeholder.element.call( that.element, that.currentItem ) ); //Append it after the actual current item that.currentItem.after( that.placeholder ); //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317) o.placeholder.update( that, that.placeholder ); }, _createTrPlaceholder: function( sourceTr, targetTr ) { var that = this; sourceTr.children().each( function() { $( " ", that.document[ 0 ] ) .attr( "colspan", $( this ).attr( "colspan" ) || 1 ) .appendTo( targetTr ); } ); }, _contactContainers: function( event ) { var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom, floating, axis, innermostContainer = null, innermostIndex = null; // Get innermost container that intersects with item for ( i = this.containers.length - 1; i >= 0; i-- ) { // Never consider a container that's located within the item itself if ( $.contains( this.currentItem[ 0 ], this.containers[ i ].element[ 0 ] ) ) { continue; } if ( this._intersectsWith( this.containers[ i ].containerCache ) ) { // If we've already found a container and it's more "inner" than this, then continue if ( innermostContainer && $.contains( this.containers[ i ].element[ 0 ], innermostContainer.element[ 0 ] ) ) { continue; } innermostContainer = this.containers[ i ]; innermostIndex = i; } else { // container doesn't intersect. trigger "out" event if necessary if ( this.containers[ i ].containerCache.over ) { this.containers[ i ]._trigger( "out", event, this._uiHash( this ) ); this.containers[ i ].containerCache.over = 0; } } } // If no intersecting containers found, return if ( !innermostContainer ) { return; } // Move the item into the container if it's not there already if ( this.containers.length === 1 ) { if ( !this.containers[ innermostIndex ].containerCache.over ) { this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash( this ) ); this.containers[ innermostIndex ].containerCache.over = 1; } } else { // When entering a new container, we will find the item with the least distance and // append our item near it dist = 10000; itemWithLeastDistance = null; floating = innermostContainer.floating || this._isFloating( this.currentItem ); posProperty = floating ? "left" : "top"; sizeProperty = floating ? "width" : "height"; axis = floating ? "pageX" : "pageY"; for ( j = this.items.length - 1; j >= 0; j-- ) { if ( !$.contains( this.containers[ innermostIndex ].element[ 0 ], this.items[ j ].item[ 0 ] ) ) { continue; } if ( this.items[ j ].item[ 0 ] === this.currentItem[ 0 ] ) { continue; } cur = this.items[ j ].item.offset()[ posProperty ]; nearBottom = false; if ( event[ axis ] - cur > this.items[ j ][ sizeProperty ] / 2 ) { nearBottom = true; } if ( Math.abs( event[ axis ] - cur ) < dist ) { dist = Math.abs( event[ axis ] - cur ); itemWithLeastDistance = this.items[ j ]; this.direction = nearBottom ? "up" : "down"; } } //Check if dropOnEmpty is enabled if ( !itemWithLeastDistance && !this.options.dropOnEmpty ) { return; } if ( this.currentContainer === this.containers[ innermostIndex ] ) { if ( !this.currentContainer.containerCache.over ) { this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash() ); this.currentContainer.containerCache.over = 1; } return; } itemWithLeastDistance ? this._rearrange( event, itemWithLeastDistance, null, true ) : this._rearrange( event, null, this.containers[ innermostIndex ].element, true ); this._trigger( "change", event, this._uiHash() ); this.containers[ innermostIndex ]._trigger( "change", event, this._uiHash( this ) ); this.currentContainer = this.containers[ innermostIndex ]; //Update the placeholder this.options.placeholder.update( this.currentContainer, this.placeholder ); this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash( this ) ); this.containers[ innermostIndex ].containerCache.over = 1; } }, _createHelper: function( event ) { var o = this.options, helper = $.isFunction( o.helper ) ? $( o.helper.apply( this.element[ 0 ], [ event, this.currentItem ] ) ) : ( o.helper === "clone" ? this.currentItem.clone() : this.currentItem ); //Add the helper to the DOM if that didn't happen already if ( !helper.parents( "body" ).length ) { $( o.appendTo !== "parent" ? o.appendTo : this.currentItem[ 0 ].parentNode )[ 0 ].appendChild( helper[ 0 ] ); } if ( helper[ 0 ] === this.currentItem[ 0 ] ) { this._storedCSS = { width: this.currentItem[ 0 ].style.width, height: this.currentItem[ 0 ].style.height, position: this.currentItem.css( "position" ), top: this.currentItem.css( "top" ), left: this.currentItem.css( "left" ) }; } if ( !helper[ 0 ].style.width || o.forceHelperSize ) { helper.width( this.currentItem.width() ); } if ( !helper[ 0 ].style.height || o.forceHelperSize ) { helper.height( this.currentItem.height() ); } return helper; }, _adjustOffsetFromHelper: function( obj ) { if ( typeof obj === "string" ) { obj = obj.split( " " ); } if ( $.isArray( obj ) ) { obj = { left: +obj[ 0 ], top: +obj[ 1 ] || 0 }; } if ( "left" in obj ) { this.offset.click.left = obj.left + this.margins.left; } if ( "right" in obj ) { this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left; } if ( "top" in obj ) { this.offset.click.top = obj.top + this.margins.top; } if ( "bottom" in obj ) { this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top; } }, _getParentOffset: function() { //Get the offsetParent and cache its position this.offsetParent = this.helper.offsetParent(); var po = this.offsetParent.offset(); // This is a special case where we need to modify a offset calculated on start, since the // following happened: // 1. The position of the helper is absolute, so it's position is calculated based on the // next positioned parent // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't // the document, which means that the scroll is included in the initial calculation of the // offset of the parent, and never recalculated upon drag if ( this.cssPosition === "absolute" && this.scrollParent[ 0 ] !== this.document[ 0 ] && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) { po.left += this.scrollParent.scrollLeft(); po.top += this.scrollParent.scrollTop(); } // This needs to be actually done for all browsers, since pageX/pageY includes this // information with an ugly IE fix if ( this.offsetParent[ 0 ] === this.document[ 0 ].body || ( this.offsetParent[ 0 ].tagName && this.offsetParent[ 0 ].tagName.toLowerCase() === "html" && $.ui.ie ) ) { po = { top: 0, left: 0 }; } return { top: po.top + ( parseInt( this.offsetParent.css( "borderTopWidth" ), 10 ) || 0 ), left: po.left + ( parseInt( this.offsetParent.css( "borderLeftWidth" ), 10 ) || 0 ) }; }, _getRelativeOffset: function() { if ( this.cssPosition === "relative" ) { var p = this.currentItem.position(); return { top: p.top - ( parseInt( this.helper.css( "top" ), 10 ) || 0 ) + this.scrollParent.scrollTop(), left: p.left - ( parseInt( this.helper.css( "left" ), 10 ) || 0 ) + this.scrollParent.scrollLeft() }; } else { return { top: 0, left: 0 }; } }, _cacheMargins: function() { this.margins = { left: ( parseInt( this.currentItem.css( "marginLeft" ), 10 ) || 0 ), top: ( parseInt( this.currentItem.css( "marginTop" ), 10 ) || 0 ) }; }, _cacheHelperProportions: function() { this.helperProportions = { width: this.helper.outerWidth(), height: this.helper.outerHeight() }; }, _setContainment: function() { var ce, co, over, o = this.options; if ( o.containment === "parent" ) { o.containment = this.helper[ 0 ].parentNode; } if ( o.containment === "document" || o.containment === "window" ) { this.containment = [ 0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, o.containment === "document" ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left, ( o.containment === "document" ? ( this.document.height() || document.body.parentNode.scrollHeight ) : this.window.height() || this.document[ 0 ].body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top ]; } if ( !( /^(document|window|parent)$/ ).test( o.containment ) ) { ce = $( o.containment )[ 0 ]; co = $( o.containment ).offset(); over = ( $( ce ).css( "overflow" ) !== "hidden" ); this.containment = [ co.left + ( parseInt( $( ce ).css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( $( ce ).css( "paddingLeft" ), 10 ) || 0 ) - this.margins.left, co.top + ( parseInt( $( ce ).css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( $( ce ).css( "paddingTop" ), 10 ) || 0 ) - this.margins.top, co.left + ( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) - ( parseInt( $( ce ).css( "borderLeftWidth" ), 10 ) || 0 ) - ( parseInt( $( ce ).css( "paddingRight" ), 10 ) || 0 ) - this.helperProportions.width - this.margins.left, co.top + ( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) - ( parseInt( $( ce ).css( "borderTopWidth" ), 10 ) || 0 ) - ( parseInt( $( ce ).css( "paddingBottom" ), 10 ) || 0 ) - this.helperProportions.height - this.margins.top ]; } }, _convertPositionTo: function( d, pos ) { if ( !pos ) { pos = this.position; } var mod = d === "absolute" ? 1 : -1, scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== this.document[ 0 ] && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent, scrollIsRootNode = ( /(html|body)/i ).test( scroll[ 0 ].tagName ); return { top: ( // The absolute mouse position pos.top + // Only for relative positioned nodes: Relative offset from element to offset parent this.offset.relative.top * mod + // The offsetParent's offset without borders (offset + border) this.offset.parent.top * mod - ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod ) ), left: ( // The absolute mouse position pos.left + // Only for relative positioned nodes: Relative offset from element to offset parent this.offset.relative.left * mod + // The offsetParent's offset without borders (offset + border) this.offset.parent.left * mod - ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod ) ) }; }, _generatePosition: function( event ) { var top, left, o = this.options, pageX = event.pageX, pageY = event.pageY, scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== this.document[ 0 ] && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent, scrollIsRootNode = ( /(html|body)/i ).test( scroll[ 0 ].tagName ); // This is another very weird special case that only happens for relative elements: // 1. If the css position is relative // 2. and the scroll parent is the document or similar to the offset parent // we have to refresh the relative offset during the scroll so there are no jumps if ( this.cssPosition === "relative" && !( this.scrollParent[ 0 ] !== this.document[ 0 ] && this.scrollParent[ 0 ] !== this.offsetParent[ 0 ] ) ) { this.offset.relative = this._getRelativeOffset(); } /* * - Position constraining - * Constrain the position to a mix of grid, containment. */ if ( this.originalPosition ) { //If we are not dragging yet, we won't check for options if ( this.containment ) { if ( event.pageX - this.offset.click.left < this.containment[ 0 ] ) { pageX = this.containment[ 0 ] + this.offset.click.left; } if ( event.pageY - this.offset.click.top < this.containment[ 1 ] ) { pageY = this.containment[ 1 ] + this.offset.click.top; } if ( event.pageX - this.offset.click.left > this.containment[ 2 ] ) { pageX = this.containment[ 2 ] + this.offset.click.left; } if ( event.pageY - this.offset.click.top > this.containment[ 3 ] ) { pageY = this.containment[ 3 ] + this.offset.click.top; } } if ( o.grid ) { top = this.originalPageY + Math.round( ( pageY - this.originalPageY ) / o.grid[ 1 ] ) * o.grid[ 1 ]; pageY = this.containment ? ( ( top - this.offset.click.top >= this.containment[ 1 ] && top - this.offset.click.top <= this.containment[ 3 ] ) ? top : ( ( top - this.offset.click.top >= this.containment[ 1 ] ) ? top - o.grid[ 1 ] : top + o.grid[ 1 ] ) ) : top; left = this.originalPageX + Math.round( ( pageX - this.originalPageX ) / o.grid[ 0 ] ) * o.grid[ 0 ]; pageX = this.containment ? ( ( left - this.offset.click.left >= this.containment[ 0 ] && left - this.offset.click.left <= this.containment[ 2 ] ) ? left : ( ( left - this.offset.click.left >= this.containment[ 0 ] ) ? left - o.grid[ 0 ] : left + o.grid[ 0 ] ) ) : left; } } return { top: ( // The absolute mouse position pageY - // Click offset (relative to the element) this.offset.click.top - // Only for relative positioned nodes: Relative offset from element to offset parent this.offset.relative.top - // The offsetParent's offset without borders (offset + border) this.offset.parent.top + ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) ) ), left: ( // The absolute mouse position pageX - // Click offset (relative to the element) this.offset.click.left - // Only for relative positioned nodes: Relative offset from element to offset parent this.offset.relative.left - // The offsetParent's offset without borders (offset + border) this.offset.parent.left + ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) ) ) }; }, _rearrange: function( event, i, a, hardRefresh ) { a ? a[ 0 ].appendChild( this.placeholder[ 0 ] ) : i.item[ 0 ].parentNode.insertBefore( this.placeholder[ 0 ], ( this.direction === "down" ? i.item[ 0 ] : i.item[ 0 ].nextSibling ) ); //Various things done here to improve the performance: // 1. we create a setTimeout, that calls refreshPositions // 2. on the instance, we have a counter variable, that get's higher after every append // 3. on the local scope, we copy the counter variable, and check in the timeout, // if it's still the same // 4. this lets only the last addition to the timeout stack through this.counter = this.counter ? ++this.counter : 1; var counter = this.counter; this._delay( function() { if ( counter === this.counter ) { //Precompute after each DOM insertion, NOT on mousemove this.refreshPositions( !hardRefresh ); } } ); }, _clear: function( event, noPropagation ) { this.reverting = false; // We delay all events that have to be triggered to after the point where the placeholder // has been removed and everything else normalized again var i, delayedTriggers = []; // We first have to update the dom position of the actual currentItem // Note: don't do it if the current item is already removed (by a user), or it gets // reappended (see #4088) if ( !this._noFinalSort && this.currentItem.parent().length ) { this.placeholder.before( this.currentItem ); } this._noFinalSort = null; if ( this.helper[ 0 ] === this.currentItem[ 0 ] ) { for ( i in this._storedCSS ) { if ( this._storedCSS[ i ] === "auto" || this._storedCSS[ i ] === "static" ) { this._storedCSS[ i ] = ""; } } this.currentItem.css( this._storedCSS ); this._removeClass( this.currentItem, "ui-sortable-helper" ); } else { this.currentItem.show(); } if ( this.fromOutside && !noPropagation ) { delayedTriggers.push( function( event ) { this._trigger( "receive", event, this._uiHash( this.fromOutside ) ); } ); } if ( ( this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not( ".ui-sortable-helper" )[ 0 ] || this.domPosition.parent !== this.currentItem.parent()[ 0 ] ) && !noPropagation ) { // Trigger update callback if the DOM position has changed delayedTriggers.push( function( event ) { this._trigger( "update", event, this._uiHash() ); } ); } // Check if the items Container has Changed and trigger appropriate // events. if ( this !== this.currentContainer ) { if ( !noPropagation ) { delayedTriggers.push( function( event ) { this._trigger( "remove", event, this._uiHash() ); } ); delayedTriggers.push( ( function( c ) { return function( event ) { c._trigger( "receive", event, this._uiHash( this ) ); }; } ).call( this, this.currentContainer ) ); delayedTriggers.push( ( function( c ) { return function( event ) { c._trigger( "update", event, this._uiHash( this ) ); }; } ).call( this, this.currentContainer ) ); } } //Post events to containers function delayEvent( type, instance, container ) { return function( event ) { container._trigger( type, event, instance._uiHash( instance ) ); }; } for ( i = this.containers.length - 1; i >= 0; i-- ) { if ( !noPropagation ) { delayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) ); } if ( this.containers[ i ].containerCache.over ) { delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) ); this.containers[ i ].containerCache.over = 0; } } //Do what was originally in plugins if ( this.storedCursor ) { this.document.find( "body" ).css( "cursor", this.storedCursor ); this.storedStylesheet.remove(); } if ( this._storedOpacity ) { this.helper.css( "opacity", this._storedOpacity ); } if ( this._storedZIndex ) { this.helper.css( "zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex ); } this.dragging = false; if ( !noPropagation ) { this._trigger( "beforeStop", event, this._uiHash() ); } //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, // it unbinds ALL events from the original node! this.placeholder[ 0 ].parentNode.removeChild( this.placeholder[ 0 ] ); if ( !this.cancelHelperRemoval ) { if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) { this.helper.remove(); } this.helper = null; } if ( !noPropagation ) { for ( i = 0; i < delayedTriggers.length; i++ ) { // Trigger all delayed events delayedTriggers[ i ].call( this, event ); } this._trigger( "stop", event, this._uiHash() ); } this.fromOutside = false; return !this.cancelHelperRemoval; }, _trigger: function() { if ( $.Widget.prototype._trigger.apply( this, arguments ) === false ) { this.cancel(); } }, _uiHash: function( _inst ) { var inst = _inst || this; return { helper: inst.helper, placeholder: inst.placeholder || $( [] ), position: inst.position, originalPosition: inst.originalPosition, offset: inst.positionAbs, item: inst.currentItem, sender: _inst ? _inst.element : null }; } } ); /*! * jQuery UI Menu 1.12.1 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license */ //>>label: Menu //>>group: Widgets //>>description: Creates nestable menus. //>>docs: http://api.jqueryui.com/menu/ //>>demos: http://jqueryui.com/menu/ //>>css.structure: ../../themes/base/core.css //>>css.structure: ../../themes/base/menu.css //>>css.theme: ../../themes/base/theme.css var widgetsMenu = $.widget( "ui.menu", { version: "1.12.1", defaultElement: "
", delay: 300, options: { icons: { submenu: "ui-icon-caret-1-e" }, items: "> *", menus: "ul", position: { my: "left top", at: "right top" }, role: "menu", // Callbacks blur: null, focus: null, select: null }, _create: function() { this.activeMenu = this.element; // Flag used to prevent firing of the click handler // as the event bubbles up through nested menus this.mouseHandled = false; this.element .uniqueId() .attr( { role: this.options.role, tabIndex: 0 } ); this._addClass( "ui-menu", "ui-widget ui-widget-content" ); this._on( { // Prevent focus from sticking to links inside menu after clicking // them (focus should always stay on UL during navigation). "mousedown .ui-menu-item": function( event ) { event.preventDefault(); }, "click .ui-menu-item": function( event ) { var target = $( event.target ); var active = $( $.ui.safeActiveElement( this.document[ 0 ] ) ); if ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length ) { this.select( event ); // Only set the mouseHandled flag if the event will bubble, see #9469. if ( !event.isPropagationStopped() ) { this.mouseHandled = true; } // Open submenu on click if ( target.has( ".ui-menu" ).length ) { this.expand( event ); } else if ( !this.element.is( ":focus" ) && active.closest( ".ui-menu" ).length ) { // Redirect focus to the menu this.element.trigger( "focus", [ true ] ); // If the active item is on the top level, let it stay active. // Otherwise, blur the active item since it is no longer visible. if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) { clearTimeout( this.timer ); } } } }, "mouseenter .ui-menu-item": function( event ) { // Ignore mouse events while typeahead is active, see #10458. // Prevents focusing the wrong item when typeahead causes a scroll while the mouse // is over an item in the menu if ( this.previousFilter ) { return; } var actualTarget = $( event.target ).closest( ".ui-menu-item" ), target = $( event.currentTarget ); // Ignore bubbled events on parent items, see #11641 if ( actualTarget[ 0 ] !== target[ 0 ] ) { return; } // Remove ui-state-active class from siblings of the newly focused menu item // to avoid a jump caused by adjacent elements both having a class with a border this._removeClass( target.siblings().children( ".ui-state-active" ), null, "ui-state-active" ); this.focus( event, target ); }, mouseleave: "collapseAll", "mouseleave .ui-menu": "collapseAll", focus: function( event, keepActiveItem ) { // If there's already an active item, keep it active // If not, activate the first item var item = this.active || this.element.find( this.options.items ).eq( 0 ); if ( !keepActiveItem ) { this.focus( event, item ); } }, blur: function( event ) { this._delay( function() { var notContained = !$.contains( this.element[ 0 ], $.ui.safeActiveElement( this.document[ 0 ] ) ); if ( notContained ) { this.collapseAll( event ); } } ); }, keydown: "_keydown" } ); this.refresh(); // Clicks outside of a menu collapse any open menus this._on( this.document, { click: function( event ) { if ( this._closeOnDocumentClick( event ) ) { this.collapseAll( event ); } // Reset the mouseHandled flag this.mouseHandled = false; } } ); }, _destroy: function() { var items = this.element.find( ".ui-menu-item" ) .removeAttr( "role aria-disabled" ), submenus = items.children( ".ui-menu-item-wrapper" ) .removeUniqueId() .removeAttr( "tabIndex role aria-haspopup" ); // Destroy (sub)menus this.element .removeAttr( "aria-activedescendant" ) .find( ".ui-menu" ).addBack() .removeAttr( "role aria-labelledby aria-expanded aria-hidden aria-disabled " + "tabIndex" ) .removeUniqueId() .show(); submenus.children().each( function() { var elem = $( this ); if ( elem.data( "ui-menu-submenu-caret" ) ) { elem.remove(); } } ); }, _keydown: function( event ) { var match, prev, character, skip, preventDefault = true; switch ( event.keyCode ) { case $.ui.keyCode.PAGE_UP: this.previousPage( event ); break; case $.ui.keyCode.PAGE_DOWN: this.nextPage( event ); break; case $.ui.keyCode.HOME: this._move( "first", "first", event ); break; case $.ui.keyCode.END: this._move( "last", "last", event ); break; case $.ui.keyCode.UP: this.previous( event ); break; case $.ui.keyCode.DOWN: this.next( event ); break; case $.ui.keyCode.LEFT: this.collapse( event ); break; case $.ui.keyCode.RIGHT: if ( this.active && !this.active.is( ".ui-state-disabled" ) ) { this.expand( event ); } break; case $.ui.keyCode.ENTER: case $.ui.keyCode.SPACE: this._activate( event ); break; case $.ui.keyCode.ESCAPE: this.collapse( event ); break; default: preventDefault = false; prev = this.previousFilter || ""; skip = false; // Support number pad values character = event.keyCode >= 96 && event.keyCode <= 105 ? ( event.keyCode - 96 ).toString() : String.fromCharCode( event.keyCode ); clearTimeout( this.filterTimer ); if ( character === prev ) { skip = true; } else { character = prev + character; } match = this._filterMenuItems( character ); match = skip && match.index( this.active.next() ) !== -1 ? this.active.nextAll( ".ui-menu-item" ) : match; // If no matches on the current filter, reset to the last character pressed // to move down the menu to the first item that starts with that character if ( !match.length ) { character = String.fromCharCode( event.keyCode ); match = this._filterMenuItems( character ); } if ( match.length ) { this.focus( event, match ); this.previousFilter = character; this.filterTimer = this._delay( function() { delete this.previousFilter; }, 1000 ); } else { delete this.previousFilter; } } if ( preventDefault ) { event.preventDefault(); } }, _activate: function( event ) { if ( this.active && !this.active.is( ".ui-state-disabled" ) ) { if ( this.active.children( "[aria-haspopup='true']" ).length ) { this.expand( event ); } else { this.select( event ); } } }, refresh: function() { var menus, items, newSubmenus, newItems, newWrappers, that = this, icon = this.options.icons.submenu, submenus = this.element.find( this.options.menus ); this._toggleClass( "ui-menu-icons", null, !!this.element.find( ".ui-icon" ).length ); // Initialize nested menus newSubmenus = submenus.filter( ":not(.ui-menu)" ) .hide() .attr( { role: this.options.role, "aria-hidden": "true", "aria-expanded": "false" } ) .each( function() { var menu = $( this ), item = menu.prev(), submenuCaret = $( "" ).data( "ui-menu-submenu-caret", true ); that._addClass( submenuCaret, "ui-menu-icon", "ui-icon " + icon ); item .attr( "aria-haspopup", "true" ) .prepend( submenuCaret ); menu.attr( "aria-labelledby", item.attr( "id" ) ); } ); this._addClass( newSubmenus, "ui-menu", "ui-widget ui-widget-content ui-front" ); menus = submenus.add( this.element ); items = menus.find( this.options.items ); // Initialize menu-items containing spaces and/or dashes only as dividers items.not( ".ui-menu-item" ).each( function() { var item = $( this ); if ( that._isDivider( item ) ) { that._addClass( item, "ui-menu-divider", "ui-widget-content" ); } } ); // Don't refresh list items that are already adapted newItems = items.not( ".ui-menu-item, .ui-menu-divider" ); newWrappers = newItems.children() .not( ".ui-menu" ) .uniqueId() .attr( { tabIndex: -1, role: this._itemRole() } ); this._addClass( newItems, "ui-menu-item" ) ._addClass( newWrappers, "ui-menu-item-wrapper" ); // Add aria-disabled attribute to any disabled menu item items.filter( ".ui-state-disabled" ).attr( "aria-disabled", "true" ); // If the active item has been removed, blur the menu if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) { this.blur(); } }, _itemRole: function() { return { menu: "menuitem", listbox: "option" }[ this.options.role ]; }, _setOption: function( key, value ) { if ( key === "icons" ) { var icons = this.element.find( ".ui-menu-icon" ); this._removeClass( icons, null, this.options.icons.submenu ) ._addClass( icons, null, value.submenu ); } this._super( key, value ); }, _setOptionDisabled: function( value ) { this._super( value ); this.element.attr( "aria-disabled", String( value ) ); this._toggleClass( null, "ui-state-disabled", !!value ); }, focus: function( event, item ) { var nested, focused, activeParent; this.blur( event, event && event.type === "focus" ); this._scrollIntoView( item ); this.active = item.first(); focused = this.active.children( ".ui-menu-item-wrapper" ); this._addClass( focused, null, "ui-state-active" ); // Only update aria-activedescendant if there's a role // otherwise we assume focus is managed elsewhere if ( this.options.role ) { this.element.attr( "aria-activedescendant", focused.attr( "id" ) ); } // Highlight active parent menu item, if any activeParent = this.active .parent() .closest( ".ui-menu-item" ) .children( ".ui-menu-item-wrapper" ); this._addClass( activeParent, null, "ui-state-active" ); if ( event && event.type === "keydown" ) { this._close(); } else { this.timer = this._delay( function() { this._close(); }, this.delay ); } nested = item.children( ".ui-menu" ); if ( nested.length && event && ( /^mouse/.test( event.type ) ) ) { this._startOpening( nested ); } this.activeMenu = item.parent(); this._trigger( "focus", event, { item: item } ); }, _scrollIntoView: function( item ) { var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight; if ( this._hasScroll() ) { borderTop = parseFloat( $.css( this.activeMenu[ 0 ], "borderTopWidth" ) ) || 0; paddingTop = parseFloat( $.css( this.activeMenu[ 0 ], "paddingTop" ) ) || 0; offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop; scroll = this.activeMenu.scrollTop(); elementHeight = this.activeMenu.height(); itemHeight = item.outerHeight(); if ( offset < 0 ) { this.activeMenu.scrollTop( scroll + offset ); } else if ( offset + itemHeight > elementHeight ) { this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight ); } } }, blur: function( event, fromFocus ) { if ( !fromFocus ) { clearTimeout( this.timer ); } if ( !this.active ) { return; } this._removeClass( this.active.children( ".ui-menu-item-wrapper" ), null, "ui-state-active" ); this._trigger( "blur", event, { item: this.active } ); this.active = null; }, _startOpening: function( submenu ) { clearTimeout( this.timer ); // Don't open if already open fixes a Firefox bug that caused a .5 pixel // shift in the submenu position when mousing over the caret icon if ( submenu.attr( "aria-hidden" ) !== "true" ) { return; } this.timer = this._delay( function() { this._close(); this._open( submenu ); }, this.delay ); }, _open: function( submenu ) { var position = $.extend( { of: this.active }, this.options.position ); clearTimeout( this.timer ); this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) ) .hide() .attr( "aria-hidden", "true" ); submenu .show() .removeAttr( "aria-hidden" ) .attr( "aria-expanded", "true" ) .position( position ); }, collapseAll: function( event, all ) { clearTimeout( this.timer ); this.timer = this._delay( function() { // If we were passed an event, look for the submenu that contains the event var currentMenu = all ? this.element : $( event && event.target ).closest( this.element.find( ".ui-menu" ) ); // If we found no valid submenu ancestor, use the main menu to close all // sub menus anyway if ( !currentMenu.length ) { currentMenu = this.element; } this._close( currentMenu ); this.blur( event ); // Work around active item staying active after menu is blurred this._removeClass( currentMenu.find( ".ui-state-active" ), null, "ui-state-active" ); this.activeMenu = currentMenu; }, this.delay ); }, // With no arguments, closes the currently active menu - if nothing is active // it closes all menus. If passed an argument, it will search for menus BELOW _close: function( startMenu ) { if ( !startMenu ) { startMenu = this.active ? this.active.parent() : this.element; } startMenu.find( ".ui-menu" ) .hide() .attr( "aria-hidden", "true" ) .attr( "aria-expanded", "false" ); }, _closeOnDocumentClick: function( event ) { return !$( event.target ).closest( ".ui-menu" ).length; }, _isDivider: function( item ) { // Match hyphen, em dash, en dash return !/[^\-\u2014\u2013\s]/.test( item.text() ); }, collapse: function( event ) { var newItem = this.active && this.active.parent().closest( ".ui-menu-item", this.element ); if ( newItem && newItem.length ) { this._close(); this.focus( event, newItem ); } }, expand: function( event ) { var newItem = this.active && this.active .children( ".ui-menu " ) .find( this.options.items ) .first(); if ( newItem && newItem.length ) { this._open( newItem.parent() ); // Delay so Firefox will not hide activedescendant change in expanding submenu from AT this._delay( function() { this.focus( event, newItem ); } ); } }, next: function( event ) { this._move( "next", "first", event ); }, previous: function( event ) { this._move( "prev", "last", event ); }, isFirstItem: function() { return this.active && !this.active.prevAll( ".ui-menu-item" ).length; }, isLastItem: function() { return this.active && !this.active.nextAll( ".ui-menu-item" ).length; }, _move: function( direction, filter, event ) { var next; if ( this.active ) { if ( direction === "first" || direction === "last" ) { next = this.active [ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" ) .eq( -1 ); } else { next = this.active [ direction + "All" ]( ".ui-menu-item" ) .eq( 0 ); } } if ( !next || !next.length || !this.active ) { next = this.activeMenu.find( this.options.items )[ filter ](); } this.focus( event, next ); }, nextPage: function( event ) { var item, base, height; if ( !this.active ) { this.next( event ); return; } if ( this.isLastItem() ) { return; } if ( this._hasScroll() ) { base = this.active.offset().top; height = this.element.height(); this.active.nextAll( ".ui-menu-item" ).each( function() { item = $( this ); return item.offset().top - base - height < 0; } ); this.focus( event, item ); } else { this.focus( event, this.activeMenu.find( this.options.items ) [ !this.active ? "first" : "last" ]() ); } }, previousPage: function( event ) { var item, base, height; if ( !this.active ) { this.next( event ); return; } if ( this.isFirstItem() ) { return; } if ( this._hasScroll() ) { base = this.active.offset().top; height = this.element.height(); this.active.prevAll( ".ui-menu-item" ).each( function() { item = $( this ); return item.offset().top - base + height > 0; } ); this.focus( event, item ); } else { this.focus( event, this.activeMenu.find( this.options.items ).first() ); } }, _hasScroll: function() { return this.element.outerHeight() < this.element.prop( "scrollHeight" ); }, select: function( event ) { // TODO: It should never be possible to not have an active item at this // point, but the tests don't trigger mouseenter before click. this.active = this.active || $( event.target ).closest( ".ui-menu-item" ); var ui = { item: this.active }; if ( !this.active.has( ".ui-menu" ).length ) { this.collapseAll( event, true ); } this._trigger( "select", event, ui ); }, _filterMenuItems: function( character ) { var escapedCharacter = character.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" ), regex = new RegExp( "^" + escapedCharacter, "i" ); return this.activeMenu .find( this.options.items ) // Only match on items, not dividers or other content (#10571) .filter( ".ui-menu-item" ) .filter( function() { return regex.test( $.trim( $( this ).children( ".ui-menu-item-wrapper" ).text() ) ); } ); } } ); /*! * jQuery UI Autocomplete 1.12.1 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license */ //>>label: Autocomplete //>>group: Widgets //>>description: Lists suggested words as the user is typing. //>>docs: http://api.jqueryui.com/autocomplete/ //>>demos: http://jqueryui.com/autocomplete/ //>>css.structure: ../../themes/base/core.css //>>css.structure: ../../themes/base/autocomplete.css //>>css.theme: ../../themes/base/theme.css $.widget( "ui.autocomplete", { version: "1.12.1", defaultElement: "
", options: { appendTo: null, autoFocus: false, delay: 300, minLength: 1, position: { my: "left top", at: "left bottom", collision: "none" }, source: null, // Callbacks change: null, close: null, focus: null, open: null, response: null, search: null, select: null }, requestIndex: 0, pending: 0, _create: function() { // Some browsers only repeat keydown events, not keypress events, // so we use the suppressKeyPress flag to determine if we've already // handled the keydown event. #7269 // Unfortunately the code for & in keypress is the same as the up arrow, // so we use the suppressKeyPressRepeat flag to avoid handling keypress // events when we know the keydown event was used to modify the // search term. #7799 var suppressKeyPress, suppressKeyPressRepeat, suppressInput, nodeName = this.element[ 0 ].nodeName.toLowerCase(), isTextarea = nodeName === "textarea", isInput = nodeName === "input"; // Textareas are always multi-line // Inputs are always single-line, even if inside a contentEditable element // IE also treats inputs as contentEditable // All other element types are determined by whether or not they're contentEditable this.isMultiLine = isTextarea || !isInput && this._isContentEditable( this.element ); this.valueMethod = this.element[ isTextarea || isInput ? "val" : "text" ]; this.isNewMenu = true; this._addClass( "ui-autocomplete-input" ); this.element.attr( "autocomplete", "off" ); this._on( this.element, { keydown: function( event ) { if ( this.element.prop( "readOnly" ) ) { suppressKeyPress = true; suppressInput = true; suppressKeyPressRepeat = true; return; } suppressKeyPress = false; suppressInput = false; suppressKeyPressRepeat = false; var keyCode = $.ui.keyCode; switch ( event.keyCode ) { case keyCode.PAGE_UP: suppressKeyPress = true; this._move( "previousPage", event ); break; case keyCode.PAGE_DOWN: suppressKeyPress = true; this._move( "nextPage", event ); break; case keyCode.UP: suppressKeyPress = true; this._keyEvent( "previous", event ); break; case keyCode.DOWN: suppressKeyPress = true; this._keyEvent( "next", event ); break; case keyCode.ENTER: // when menu is open and has focus if ( this.menu.active ) { // #6055 - Opera still allows the keypress to occur // which causes forms to submit suppressKeyPress = true; event.preventDefault(); this.menu.select( event ); } break; case keyCode.TAB: if ( this.menu.active ) { this.menu.select( event ); } break; case keyCode.ESCAPE: if ( this.menu.element.is( ":visible" ) ) { if ( !this.isMultiLine ) { this._value( this.term ); } this.close( event ); // Different browsers have different default behavior for escape // Single press can mean undo or clear // Double press in IE means clear the whole form event.preventDefault(); } break; default: suppressKeyPressRepeat = true; // search timeout should be triggered before the input value is changed this._searchTimeout( event ); break; } }, keypress: function( event ) { if ( suppressKeyPress ) { suppressKeyPress = false; if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) { event.preventDefault(); } return; } if ( suppressKeyPressRepeat ) { return; } // Replicate some key handlers to allow them to repeat in Firefox and Opera var keyCode = $.ui.keyCode; switch ( event.keyCode ) { case keyCode.PAGE_UP: this._move( "previousPage", event ); break; case keyCode.PAGE_DOWN: this._move( "nextPage", event ); break; case keyCode.UP: this._keyEvent( "previous", event ); break; case keyCode.DOWN: this._keyEvent( "next", event ); break; } }, input: function( event ) { if ( suppressInput ) { suppressInput = false; event.preventDefault(); return; } this._searchTimeout( event ); }, focus: function() { this.selectedItem = null; this.previous = this._value(); }, blur: function( event ) { if ( this.cancelBlur ) { delete this.cancelBlur; return; } clearTimeout( this.searching ); this.close( event ); this._change( event ); } } ); this._initSource(); this.menu = $( "
" ) .appendTo( this._appendTo() ) .menu( { // disable ARIA support, the live region takes care of that role: null } ) .hide() .menu( "instance" ); this._addClass( this.menu.element, "ui-autocomplete", "ui-front" ); this._on( this.menu.element, { mousedown: function( event ) { // prevent moving focus out of the text field event.preventDefault(); // IE doesn't prevent moving focus even with event.preventDefault() // so we set a flag to know when we should ignore the blur event this.cancelBlur = true; this._delay( function() { delete this.cancelBlur; // Support: IE 8 only // Right clicking a menu item or selecting text from the menu items will // result in focus moving out of the input. However, we've already received // and ignored the blur event because of the cancelBlur flag set above. So // we restore focus to ensure that the menu closes properly based on the user's // next actions. if ( this.element[ 0 ] !== $.ui.safeActiveElement( this.document[ 0 ] ) ) { this.element.trigger( "focus" ); } } ); }, menufocus: function( event, ui ) { var label, item; // support: Firefox // Prevent accidental activation of menu items in Firefox (#7024 #9118) if ( this.isNewMenu ) { this.isNewMenu = false; if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) { this.menu.blur(); this.document.one( "mousemove", function() { $( event.target ).trigger( event.originalEvent ); } ); return; } } item = ui.item.data( "ui-autocomplete-item" ); if ( false !== this._trigger( "focus", event, { item: item } ) ) { // use value to match what will end up in the input, if it was a key event if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) { this._value( item.value ); } } // Announce the value in the liveRegion label = ui.item.attr( "aria-label" ) || item.value; if ( label && $.trim( label ).length ) { this.liveRegion.children().hide(); $( "
" ).text( label ).appendTo( this.liveRegion ); } }, menuselect: function( event, ui ) { var item = ui.item.data( "ui-autocomplete-item" ), previous = this.previous; // Only trigger when focus was lost (click on menu) if ( this.element[ 0 ] !== $.ui.safeActiveElement( this.document[ 0 ] ) ) { this.element.trigger( "focus" ); this.previous = previous; // #6109 - IE triggers two focus events and the second // is asynchronous, so we need to reset the previous // term synchronously and asynchronously :-( this._delay( function() { this.previous = previous; this.selectedItem = item; } ); } if ( false !== this._trigger( "select", event, { item: item } ) ) { this._value( item.value ); } // reset the term after the select event // this allows custom select handling to work properly this.term = this._value(); this.close( event ); this.selectedItem = item; } } ); this.liveRegion = $( "
", { role: "status", "aria-live": "assertive", "aria-relevant": "additions" } ) .appendTo( this.document[ 0 ].body ); this._addClass( this.liveRegion, null, "ui-helper-hidden-accessible" ); // Turning off autocomplete prevents the browser from remembering the // value when navigating through history, so we re-enable autocomplete // if the page is unloaded before the widget is destroyed. #7790 this._on( this.window, { beforeunload: function() { this.element.removeAttr( "autocomplete" ); } } ); }, _destroy: function() { clearTimeout( this.searching ); this.element.removeAttr( "autocomplete" ); this.menu.element.remove(); this.liveRegion.remove(); }, _setOption: function( key, value ) { this._super( key, value ); if ( key === "source" ) { this._initSource(); } if ( key === "appendTo" ) { this.menu.element.appendTo( this._appendTo() ); } if ( key === "disabled" && value && this.xhr ) { this.xhr.abort(); } }, _isEventTargetInWidget: function( event ) { var menuElement = this.menu.element[ 0 ]; return event.target === this.element[ 0 ] || event.target === menuElement || $.contains( menuElement, event.target ); }, _closeOnClickOutside: function( event ) { if ( !this._isEventTargetInWidget( event ) ) { this.close(); } }, _appendTo: function() { var element = this.options.appendTo; if ( element ) { element = element.jquery || element.nodeType ? $( element ) : this.document.find( element ).eq( 0 ); } if ( !element || !element[ 0 ] ) { element = this.element.closest( ".ui-front, dialog" ); } if ( !element.length ) { element = this.document[ 0 ].body; } return element; }, _initSource: function() { var array, url, that = this; if ( $.isArray( this.options.source ) ) { array = this.options.source; this.source = function( request, response ) { response( $.ui.autocomplete.filter( array, request.term ) ); }; } else if ( typeof this.options.source === "string" ) { url = this.options.source; this.source = function( request, response ) { if ( that.xhr ) { that.xhr.abort(); } that.xhr = $.ajax( { url: url, data: request, dataType: "json", success: function( data ) { response( data ); }, error: function() { response( [] ); } } ); }; } else { this.source = this.options.source; } }, _searchTimeout: function( event ) { clearTimeout( this.searching ); this.searching = this._delay( function() { // Search if the value has changed, or if the user retypes the same value (see #7434) var equalValues = this.term === this._value(), menuVisible = this.menu.element.is( ":visible" ), modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey; if ( !equalValues || ( equalValues && !menuVisible && !modifierKey ) ) { this.selectedItem = null; this.search( null, event ); } }, this.options.delay ); }, search: function( value, event ) { value = value != null ? value : this._value(); // Always save the actual value, not the one passed as an argument this.term = this._value(); if ( value.length < this.options.minLength ) { return this.close( event ); } if ( this._trigger( "search", event ) === false ) { return; } return this._search( value ); }, _search: function( value ) { this.pending++; this._addClass( "ui-autocomplete-loading" ); this.cancelSearch = false; this.source( { term: value }, this._response() ); }, _response: function() { var index = ++this.requestIndex; return $.proxy( function( content ) { if ( index === this.requestIndex ) { this.__response( content ); } this.pending--; if ( !this.pending ) { this._removeClass( "ui-autocomplete-loading" ); } }, this ); }, __response: function( content ) { if ( content ) { content = this._normalize( content ); } this._trigger( "response", null, { content: content } ); if ( !this.options.disabled && content && content.length && !this.cancelSearch ) { this._suggest( content ); this._trigger( "open" ); } else { // use ._close() instead of .close() so we don't cancel future searches this._close(); } }, close: function( event ) { this.cancelSearch = true; this._close( event ); }, _close: function( event ) { // Remove the handler that closes the menu on outside clicks this._off( this.document, "mousedown" ); if ( this.menu.element.is( ":visible" ) ) { this.menu.element.hide(); this.menu.blur(); this.isNewMenu = true; this._trigger( "close", event ); } }, _change: function( event ) { if ( this.previous !== this._value() ) { this._trigger( "change", event, { item: this.selectedItem } ); } }, _normalize: function( items ) { // assume all items have the right format when the first item is complete if ( items.length && items[ 0 ].label && items[ 0 ].value ) { return items; } return $.map( items, function( item ) { if ( typeof item === "string" ) { return { label: item, value: item }; } return $.extend( {}, item, { label: item.label || item.value, value: item.value || item.label } ); } ); }, _suggest: function( items ) { var ul = this.menu.element.empty(); this._renderMenu( ul, items ); this.isNewMenu = true; this.menu.refresh(); // Size and position menu ul.show(); this._resizeMenu(); ul.position( $.extend( { of: this.element }, this.options.position ) ); if ( this.options.autoFocus ) { this.menu.next(); } // Listen for interactions outside of the widget (#6642) this._on( this.document, { mousedown: "_closeOnClickOutside" } ); }, _resizeMenu: function() { var ul = this.menu.element; ul.outerWidth( Math.max( // Firefox wraps long text (possibly a rounding bug) // so we add 1px to avoid the wrapping (#7513) ul.width( "" ).outerWidth() + 1, this.element.outerWidth() ) ); }, _renderMenu: function( ul, items ) { var that = this; $.each( items, function( index, item ) { that._renderItemData( ul, item ); } ); }, _renderItemData: function( ul, item ) { return this._renderItem( ul, item ).data( "ui-autocomplete-item", item ); }, _renderItem: function( ul, item ) { return $( "
" ) .append( $( "
" ).text( item.label ) ) .appendTo( ul ); }, _move: function( direction, event ) { if ( !this.menu.element.is( ":visible" ) ) { this.search( null, event ); return; } if ( this.menu.isFirstItem() && /^previous/.test( direction ) || this.menu.isLastItem() && /^next/.test( direction ) ) { if ( !this.isMultiLine ) { this._value( this.term ); } this.menu.blur(); return; } this.menu[ direction ]( event ); }, widget: function() { return this.menu.element; }, _value: function() { return this.valueMethod.apply( this.element, arguments ); }, _keyEvent: function( keyEvent, event ) { if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) { this._move( keyEvent, event ); // Prevents moving cursor to beginning/end of the text field in some browsers event.preventDefault(); } }, // Support: Chrome <=50 // We should be able to just use this.element.prop( "isContentEditable" ) // but hidden elements always report false in Chrome. // https://code.google.com/p/chromium/issues/detail?id=313082 _isContentEditable: function( element ) { if ( !element.length ) { return false; } var editable = element.prop( "contentEditable" ); if ( editable === "inherit" ) { return this._isContentEditable( element.parent() ); } return editable === "true"; } } ); $.extend( $.ui.autocomplete, { escapeRegex: function( value ) { return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" ); }, filter: function( array, term ) { var matcher = new RegExp( $.ui.autocomplete.escapeRegex( term ), "i" ); return $.grep( array, function( value ) { return matcher.test( value.label || value.value || value ); } ); } } ); // Live region extension, adding a `messages` option // NOTE: This is an experimental API. We are still investigating // a full solution for string manipulation and internationalization. $.widget( "ui.autocomplete", $.ui.autocomplete, { options: { messages: { noResults: "No search results.", results: function( amount ) { return amount + ( amount > 1 ? " results are" : " result is" ) + " available, use up and down arrow keys to navigate."; } } }, __response: function( content ) { var message; this._superApply( arguments ); if ( this.options.disabled || this.cancelSearch ) { return; } if ( content && content.length ) { message = this.options.messages.results( content.length ); } else { message = this.options.messages.noResults; } this.liveRegion.children().hide(); $( "
" ).text( message ).appendTo( this.liveRegion ); } } ); var widgetsAutocomplete = $.ui.autocomplete; // jscs:disable maximumLineLength /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */ /*! * jQuery UI Datepicker 1.12.1 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license */ //>>label: Datepicker //>>group: Widgets //>>description: Displays a calendar from an input or inline for selecting dates. //>>docs: http://api.jqueryui.com/datepicker/ //>>demos: http://jqueryui.com/datepicker/ //>>css.structure: ../../themes/base/core.css //>>css.structure: ../../themes/base/datepicker.css //>>css.theme: ../../themes/base/theme.css $.extend( $.ui, { datepicker: { version: "1.12.1" } } ); var datepicker_instActive; function datepicker_getZindex( elem ) { var position, value; while ( elem.length && elem[ 0 ] !== document ) { // Ignore z-index if position is set to a value where z-index is ignored by the browser // This makes behavior of this function consistent across browsers // WebKit always returns auto if the element is positioned position = elem.css( "position" ); if ( position === "absolute" || position === "relative" || position === "fixed" ) { // IE returns 0 when zIndex is not specified // other browsers return a string // we ignore the case of nested elements with an explicit value of 0 //
value = parseInt( elem.css( "zIndex" ), 10 ); if ( !isNaN( value ) && value !== 0 ) { return value; } } elem = elem.parent(); } return 0; } /* Date picker manager. Use the singleton instance of this class, $.datepicker, to interact with the date picker. Settings for (groups of) date pickers are maintained in an instance object, allowing multiple different settings on the same page. */ function Datepicker() { this._curInst = null; // The current instance in use this._keyEvent = false; // If the last event was a key event this._disabledInputs = []; // List of date picker inputs that have been disabled this._datepickerShowing = false; // true if the popup picker is showing , false if not this._inDialog = false; // true if showing within a "dialog", false if not this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class this._appendClass = "ui-datepicker-append"; // The name of the append marker class this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class this.regional = []; // Available regional settings, indexed by language code this.regional[ "" ] = { // Default regional settings closeText: "Done", // Display text for close link prevText: "Prev", // Display text for previous month link nextText: "Next", // Display text for next month link currentText: "Today", // Display text for current month link monthNames: [ "January","February","March","April","May","June", "July","August","September","October","November","December" ], // Names of months for drop-down and formatting monthNamesShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], // For formatting dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], // For formatting dayNamesShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], // For formatting dayNamesMin: [ "Su","Mo","Tu","We","Th","Fr","Sa" ], // Column headings for days starting at Sunday weekHeader: "Wk", // Column header for week of the year dateFormat: "mm/dd/yy", // See format options on parseDate firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ... isRTL: false, // true if right-to-left language, false if left-to-right showMonthAfterYear: false, // true if the year select precedes month, false for month then year yearSuffix: "" // Additional text to append to the year in the month headers }; this._defaults = { // Global defaults for all the date picker instances showOn: "focus", // "focus" for popup on focus, // "button" for trigger button, or "both" for either showAnim: "fadeIn", // Name of jQuery animation for popup showOptions: {}, // Options for enhanced animations defaultDate: null, // Used when field is blank: actual date, // +/-number for offset from today, null for today appendText: "", // Display text following the input box, e.g. showing the format buttonText: "...", // Text for trigger button buttonImage: "", // URL for trigger button image buttonImageOnly: false, // true if the image appears alone, false if it appears on a button hideIfNoPrevNext: false, // true to hide next/previous month links // if not applicable, false to just disable them navigationAsDateFormat: false, // true if date formatting applied to prev/today/next links gotoCurrent: false, // true if today link goes back to current selection instead changeMonth: false, // true if month can be selected directly, false if only prev/next changeYear: false, // true if year can be selected directly, false if only prev/next yearRange: "c-10:c+10", // Range of years to display in drop-down, // either relative to today's year (-nn:+nn), relative to currently displayed year // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n) showOtherMonths: false, // true to show dates in other months, false to leave blank selectOtherMonths: false, // true to allow selection of dates in other months, false for unselectable showWeek: false, // true to show week of the year, false to not show it calculateWeek: this.iso8601Week, // How to calculate the week of the year, // takes a Date and returns the number of the week for it shortYearCutoff: "+10", // Short year values < this are in the current century, // > this are in the previous century, // string value starting with "+" for current year + value minDate: null, // The earliest selectable date, or null for no limit maxDate: null, // The latest selectable date, or null for no limit duration: "fast", // Duration of display/closure beforeShowDay: null, // Function that takes a date and returns an array with // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "", // [2] = cell title (optional), e.g. $.datepicker.noWeekends beforeShow: null, // Function that takes an input field and // returns a set of custom settings for the date picker onSelect: null, // Define a callback function when a date is selected onchangeMonthYear: null, // Define a callback function when the month or year is changed onClose: null, // Define a callback function when the datepicker is closed numberOfMonths: 1, // Number of months to show at a time showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0) stepMonths: 1, // Number of months to step back/forward stepBigMonths: 12, // Number of months to step back/forward for the big links altField: "", // Selector for an alternate field to store selected dates into altFormat: "", // The date format to use for the alternate field constrainInput: true, // The input is constrained by the current date format showButtonPanel: false, // true to show button panel, false to not show it autoSize: false, // true to size the input for the date format, false to leave as is disabled: false // The initial disabled state }; $.extend( this._defaults, this.regional[ "" ] ); this.regional.en = $.extend( true, {}, this.regional[ "" ] ); this.regional[ "en-US" ] = $.extend( true, {}, this.regional.en ); this.dpDiv = datepicker_bindHover( $( "
" ) ); } $.extend( Datepicker.prototype, { /* Class name added to elements to indicate already configured with a date picker. */ markerClassName: "hasDatepicker", //Keep track of the maximum number of rows displayed (see #7043) maxRows: 4, // TODO rename to "widget" when switching to widget factory _widgetDatepicker: function() { return this.dpDiv; }, /* Override the default settings for all instances of the date picker. * @param settings object - the new settings to use as defaults (anonymous object) * @return the manager object */ setDefaults: function( settings ) { datepicker_extendRemove( this._defaults, settings || {} ); return this; }, /* Attach the date picker to a jQuery selection. * @param target element - the target input field or division or span * @param settings object - the new settings to use for this date picker instance (anonymous) */ _attachDatepicker: function( target, settings ) { var nodeName, inline, inst; nodeName = target.nodeName.toLowerCase(); inline = ( nodeName === "div" || nodeName === "span" ); if ( !target.id ) { this.uuid += 1; target.id = "dp" + this.uuid; } inst = this._newInst( $( target ), inline ); inst.settings = $.extend( {}, settings || {} ); if ( nodeName === "input" ) { this._connectDatepicker( target, inst ); } else if ( inline ) { this._inlineDatepicker( target, inst ); } }, /* Create a new instance object. */ _newInst: function( target, inline ) { var id = target[ 0 ].id.replace( /([^A-Za-z0-9_\-])/g, "\\\\$1" ); // escape jQuery meta chars return { id: id, input: target, // associated target selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection drawMonth: 0, drawYear: 0, // month being drawn inline: inline, // is datepicker inline or not dpDiv: ( !inline ? this.dpDiv : // presentation div datepicker_bindHover( $( "
" ) ) ) }; }, /* Attach the date picker to an input field. */ _connectDatepicker: function( target, inst ) { var input = $( target ); inst.append = $( [] ); inst.trigger = $( [] ); if ( input.hasClass( this.markerClassName ) ) { return; } this._attachments( input, inst ); input.addClass( this.markerClassName ).on( "keydown", this._doKeyDown ). on( "keypress", this._doKeyPress ).on( "keyup", this._doKeyUp ); this._autoSize( inst ); $.data( target, "datepicker", inst ); //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665) if ( inst.settings.disabled ) { this._disableDatepicker( target ); } }, /* Make attachments based on settings. */ _attachments: function( input, inst ) { var showOn, buttonText, buttonImage, appendText = this._get( inst, "appendText" ), isRTL = this._get( inst, "isRTL" ); if ( inst.append ) { inst.append.remove(); } if ( appendText ) { inst.append = $( "" + appendText + "" ); input[ isRTL ? "before" : "after" ]( inst.append ); } input.off( "focus", this._showDatepicker ); if ( inst.trigger ) { inst.trigger.remove(); } showOn = this._get( inst, "showOn" ); if ( showOn === "focus" || showOn === "both" ) { // pop-up date picker when in the marked field input.on( "focus", this._showDatepicker ); } if ( showOn === "button" || showOn === "both" ) { // pop-up date picker when button clicked buttonText = this._get( inst, "buttonText" ); buttonImage = this._get( inst, "buttonImage" ); inst.trigger = $( this._get( inst, "buttonImageOnly" ) ? $( "" ).addClass( this._triggerClass ). attr( { src: buttonImage, alt: buttonText, title: buttonText } ) : $( "" ).addClass( this._triggerClass ). html( !buttonImage ? buttonText : $( "" ).attr( { src:buttonImage, alt:buttonText, title:buttonText } ) ) ); input[ isRTL ? "before" : "after" ]( inst.trigger ); inst.trigger.on( "click", function() { if ( $.datepicker._datepickerShowing && $.datepicker._lastInput === input[ 0 ] ) { $.datepicker._hideDatepicker(); } else if ( $.datepicker._datepickerShowing && $.datepicker._lastInput !== input[ 0 ] ) { $.datepicker._hideDatepicker(); $.datepicker._showDatepicker( input[ 0 ] ); } else { $.datepicker._showDatepicker( input[ 0 ] ); } return false; } ); } }, /* Apply the maximum length for the date format. */ _autoSize: function( inst ) { if ( this._get( inst, "autoSize" ) && !inst.inline ) { var findMax, max, maxI, i, date = new Date( 2009, 12 - 1, 20 ), // Ensure double digits dateFormat = this._get( inst, "dateFormat" ); if ( dateFormat.match( /[DM]/ ) ) { findMax = function( names ) { max = 0; maxI = 0; for ( i = 0; i < names.length; i++ ) { if ( names[ i ].length > max ) { max = names[ i ].length; maxI = i; } } return maxI; }; date.setMonth( findMax( this._get( inst, ( dateFormat.match( /MM/ ) ? "monthNames" : "monthNamesShort" ) ) ) ); date.setDate( findMax( this._get( inst, ( dateFormat.match( /DD/ ) ? "dayNames" : "dayNamesShort" ) ) ) + 20 - date.getDay() ); } inst.input.attr( "size", this._formatDate( inst, date ).length ); } }, /* Attach an inline date picker to a div. */ _inlineDatepicker: function( target, inst ) { var divSpan = $( target ); if ( divSpan.hasClass( this.markerClassName ) ) { return; } divSpan.addClass( this.markerClassName ).append( inst.dpDiv ); $.data( target, "datepicker", inst ); this._setDate( inst, this._getDefaultDate( inst ), true ); this._updateDatepicker( inst ); this._updateAlternate( inst ); //If disabled option is true, disable the datepicker before showing it (see ticket #5665) if ( inst.settings.disabled ) { this._disableDatepicker( target ); } // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height inst.dpDiv.css( "display", "block" ); }, /* Pop-up the date picker in a "dialog" box. * @param input element - ignored * @param date string or Date - the initial date to display * @param onSelect function - the function to call when a date is selected * @param settings object - update the dialog date picker instance's settings (anonymous object) * @param pos int[2] - coordinates for the dialog's position within the screen or * event - with x/y coordinates or * leave empty for default (screen centre) * @return the manager object */ _dialogDatepicker: function( input, date, onSelect, settings, pos ) { var id, browserWidth, browserHeight, scrollX, scrollY, inst = this._dialogInst; // internal instance if ( !inst ) { this.uuid += 1; id = "dp" + this.uuid; this._dialogInput = $( "
" ); this._dialogInput.on( "keydown", this._doKeyDown ); $( "body" ).append( this._dialogInput ); inst = this._dialogInst = this._newInst( this._dialogInput, false ); inst.settings = {}; $.data( this._dialogInput[ 0 ], "datepicker", inst ); } datepicker_extendRemove( inst.settings, settings || {} ); date = ( date && date.constructor === Date ? this._formatDate( inst, date ) : date ); this._dialogInput.val( date ); this._pos = ( pos ? ( pos.length ? pos : [ pos.pageX, pos.pageY ] ) : null ); if ( !this._pos ) { browserWidth = document.documentElement.clientWidth; browserHeight = document.documentElement.clientHeight; scrollX = document.documentElement.scrollLeft || document.body.scrollLeft; scrollY = document.documentElement.scrollTop || document.body.scrollTop; this._pos = // should use actual width/height below [ ( browserWidth / 2 ) - 100 + scrollX, ( browserHeight / 2 ) - 150 + scrollY ]; } // Move input on screen for focus, but hidden behind dialog this._dialogInput.css( "left", ( this._pos[ 0 ] + 20 ) + "px" ).css( "top", this._pos[ 1 ] + "px" ); inst.settings.onSelect = onSelect; this._inDialog = true; this.dpDiv.addClass( this._dialogClass ); this._showDatepicker( this._dialogInput[ 0 ] ); if ( $.blockUI ) { $.blockUI( this.dpDiv ); } $.data( this._dialogInput[ 0 ], "datepicker", inst ); return this; }, /* Detach a datepicker from its control. * @param target element - the target input field or division or span */ _destroyDatepicker: function( target ) { var nodeName, $target = $( target ), inst = $.data( target, "datepicker" ); if ( !$target.hasClass( this.markerClassName ) ) { return; } nodeName = target.nodeName.toLowerCase(); $.removeData( target, "datepicker" ); if ( nodeName === "input" ) { inst.append.remove(); inst.trigger.remove(); $target.removeClass( this.markerClassName ). off( "focus", this._showDatepicker ). off( "keydown", this._doKeyDown ). off( "keypress", this._doKeyPress ). off( "keyup", this._doKeyUp ); } else if ( nodeName === "div" || nodeName === "span" ) { $target.removeClass( this.markerClassName ).empty(); } if ( datepicker_instActive === inst ) { datepicker_instActive = null; } }, /* Enable the date picker to a jQuery selection. * @param target element - the target input field or division or span */ _enableDatepicker: function( target ) { var nodeName, inline, $target = $( target ), inst = $.data( target, "datepicker" ); if ( !$target.hasClass( this.markerClassName ) ) { return; } nodeName = target.nodeName.toLowerCase(); if ( nodeName === "input" ) { target.disabled = false; inst.trigger.filter( "button" ). each( function() { this.disabled = false; } ).end(). filter( "img" ).css( { opacity: "1.0", cursor: "" } ); } else if ( nodeName === "div" || nodeName === "span" ) { inline = $target.children( "." + this._inlineClass ); inline.children().removeClass( "ui-state-disabled" ); inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ). prop( "disabled", false ); } this._disabledInputs = $.map( this._disabledInputs, function( value ) { return ( value === target ? null : value ); } ); // delete entry }, /* Disable the date picker to a jQuery selection. * @param target element - the target input field or division or span */ _disableDatepicker: function( target ) { var nodeName, inline, $target = $( target ), inst = $.data( target, "datepicker" ); if ( !$target.hasClass( this.markerClassName ) ) { return; } nodeName = target.nodeName.toLowerCase(); if ( nodeName === "input" ) { target.disabled = true; inst.trigger.filter( "button" ). each( function() { this.disabled = true; } ).end(). filter( "img" ).css( { opacity: "0.5", cursor: "default" } ); } else if ( nodeName === "div" || nodeName === "span" ) { inline = $target.children( "." + this._inlineClass ); inline.children().addClass( "ui-state-disabled" ); inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ). prop( "disabled", true ); } this._disabledInputs = $.map( this._disabledInputs, function( value ) { return ( value === target ? null : value ); } ); // delete entry this._disabledInputs[ this._disabledInputs.length ] = target; }, /* Is the first field in a jQuery collection disabled as a datepicker? * @param target element - the target input field or division or span * @return boolean - true if disabled, false if enabled */ _isDisabledDatepicker: function( target ) { if ( !target ) { return false; } for ( var i = 0; i < this._disabledInputs.length; i++ ) { if ( this._disabledInputs[ i ] === target ) { return true; } } return false; }, /* Retrieve the instance data for the target control. * @param target element - the target input field or division or span * @return object - the associated instance data * @throws error if a jQuery problem getting data */ _getInst: function( target ) { try { return $.data( target, "datepicker" ); } catch ( err ) { throw "Missing instance data for this datepicker"; } }, /* Update or retrieve the settings for a date picker attached to an input field or division. * @param target element - the target input field or division or span * @param name object - the new settings to update or * string - the name of the setting to change or retrieve, * when retrieving also "all" for all instance settings or * "defaults" for all global defaults * @param value any - the new value for the setting * (omit if above is an object or to retrieve a value) */ _optionDatepicker: function( target, name, value ) { var settings, date, minDate, maxDate, inst = this._getInst( target ); if ( arguments.length === 2 && typeof name === "string" ) { return ( name === "defaults" ? $.extend( {}, $.datepicker._defaults ) : ( inst ? ( name === "all" ? $.extend( {}, inst.settings ) : this._get( inst, name ) ) : null ) ); } settings = name || {}; if ( typeof name === "string" ) { settings = {}; settings[ name ] = value; } if ( inst ) { if ( this._curInst === inst ) { this._hideDatepicker(); } date = this._getDateDatepicker( target, true ); minDate = this._getMinMaxDate( inst, "min" ); maxDate = this._getMinMaxDate( inst, "max" ); datepicker_extendRemove( inst.settings, settings ); // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided if ( minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined ) { inst.settings.minDate = this._formatDate( inst, minDate ); } if ( maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined ) { inst.settings.maxDate = this._formatDate( inst, maxDate ); } if ( "disabled" in settings ) { if ( settings.disabled ) { this._disableDatepicker( target ); } else { this._enableDatepicker( target ); } } this._attachments( $( target ), inst ); this._autoSize( inst ); this._setDate( inst, date ); this._updateAlternate( inst ); this._updateDatepicker( inst ); } }, // Change method deprecated _changeDatepicker: function( target, name, value ) { this._optionDatepicker( target, name, value ); }, /* Redraw the date picker attached to an input field or division. * @param target element - the target input field or division or span */ _refreshDatepicker: function( target ) { var inst = this._getInst( target ); if ( inst ) { this._updateDatepicker( inst ); } }, /* Set the dates for a jQuery selection. * @param target element - the target input field or division or span * @param date Date - the new date */ _setDateDatepicker: function( target, date ) { var inst = this._getInst( target ); if ( inst ) { this._setDate( inst, date ); this._updateDatepicker( inst ); this._updateAlternate( inst ); } }, /* Get the date(s) for the first entry in a jQuery selection. * @param target element - the target input field or division or span * @param noDefault boolean - true if no default date is to be used * @return Date - the current date */ _getDateDatepicker: function( target, noDefault ) { var inst = this._getInst( target ); if ( inst && !inst.inline ) { this._setDateFromField( inst, noDefault ); } return ( inst ? this._getDate( inst ) : null ); }, /* Handle keystrokes. */ _doKeyDown: function( event ) { var onSelect, dateStr, sel, inst = $.datepicker._getInst( event.target ), handled = true, isRTL = inst.dpDiv.is( ".ui-datepicker-rtl" ); inst._keyEvent = true; if ( $.datepicker._datepickerShowing ) { switch ( event.keyCode ) { case 9: $.datepicker._hideDatepicker(); handled = false; break; // hide on tab out case 13: sel = $( "td." + $.datepicker._dayOverClass + ":not(." + $.datepicker._currentClass + ")", inst.dpDiv ); if ( sel[ 0 ] ) { $.datepicker._selectDay( event.target, inst.selectedMonth, inst.selectedYear, sel[ 0 ] ); } onSelect = $.datepicker._get( inst, "onSelect" ); if ( onSelect ) { dateStr = $.datepicker._formatDate( inst ); // Trigger custom callback onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] ); } else { $.datepicker._hideDatepicker(); } return false; // don't submit the form case 27: $.datepicker._hideDatepicker(); break; // hide on escape case 33: $.datepicker._adjustDate( event.target, ( event.ctrlKey ? -$.datepicker._get( inst, "stepBigMonths" ) : -$.datepicker._get( inst, "stepMonths" ) ), "M" ); break; // previous month/year on page up/+ ctrl case 34: $.datepicker._adjustDate( event.target, ( event.ctrlKey ? +$.datepicker._get( inst, "stepBigMonths" ) : +$.datepicker._get( inst, "stepMonths" ) ), "M" ); break; // next month/year on page down/+ ctrl case 35: if ( event.ctrlKey || event.metaKey ) { $.datepicker._clearDate( event.target ); } handled = event.ctrlKey || event.metaKey; break; // clear on ctrl or command +end case 36: if ( event.ctrlKey || event.metaKey ) { $.datepicker._gotoToday( event.target ); } handled = event.ctrlKey || event.metaKey; break; // current on ctrl or command +home case 37: if ( event.ctrlKey || event.metaKey ) { $.datepicker._adjustDate( event.target, ( isRTL ? +1 : -1 ), "D" ); } handled = event.ctrlKey || event.metaKey; // -1 day on ctrl or command +left if ( event.originalEvent.altKey ) { $.datepicker._adjustDate( event.target, ( event.ctrlKey ? -$.datepicker._get( inst, "stepBigMonths" ) : -$.datepicker._get( inst, "stepMonths" ) ), "M" ); } // next month/year on alt +left on Mac break; case 38: if ( event.ctrlKey || event.metaKey ) { $.datepicker._adjustDate( event.target, -7, "D" ); } handled = event.ctrlKey || event.metaKey; break; // -1 week on ctrl or command +up case 39: if ( event.ctrlKey || event.metaKey ) { $.datepicker._adjustDate( event.target, ( isRTL ? -1 : +1 ), "D" ); } handled = event.ctrlKey || event.metaKey; // +1 day on ctrl or command +right if ( event.originalEvent.altKey ) { $.datepicker._adjustDate( event.target, ( event.ctrlKey ? +$.datepicker._get( inst, "stepBigMonths" ) : +$.datepicker._get( inst, "stepMonths" ) ), "M" ); } // next month/year on alt +right break; case 40: if ( event.ctrlKey || event.metaKey ) { $.datepicker._adjustDate( event.target, +7, "D" ); } handled = event.ctrlKey || event.metaKey; break; // +1 week on ctrl or command +down default: handled = false; } } else if ( event.keyCode === 36 && event.ctrlKey ) { // display the date picker on ctrl+home $.datepicker._showDatepicker( this ); } else { handled = false; } if ( handled ) { event.preventDefault(); event.stopPropagation(); } }, /* Filter entered characters - based on date format. */ _doKeyPress: function( event ) { var chars, chr, inst = $.datepicker._getInst( event.target ); if ( $.datepicker._get( inst, "constrainInput" ) ) { chars = $.datepicker._possibleChars( $.datepicker._get( inst, "dateFormat" ) ); chr = String.fromCharCode( event.charCode == null ? event.keyCode : event.charCode ); return event.ctrlKey || event.metaKey || ( chr < " " || !chars || chars.indexOf( chr ) > -1 ); } }, /* Synchronise manual entry and field/alternate field. */ _doKeyUp: function( event ) { var date, inst = $.datepicker._getInst( event.target ); if ( inst.input.val() !== inst.lastVal ) { try { date = $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ), ( inst.input ? inst.input.val() : null ), $.datepicker._getFormatConfig( inst ) ); if ( date ) { // only if valid $.datepicker._setDateFromField( inst ); $.datepicker._updateAlternate( inst ); $.datepicker._updateDatepicker( inst ); } } catch ( err ) { } } return true; }, /* Pop-up the date picker for a given input field. * If false returned from beforeShow event handler do not show. * @param input element - the input field attached to the date picker or * event - if triggered by focus */ _showDatepicker: function( input ) { input = input.target || input; if ( input.nodeName.toLowerCase() !== "input" ) { // find from button/image trigger input = $( "input", input.parentNode )[ 0 ]; } if ( $.datepicker._isDisabledDatepicker( input ) || $.datepicker._lastInput === input ) { // already here return; } var inst, beforeShow, beforeShowSettings, isFixed, offset, showAnim, duration; inst = $.datepicker._getInst( input ); if ( $.datepicker._curInst && $.datepicker._curInst !== inst ) { $.datepicker._curInst.dpDiv.stop( true, true ); if ( inst && $.datepicker._datepickerShowing ) { $.datepicker._hideDatepicker( $.datepicker._curInst.input[ 0 ] ); } } beforeShow = $.datepicker._get( inst, "beforeShow" ); beforeShowSettings = beforeShow ? beforeShow.apply( input, [ input, inst ] ) : {}; if ( beforeShowSettings === false ) { return; } datepicker_extendRemove( inst.settings, beforeShowSettings ); inst.lastVal = null; $.datepicker._lastInput = input; $.datepicker._setDateFromField( inst ); if ( $.datepicker._inDialog ) { // hide cursor input.value = ""; } if ( !$.datepicker._pos ) { // position below input $.datepicker._pos = $.datepicker._findPos( input ); $.datepicker._pos[ 1 ] += input.offsetHeight; // add the height } isFixed = false; $( input ).parents().each( function() { isFixed |= $( this ).css( "position" ) === "fixed"; return !isFixed; } ); offset = { left: $.datepicker._pos[ 0 ], top: $.datepicker._pos[ 1 ] }; $.datepicker._pos = null; //to avoid flashes on Firefox inst.dpDiv.empty(); // determine sizing offscreen inst.dpDiv.css( { position: "absolute", display: "block", top: "-1000px" } ); $.datepicker._updateDatepicker( inst ); // fix width for dynamic number of date pickers // and adjust position before showing offset = $.datepicker._checkOffset( inst, offset, isFixed ); inst.dpDiv.css( { position: ( $.datepicker._inDialog && $.blockUI ? "static" : ( isFixed ? "fixed" : "absolute" ) ), display: "none", left: offset.left + "px", top: offset.top + "px" } ); if ( !inst.inline ) { showAnim = $.datepicker._get( inst, "showAnim" ); duration = $.datepicker._get( inst, "duration" ); inst.dpDiv.css( "z-index", datepicker_getZindex( $( input ) ) + 1 ); $.datepicker._datepickerShowing = true; if ( $.effects && $.effects.effect[ showAnim ] ) { inst.dpDiv.show( showAnim, $.datepicker._get( inst, "showOptions" ), duration ); } else { inst.dpDiv[ showAnim || "show" ]( showAnim ? duration : null ); } if ( $.datepicker._shouldFocusInput( inst ) ) { inst.input.trigger( "focus" ); } $.datepicker._curInst = inst; } }, /* Generate the date picker content. */ _updateDatepicker: function( inst ) { this.maxRows = 4; //Reset the max number of rows being displayed (see #7043) datepicker_instActive = inst; // for delegate hover events inst.dpDiv.empty().append( this._generateHTML( inst ) ); this._attachHandlers( inst ); var origyearshtml, numMonths = this._getNumberOfMonths( inst ), cols = numMonths[ 1 ], width = 17, activeCell = inst.dpDiv.find( "." + this._dayOverClass + " a" ); if ( activeCell.length > 0 ) { datepicker_handleMouseover.apply( activeCell.get( 0 ) ); } inst.dpDiv.removeClass( "ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4" ).width( "" ); if ( cols > 1 ) { inst.dpDiv.addClass( "ui-datepicker-multi-" + cols ).css( "width", ( width * cols ) + "em" ); } inst.dpDiv[ ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ? "add" : "remove" ) + "Class" ]( "ui-datepicker-multi" ); inst.dpDiv[ ( this._get( inst, "isRTL" ) ? "add" : "remove" ) + "Class" ]( "ui-datepicker-rtl" ); if ( inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) { inst.input.trigger( "focus" ); } // Deffered render of the years select (to avoid flashes on Firefox) if ( inst.yearshtml ) { origyearshtml = inst.yearshtml; setTimeout( function() { //assure that inst.yearshtml didn't change. if ( origyearshtml === inst.yearshtml && inst.yearshtml ) { inst.dpDiv.find( "select.ui-datepicker-year:first" ).replaceWith( inst.yearshtml ); } origyearshtml = inst.yearshtml = null; }, 0 ); } }, // #6694 - don't focus the input if it's already focused // this breaks the change event in IE // Support: IE and jQuery <1.9 _shouldFocusInput: function( inst ) { return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" ); }, /* Check positioning to remain on screen. */ _checkOffset: function( inst, offset, isFixed ) { var dpWidth = inst.dpDiv.outerWidth(), dpHeight = inst.dpDiv.outerHeight(), inputWidth = inst.input ? inst.input.outerWidth() : 0, inputHeight = inst.input ? inst.input.outerHeight() : 0, viewWidth = document.documentElement.clientWidth + ( isFixed ? 0 : $( document ).scrollLeft() ), viewHeight = document.documentElement.clientHeight + ( isFixed ? 0 : $( document ).scrollTop() ); offset.left -= ( this._get( inst, "isRTL" ) ? ( dpWidth - inputWidth ) : 0 ); offset.left -= ( isFixed && offset.left === inst.input.offset().left ) ? $( document ).scrollLeft() : 0; offset.top -= ( isFixed && offset.top === ( inst.input.offset().top + inputHeight ) ) ? $( document ).scrollTop() : 0; // Now check if datepicker is showing outside window viewport - move to a better place if so. offset.left -= Math.min( offset.left, ( offset.left + dpWidth > viewWidth && viewWidth > dpWidth ) ? Math.abs( offset.left + dpWidth - viewWidth ) : 0 ); offset.top -= Math.min( offset.top, ( offset.top + dpHeight > viewHeight && viewHeight > dpHeight ) ? Math.abs( dpHeight + inputHeight ) : 0 ); return offset; }, /* Find an object's position on the screen. */ _findPos: function( obj ) { var position, inst = this._getInst( obj ), isRTL = this._get( inst, "isRTL" ); while ( obj && ( obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden( obj ) ) ) { obj = obj[ isRTL ? "previousSibling" : "nextSibling" ]; } position = $( obj ).offset(); return [ position.left, position.top ]; }, /* Hide the date picker from view. * @param input element - the input field attached to the date picker */ _hideDatepicker: function( input ) { var showAnim, duration, postProcess, onClose, inst = this._curInst; if ( !inst || ( input && inst !== $.data( input, "datepicker" ) ) ) { return; } if ( this._datepickerShowing ) { showAnim = this._get( inst, "showAnim" ); duration = this._get( inst, "duration" ); postProcess = function() { $.datepicker._tidyDialog( inst ); }; // DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) { inst.dpDiv.hide( showAnim, $.datepicker._get( inst, "showOptions" ), duration, postProcess ); } else { inst.dpDiv[ ( showAnim === "slideDown" ? "slideUp" : ( showAnim === "fadeIn" ? "fadeOut" : "hide" ) ) ]( ( showAnim ? duration : null ), postProcess ); } if ( !showAnim ) { postProcess(); } this._datepickerShowing = false; onClose = this._get( inst, "onClose" ); if ( onClose ) { onClose.apply( ( inst.input ? inst.input[ 0 ] : null ), [ ( inst.input ? inst.input.val() : "" ), inst ] ); } this._lastInput = null; if ( this._inDialog ) { this._dialogInput.css( { position: "absolute", left: "0", top: "-100px" } ); if ( $.blockUI ) { $.unblockUI(); $( "body" ).append( this.dpDiv ); } } this._inDialog = false; } }, /* Tidy up after a dialog display. */ _tidyDialog: function( inst ) { inst.dpDiv.removeClass( this._dialogClass ).off( ".ui-datepicker-calendar" ); }, /* Close date picker if clicked elsewhere. */ _checkExternalClick: function( event ) { if ( !$.datepicker._curInst ) { return; } var $target = $( event.target ), inst = $.datepicker._getInst( $target[ 0 ] ); if ( ( ( $target[ 0 ].id !== $.datepicker._mainDivId && $target.parents( "#" + $.datepicker._mainDivId ).length === 0 && !$target.hasClass( $.datepicker.markerClassName ) && !$target.closest( "." + $.datepicker._triggerClass ).length && $.datepicker._datepickerShowing && !( $.datepicker._inDialog && $.blockUI ) ) ) || ( $target.hasClass( $.datepicker.markerClassName ) && $.datepicker._curInst !== inst ) ) { $.datepicker._hideDatepicker(); } }, /* Adjust one of the date sub-fields. */ _adjustDate: function( id, offset, period ) { var target = $( id ), inst = this._getInst( target[ 0 ] ); if ( this._isDisabledDatepicker( target[ 0 ] ) ) { return; } this._adjustInstDate( inst, offset + ( period === "M" ? this._get( inst, "showCurrentAtPos" ) : 0 ), // undo positioning period ); this._updateDatepicker( inst ); }, /* Action for current link. */ _gotoToday: function( id ) { var date, target = $( id ), inst = this._getInst( target[ 0 ] ); if ( this._get( inst, "gotoCurrent" ) && inst.currentDay ) { inst.selectedDay = inst.currentDay; inst.drawMonth = inst.selectedMonth = inst.currentMonth; inst.drawYear = inst.selectedYear = inst.currentYear; } else { date = new Date(); inst.selectedDay = date.getDate(); inst.drawMonth = inst.selectedMonth = date.getMonth(); inst.drawYear = inst.selectedYear = date.getFullYear(); } this._notifyChange( inst ); this._adjustDate( target ); }, /* Action for selecting a new month/year. */ _selectMonthYear: function( id, select, period ) { var target = $( id ), inst = this._getInst( target[ 0 ] ); inst[ "selected" + ( period === "M" ? "Month" : "Year" ) ] = inst[ "draw" + ( period === "M" ? "Month" : "Year" ) ] = parseInt( select.options[ select.selectedIndex ].value, 10 ); this._notifyChange( inst ); this._adjustDate( target ); }, /* Action for selecting a day. */ _selectDay: function( id, month, year, td ) { var inst, target = $( id ); if ( $( td ).hasClass( this._unselectableClass ) || this._isDisabledDatepicker( target[ 0 ] ) ) { return; } inst = this._getInst( target[ 0 ] ); inst.selectedDay = inst.currentDay = $( "a", td ).html(); inst.selectedMonth = inst.currentMonth = month; inst.selectedYear = inst.currentYear = year; this._selectDate( id, this._formatDate( inst, inst.currentDay, inst.currentMonth, inst.currentYear ) ); }, /* Erase the input field and hide the date picker. */ _clearDate: function( id ) { var target = $( id ); this._selectDate( target, "" ); }, /* Update the input field with the selected date. */ _selectDate: function( id, dateStr ) { var onSelect, target = $( id ), inst = this._getInst( target[ 0 ] ); dateStr = ( dateStr != null ? dateStr : this._formatDate( inst ) ); if ( inst.input ) { inst.input.val( dateStr ); } this._updateAlternate( inst ); onSelect = this._get( inst, "onSelect" ); if ( onSelect ) { onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] ); // trigger custom callback } else if ( inst.input ) { inst.input.trigger( "change" ); // fire the change event } if ( inst.inline ) { this._updateDatepicker( inst ); } else { this._hideDatepicker(); this._lastInput = inst.input[ 0 ]; if ( typeof( inst.input[ 0 ] ) !== "object" ) { inst.input.trigger( "focus" ); // restore focus } this._lastInput = null; } }, /* Update any alternate field to synchronise with the main field. */ _updateAlternate: function( inst ) { var altFormat, date, dateStr, altField = this._get( inst, "altField" ); if ( altField ) { // update alternate field too altFormat = this._get( inst, "altFormat" ) || this._get( inst, "dateFormat" ); date = this._getDate( inst ); dateStr = this.formatDate( altFormat, date, this._getFormatConfig( inst ) ); $( altField ).val( dateStr ); } }, /* Set as beforeShowDay function to prevent selection of weekends. * @param date Date - the date to customise * @return [boolean, string] - is this date selectable?, what is its CSS class? */ noWeekends: function( date ) { var day = date.getDay(); return [ ( day > 0 && day < 6 ), "" ]; }, /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition. * @param date Date - the date to get the week for * @return number - the number of the week within the year that contains this date */ iso8601Week: function( date ) { var time, checkDate = new Date( date.getTime() ); // Find Thursday of this week starting on Monday checkDate.setDate( checkDate.getDate() + 4 - ( checkDate.getDay() || 7 ) ); time = checkDate.getTime(); checkDate.setMonth( 0 ); // Compare with Jan 1 checkDate.setDate( 1 ); return Math.floor( Math.round( ( time - checkDate ) / 86400000 ) / 7 ) + 1; }, /* Parse a string value into a date object. * See formatDate below for the possible formats. * * @param format string - the expected format of the date * @param value string - the date in the above format * @param settings Object - attributes include: * shortYearCutoff number - the cutoff year for determining the century (optional) * dayNamesShort string[7] - abbreviated names of the days from Sunday (optional) * dayNames string[7] - names of the days from Sunday (optional) * monthNamesShort string[12] - abbreviated names of the months (optional) * monthNames string[12] - names of the months (optional) * @return Date - the extracted date value or null if value is blank */ parseDate: function( format, value, settings ) { if ( format == null || value == null ) { throw "Invalid arguments"; } value = ( typeof value === "object" ? value.toString() : value + "" ); if ( value === "" ) { return null; } var iFormat, dim, extra, iValue = 0, shortYearCutoffTemp = ( settings ? settings.shortYearCutoff : null ) || this._defaults.shortYearCutoff, shortYearCutoff = ( typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp : new Date().getFullYear() % 100 + parseInt( shortYearCutoffTemp, 10 ) ), dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort, dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames, monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort, monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames, year = -1, month = -1, day = -1, doy = -1, literal = false, date, // Check whether a format character is doubled lookAhead = function( match ) { var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match ); if ( matches ) { iFormat++; } return matches; }, // Extract a number from the string value getNumber = function( match ) { var isDoubled = lookAhead( match ), size = ( match === "@" ? 14 : ( match === "!" ? 20 : ( match === "y" && isDoubled ? 4 : ( match === "o" ? 3 : 2 ) ) ) ), minSize = ( match === "y" ? size : 1 ), digits = new RegExp( "^\\d{" + minSize + "," + size + "}" ), num = value.substring( iValue ).match( digits ); if ( !num ) { throw "Missing number at position " + iValue; } iValue += num[ 0 ].length; return parseInt( num[ 0 ], 10 ); }, // Extract a name from the string value and convert to an index getName = function( match, shortNames, longNames ) { var index = -1, names = $.map( lookAhead( match ) ? longNames : shortNames, function( v, k ) { return [ [ k, v ] ]; } ).sort( function( a, b ) { return -( a[ 1 ].length - b[ 1 ].length ); } ); $.each( names, function( i, pair ) { var name = pair[ 1 ]; if ( value.substr( iValue, name.length ).toLowerCase() === name.toLowerCase() ) { index = pair[ 0 ]; iValue += name.length; return false; } } ); if ( index !== -1 ) { return index + 1; } else { throw "Unknown name at position " + iValue; } }, // Confirm that a literal character matches the string value checkLiteral = function() { if ( value.charAt( iValue ) !== format.charAt( iFormat ) ) { throw "Unexpected literal at position " + iValue; } iValue++; }; for ( iFormat = 0; iFormat < format.length; iFormat++ ) { if ( literal ) { if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) { literal = false; } else { checkLiteral(); } } else { switch ( format.charAt( iFormat ) ) { case "d": day = getNumber( "d" ); break; case "D": getName( "D", dayNamesShort, dayNames ); break; case "o": doy = getNumber( "o" ); break; case "m": month = getNumber( "m" ); break; case "M": month = getName( "M", monthNamesShort, monthNames ); break; case "y": year = getNumber( "y" ); break; case "@": date = new Date( getNumber( "@" ) ); year = date.getFullYear(); month = date.getMonth() + 1; day = date.getDate(); break; case "!": date = new Date( ( getNumber( "!" ) - this._ticksTo1970 ) / 10000 ); year = date.getFullYear(); month = date.getMonth() + 1; day = date.getDate(); break; case "'": if ( lookAhead( "'" ) ) { checkLiteral(); } else { literal = true; } break; default: checkLiteral(); } } } if ( iValue < value.length ) { extra = value.substr( iValue ); if ( !/^\s+/.test( extra ) ) { throw "Extra/unparsed characters found in date: " + extra; } } if ( year === -1 ) { year = new Date().getFullYear(); } else if ( year < 100 ) { year += new Date().getFullYear() - new Date().getFullYear() % 100 + ( year <= shortYearCutoff ? 0 : -100 ); } if ( doy > -1 ) { month = 1; day = doy; do { dim = this._getDaysInMonth( year, month - 1 ); if ( day <= dim ) { break; } month++; day -= dim; } while ( true ); } date = this._daylightSavingAdjust( new Date( year, month - 1, day ) ); if ( date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day ) { throw "Invalid date"; // E.g. 31/02/00 } return date; }, /* Standard date formats. */ ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601) COOKIE: "D, dd M yy", ISO_8601: "yy-mm-dd", RFC_822: "D, d M y", RFC_850: "DD, dd-M-y", RFC_1036: "D, d M y", RFC_1123: "D, d M yy", RFC_2822: "D, d M yy", RSS: "D, d M y", // RFC 822 TICKS: "!", TIMESTAMP: "@", W3C: "yy-mm-dd", // ISO 8601 _ticksTo1970: ( ( ( 1970 - 1 ) * 365 + Math.floor( 1970 / 4 ) - Math.floor( 1970 / 100 ) + Math.floor( 1970 / 400 ) ) * 24 * 60 * 60 * 10000000 ), /* Format a date object into a string value. * The format can be combinations of the following: * d - day of month (no leading zero) * dd - day of month (two digit) * o - day of year (no leading zeros) * oo - day of year (three digit) * D - day name short * DD - day name long * m - month of year (no leading zero) * mm - month of year (two digit) * M - month name short * MM - month name long * y - year (two digit) * yy - year (four digit) * @ - Unix timestamp (ms since 01/01/1970) * ! - Windows ticks (100ns since 01/01/0001) * "..." - literal text * '' - single quote * * @param format string - the desired format of the date * @param date Date - the date value to format * @param settings Object - attributes include: * dayNamesShort string[7] - abbreviated names of the days from Sunday (optional) * dayNames string[7] - names of the days from Sunday (optional) * monthNamesShort string[12] - abbreviated names of the months (optional) * monthNames string[12] - names of the months (optional) * @return string - the date in the above format */ formatDate: function( format, date, settings ) { if ( !date ) { return ""; } var iFormat, dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort, dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames, monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort, monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames, // Check whether a format character is doubled lookAhead = function( match ) { var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match ); if ( matches ) { iFormat++; } return matches; }, // Format a number, with leading zero if necessary formatNumber = function( match, value, len ) { var num = "" + value; if ( lookAhead( match ) ) { while ( num.length < len ) { num = "0" + num; } } return num; }, // Format a name, short or long as requested formatName = function( match, value, shortNames, longNames ) { return ( lookAhead( match ) ? longNames[ value ] : shortNames[ value ] ); }, output = "", literal = false; if ( date ) { for ( iFormat = 0; iFormat < format.length; iFormat++ ) { if ( literal ) { if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) { literal = false; } else { output += format.charAt( iFormat ); } } else { switch ( format.charAt( iFormat ) ) { case "d": output += formatNumber( "d", date.getDate(), 2 ); break; case "D": output += formatName( "D", date.getDay(), dayNamesShort, dayNames ); break; case "o": output += formatNumber( "o", Math.round( ( new Date( date.getFullYear(), date.getMonth(), date.getDate() ).getTime() - new Date( date.getFullYear(), 0, 0 ).getTime() ) / 86400000 ), 3 ); break; case "m": output += formatNumber( "m", date.getMonth() + 1, 2 ); break; case "M": output += formatName( "M", date.getMonth(), monthNamesShort, monthNames ); break; case "y": output += ( lookAhead( "y" ) ? date.getFullYear() : ( date.getFullYear() % 100 < 10 ? "0" : "" ) + date.getFullYear() % 100 ); break; case "@": output += date.getTime(); break; case "!": output += date.getTime() * 10000 + this._ticksTo1970; break; case "'": if ( lookAhead( "'" ) ) { output += "'"; } else { literal = true; } break; default: output += format.charAt( iFormat ); } } } } return output; }, /* Extract all possible characters from the date format. */ _possibleChars: function( format ) { var iFormat, chars = "", literal = false, // Check whether a format character is doubled lookAhead = function( match ) { var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match ); if ( matches ) { iFormat++; } return matches; }; for ( iFormat = 0; iFormat < format.length; iFormat++ ) { if ( literal ) { if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) { literal = false; } else { chars += format.charAt( iFormat ); } } else { switch ( format.charAt( iFormat ) ) { case "d": case "m": case "y": case "@": chars += "0123456789"; break; case "D": case "M": return null; // Accept anything case "'": if ( lookAhead( "'" ) ) { chars += "'"; } else { literal = true; } break; default: chars += format.charAt( iFormat ); } } } return chars; }, /* Get a setting value, defaulting if necessary. */ _get: function( inst, name ) { return inst.settings[ name ] !== undefined ? inst.settings[ name ] : this._defaults[ name ]; }, /* Parse existing date and initialise date picker. */ _setDateFromField: function( inst, noDefault ) { if ( inst.input.val() === inst.lastVal ) { return; } var dateFormat = this._get( inst, "dateFormat" ), dates = inst.lastVal = inst.input ? inst.input.val() : null, defaultDate = this._getDefaultDate( inst ), date = defaultDate, settings = this._getFormatConfig( inst ); try { date = this.parseDate( dateFormat, dates, settings ) || defaultDate; } catch ( event ) { dates = ( noDefault ? "" : dates ); } inst.selectedDay = date.getDate(); inst.drawMonth = inst.selectedMonth = date.getMonth(); inst.drawYear = inst.selectedYear = date.getFullYear(); inst.currentDay = ( dates ? date.getDate() : 0 ); inst.currentMonth = ( dates ? date.getMonth() : 0 ); inst.currentYear = ( dates ? date.getFullYear() : 0 ); this._adjustInstDate( inst ); }, /* Retrieve the default date shown on opening. */ _getDefaultDate: function( inst ) { return this._restrictMinMax( inst, this._determineDate( inst, this._get( inst, "defaultDate" ), new Date() ) ); }, /* A date may be specified as an exact value or a relative one. */ _determineDate: function( inst, date, defaultDate ) { var offsetNumeric = function( offset ) { var date = new Date(); date.setDate( date.getDate() + offset ); return date; }, offsetString = function( offset ) { try { return $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ), offset, $.datepicker._getFormatConfig( inst ) ); } catch ( e ) { // Ignore } var date = ( offset.toLowerCase().match( /^c/ ) ? $.datepicker._getDate( inst ) : null ) || new Date(), year = date.getFullYear(), month = date.getMonth(), day = date.getDate(), pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, matches = pattern.exec( offset ); while ( matches ) { switch ( matches[ 2 ] || "d" ) { case "d" : case "D" : day += parseInt( matches[ 1 ], 10 ); break; case "w" : case "W" : day += parseInt( matches[ 1 ], 10 ) * 7; break; case "m" : case "M" : month += parseInt( matches[ 1 ], 10 ); day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) ); break; case "y": case "Y" : year += parseInt( matches[ 1 ], 10 ); day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) ); break; } matches = pattern.exec( offset ); } return new Date( year, month, day ); }, newDate = ( date == null || date === "" ? defaultDate : ( typeof date === "string" ? offsetString( date ) : ( typeof date === "number" ? ( isNaN( date ) ? defaultDate : offsetNumeric( date ) ) : new Date( date.getTime() ) ) ) ); newDate = ( newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate ); if ( newDate ) { newDate.setHours( 0 ); newDate.setMinutes( 0 ); newDate.setSeconds( 0 ); newDate.setMilliseconds( 0 ); } return this._daylightSavingAdjust( newDate ); }, /* Handle switch to/from daylight saving. * Hours may be non-zero on daylight saving cut-over: * > 12 when midnight changeover, but then cannot generate * midnight datetime, so jump to 1AM, otherwise reset. * @param date (Date) the date to check * @return (Date) the corrected date */ _daylightSavingAdjust: function( date ) { if ( !date ) { return null; } date.setHours( date.getHours() > 12 ? date.getHours() + 2 : 0 ); return date; }, /* Set the date(s) directly. */ _setDate: function( inst, date, noChange ) { var clear = !date, origMonth = inst.selectedMonth, origYear = inst.selectedYear, newDate = this._restrictMinMax( inst, this._determineDate( inst, date, new Date() ) ); inst.selectedDay = inst.currentDay = newDate.getDate(); inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth(); inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear(); if ( ( origMonth !== inst.selectedMonth || origYear !== inst.selectedYear ) && !noChange ) { this._notifyChange( inst ); } this._adjustInstDate( inst ); if ( inst.input ) { inst.input.val( clear ? "" : this._formatDate( inst ) ); } }, /* Retrieve the date(s) directly. */ _getDate: function( inst ) { var startDate = ( !inst.currentYear || ( inst.input && inst.input.val() === "" ) ? null : this._daylightSavingAdjust( new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) ); return startDate; }, /* Attach the onxxx handlers. These are declared statically so * they work with static code transformers like Caja. */ _attachHandlers: function( inst ) { var stepMonths = this._get( inst, "stepMonths" ), id = "#" + inst.id.replace( /\\\\/g, "\\" ); inst.dpDiv.find( "[data-handler]" ).map( function() { var handler = { prev: function() { $.datepicker._adjustDate( id, -stepMonths, "M" ); }, next: function() { $.datepicker._adjustDate( id, +stepMonths, "M" ); }, hide: function() { $.datepicker._hideDatepicker(); }, today: function() { $.datepicker._gotoToday( id ); }, selectDay: function() { $.datepicker._selectDay( id, +this.getAttribute( "data-month" ), +this.getAttribute( "data-year" ), this ); return false; }, selectMonth: function() { $.datepicker._selectMonthYear( id, this, "M" ); return false; }, selectYear: function() { $.datepicker._selectMonthYear( id, this, "Y" ); return false; } }; $( this ).on( this.getAttribute( "data-event" ), handler[ this.getAttribute( "data-handler" ) ] ); } ); }, /* Generate the HTML for the current state of the date picker. */ _generateHTML: function( inst ) { var maxDraw, prevText, prev, nextText, next, currentText, gotoDate, controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin, monthNames, monthNamesShort, beforeShowDay, showOtherMonths, selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate, cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows, printDate, dRow, tbody, daySettings, otherMonth, unselectable, tempDate = new Date(), today = this._daylightSavingAdjust( new Date( tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate() ) ), // clear time isRTL = this._get( inst, "isRTL" ), showButtonPanel = this._get( inst, "showButtonPanel" ), hideIfNoPrevNext = this._get( inst, "hideIfNoPrevNext" ), navigationAsDateFormat = this._get( inst, "navigationAsDateFormat" ), numMonths = this._getNumberOfMonths( inst ), showCurrentAtPos = this._get( inst, "showCurrentAtPos" ), stepMonths = this._get( inst, "stepMonths" ), isMultiMonth = ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ), currentDate = this._daylightSavingAdjust( ( !inst.currentDay ? new Date( 9999, 9, 9 ) : new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) ), minDate = this._getMinMaxDate( inst, "min" ), maxDate = this._getMinMaxDate( inst, "max" ), drawMonth = inst.drawMonth - showCurrentAtPos, drawYear = inst.drawYear; if ( drawMonth < 0 ) { drawMonth += 12; drawYear--; } if ( maxDate ) { maxDraw = this._daylightSavingAdjust( new Date( maxDate.getFullYear(), maxDate.getMonth() - ( numMonths[ 0 ] * numMonths[ 1 ] ) + 1, maxDate.getDate() ) ); maxDraw = ( minDate && maxDraw < minDate ? minDate : maxDraw ); while ( this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 ) ) > maxDraw ) { drawMonth--; if ( drawMonth < 0 ) { drawMonth = 11; drawYear--; } } } inst.drawMonth = drawMonth; inst.drawYear = drawYear; prevText = this._get( inst, "prevText" ); prevText = ( !navigationAsDateFormat ? prevText : this.formatDate( prevText, this._daylightSavingAdjust( new Date( drawYear, drawMonth - stepMonths, 1 ) ), this._getFormatConfig( inst ) ) ); prev = ( this._canAdjustMonth( inst, -1, drawYear, drawMonth ) ? "" + prevText + "" : ( hideIfNoPrevNext ? "" : "" + prevText + "" ) ); nextText = this._get( inst, "nextText" ); nextText = ( !navigationAsDateFormat ? nextText : this.formatDate( nextText, this._daylightSavingAdjust( new Date( drawYear, drawMonth + stepMonths, 1 ) ), this._getFormatConfig( inst ) ) ); next = ( this._canAdjustMonth( inst, +1, drawYear, drawMonth ) ? "" + nextText + "" : ( hideIfNoPrevNext ? "" : "" + nextText + "" ) ); currentText = this._get( inst, "currentText" ); gotoDate = ( this._get( inst, "gotoCurrent" ) && inst.currentDay ? currentDate : today ); currentText = ( !navigationAsDateFormat ? currentText : this.formatDate( currentText, gotoDate, this._getFormatConfig( inst ) ) ); controls = ( !inst.inline ? "" + this._get( inst, "closeText" ) + "" : "" ); buttonPanel = ( showButtonPanel ) ? "
" + ( isRTL ? controls : "" ) + ( this._isInRange( inst, gotoDate ) ? "" + currentText + "" : "" ) + ( isRTL ? "" : controls ) + "
" : ""; firstDay = parseInt( this._get( inst, "firstDay" ), 10 ); firstDay = ( isNaN( firstDay ) ? 0 : firstDay ); showWeek = this._get( inst, "showWeek" ); dayNames = this._get( inst, "dayNames" ); dayNamesMin = this._get( inst, "dayNamesMin" ); monthNames = this._get( inst, "monthNames" ); monthNamesShort = this._get( inst, "monthNamesShort" ); beforeShowDay = this._get( inst, "beforeShowDay" ); showOtherMonths = this._get( inst, "showOtherMonths" ); selectOtherMonths = this._get( inst, "selectOtherMonths" ); defaultDate = this._getDefaultDate( inst ); html = ""; for ( row = 0; row < numMonths[ 0 ]; row++ ) { group = ""; this.maxRows = 4; for ( col = 0; col < numMonths[ 1 ]; col++ ) { selectedDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, inst.selectedDay ) ); cornerClass = " ui-corner-all"; calender = ""; if ( isMultiMonth ) { calender += "
"; } calender += "
" + ( /all|left/.test( cornerClass ) && row === 0 ? ( isRTL ? next : prev ) : "" ) + ( /all|right/.test( cornerClass ) && row === 0 ? ( isRTL ? prev : next ) : "" ) + this._generateMonthYearHeader( inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort ) + // draw month headers "
" + ""; thead = ( showWeek ? "" : "" ); for ( dow = 0; dow < 7; dow++ ) { // days of the week day = ( dow + firstDay ) % 7; thead += ""; } calender += thead + ""; daysInMonth = this._getDaysInMonth( drawYear, drawMonth ); if ( drawYear === inst.selectedYear && drawMonth === inst.selectedMonth ) { inst.selectedDay = Math.min( inst.selectedDay, daysInMonth ); } leadDays = ( this._getFirstDayOfMonth( drawYear, drawMonth ) - firstDay + 7 ) % 7; curRows = Math.ceil( ( leadDays + daysInMonth ) / 7 ); // calculate the number of rows to generate numRows = ( isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows ); //If multiple months, use the higher number of rows (see #7043) this.maxRows = numRows; printDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 - leadDays ) ); for ( dRow = 0; dRow < numRows; dRow++ ) { // create date picker rows calender += ""; tbody = ( !showWeek ? "" : "" ); for ( dow = 0; dow < 7; dow++ ) { // create date picker days daySettings = ( beforeShowDay ? beforeShowDay.apply( ( inst.input ? inst.input[ 0 ] : null ), [ printDate ] ) : [ true, "" ] ); otherMonth = ( printDate.getMonth() !== drawMonth ); unselectable = ( otherMonth && !selectOtherMonths ) || !daySettings[ 0 ] || ( minDate && printDate < minDate ) || ( maxDate && printDate > maxDate ); tbody += ""; // display selectable date printDate.setDate( printDate.getDate() + 1 ); printDate = this._daylightSavingAdjust( printDate ); } calender += tbody + ""; } drawMonth++; if ( drawMonth > 11 ) { drawMonth = 0; drawYear++; } calender += "
" + this._get( inst, "weekHeader" ) + "	= 5 ? " class='ui-datepicker-week-end'" : "" ) + ">" + "" + dayNamesMin[ day ] + "
" + this._get( inst, "calculateWeek" )( printDate ) + "	" + // actions ( otherMonth && !showOtherMonths ? " " : // display for other months ( unselectable ? "" + printDate.getDate() + "" : "" + printDate.getDate() + "" ) ) + "
" + ( isMultiMonth ? "
" + ( ( numMonths[ 0 ] > 0 && col === numMonths[ 1 ] - 1 ) ? "
" : "" ) : "" ); group += calender; } html += group; } html += buttonPanel; inst._keyEvent = false; return html; }, /* Generate the month and year header. */ _generateMonthYearHeader: function( inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort ) { var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear, changeMonth = this._get( inst, "changeMonth" ), changeYear = this._get( inst, "changeYear" ), showMonthAfterYear = this._get( inst, "showMonthAfterYear" ), html = "
", monthHtml = ""; // Month selection if ( secondary || !changeMonth ) { monthHtml += "" + monthNames[ drawMonth ] + ""; } else { inMinYear = ( minDate && minDate.getFullYear() === drawYear ); inMaxYear = ( maxDate && maxDate.getFullYear() === drawYear ); monthHtml += "
" + monthNamesShort[ month ] + "
"; } if ( !showMonthAfterYear ) { html += monthHtml + ( secondary || !( changeMonth && changeYear ) ? " " : "" ); } // Year selection if ( !inst.yearshtml ) { inst.yearshtml = ""; if ( secondary || !changeYear ) { html += "" + drawYear + ""; } else { // determine range of years to display years = this._get( inst, "yearRange" ).split( ":" ); thisYear = new Date().getFullYear(); determineYear = function( value ) { var year = ( value.match( /c[+\-].*/ ) ? drawYear + parseInt( value.substring( 1 ), 10 ) : ( value.match( /[+\-].*/ ) ? thisYear + parseInt( value, 10 ) : parseInt( value, 10 ) ) ); return ( isNaN( year ) ? thisYear : year ); }; year = determineYear( years[ 0 ] ); endYear = Math.max( year, determineYear( years[ 1 ] || "" ) ); year = ( minDate ? Math.max( year, minDate.getFullYear() ) : year ); endYear = ( maxDate ? Math.min( endYear, maxDate.getFullYear() ) : endYear ); inst.yearshtml += "
" + year + "
"; html += inst.yearshtml; inst.yearshtml = null; } } html += this._get( inst, "yearSuffix" ); if ( showMonthAfterYear ) { html += ( secondary || !( changeMonth && changeYear ) ? " " : "" ) + monthHtml; } html += "
"; // Close datepicker_header return html; }, /* Adjust one of the date sub-fields. */ _adjustInstDate: function( inst, offset, period ) { var year = inst.selectedYear + ( period === "Y" ? offset : 0 ), month = inst.selectedMonth + ( period === "M" ? offset : 0 ), day = Math.min( inst.selectedDay, this._getDaysInMonth( year, month ) ) + ( period === "D" ? offset : 0 ), date = this._restrictMinMax( inst, this._daylightSavingAdjust( new Date( year, month, day ) ) ); inst.selectedDay = date.getDate(); inst.drawMonth = inst.selectedMonth = date.getMonth(); inst.drawYear = inst.selectedYear = date.getFullYear(); if ( period === "M" || period === "Y" ) { this._notifyChange( inst ); } }, /* Ensure a date is within any min/max bounds. */ _restrictMinMax: function( inst, date ) { var minDate = this._getMinMaxDate( inst, "min" ), maxDate = this._getMinMaxDate( inst, "max" ), newDate = ( minDate && date < minDate ? minDate : date ); return ( maxDate && newDate > maxDate ? maxDate : newDate ); }, /* Notify change of month/year. */ _notifyChange: function( inst ) { var onchange = this._get( inst, "onchangeMonthYear" ); if ( onchange ) { onchange.apply( ( inst.input ? inst.input[ 0 ] : null ), [ inst.selectedYear, inst.selectedMonth + 1, inst ] ); } }, /* Determine the number of months to show. */ _getNumberOfMonths: function( inst ) { var numMonths = this._get( inst, "numberOfMonths" ); return ( numMonths == null ? [ 1, 1 ] : ( typeof numMonths === "number" ? [ 1, numMonths ] : numMonths ) ); }, /* Determine the current maximum date - ensure no time components are set. */ _getMinMaxDate: function( inst, minMax ) { return this._determineDate( inst, this._get( inst, minMax + "Date" ), null ); }, /* Find the number of days in a given month. */ _getDaysInMonth: function( year, month ) { return 32 - this._daylightSavingAdjust( new Date( year, month, 32 ) ).getDate(); }, /* Find the day of the week of the first of a month. */ _getFirstDayOfMonth: function( year, month ) { return new Date( year, month, 1 ).getDay(); }, /* Determines if we should allow a "next/prev" month display change. */ _canAdjustMonth: function( inst, offset, curYear, curMonth ) { var numMonths = this._getNumberOfMonths( inst ), date = this._daylightSavingAdjust( new Date( curYear, curMonth + ( offset < 0 ? offset : numMonths[ 0 ] * numMonths[ 1 ] ), 1 ) ); if ( offset < 0 ) { date.setDate( this._getDaysInMonth( date.getFullYear(), date.getMonth() ) ); } return this._isInRange( inst, date ); }, /* Is the given date in the accepted range? */ _isInRange: function( inst, date ) { var yearSplit, currentYear, minDate = this._getMinMaxDate( inst, "min" ), maxDate = this._getMinMaxDate( inst, "max" ), minYear = null, maxYear = null, years = this._get( inst, "yearRange" ); if ( years ) { yearSplit = years.split( ":" ); currentYear = new Date().getFullYear(); minYear = parseInt( yearSplit[ 0 ], 10 ); maxYear = parseInt( yearSplit[ 1 ], 10 ); if ( yearSplit[ 0 ].match( /[+\-].*/ ) ) { minYear += currentYear; } if ( yearSplit[ 1 ].match( /[+\-].*/ ) ) { maxYear += currentYear; } } return ( ( !minDate || date.getTime() >= minDate.getTime() ) && ( !maxDate || date.getTime() <= maxDate.getTime() ) && ( !minYear || date.getFullYear() >= minYear ) && ( !maxYear || date.getFullYear() <= maxYear ) ); }, /* Provide the configuration settings for formatting/parsing. */ _getFormatConfig: function( inst ) { var shortYearCutoff = this._get( inst, "shortYearCutoff" ); shortYearCutoff = ( typeof shortYearCutoff !== "string" ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt( shortYearCutoff, 10 ) ); return { shortYearCutoff: shortYearCutoff, dayNamesShort: this._get( inst, "dayNamesShort" ), dayNames: this._get( inst, "dayNames" ), monthNamesShort: this._get( inst, "monthNamesShort" ), monthNames: this._get( inst, "monthNames" ) }; }, /* Format the given date for display. */ _formatDate: function( inst, day, month, year ) { if ( !day ) { inst.currentDay = inst.selectedDay; inst.currentMonth = inst.selectedMonth; inst.currentYear = inst.selectedYear; } var date = ( day ? ( typeof day === "object" ? day : this._daylightSavingAdjust( new Date( year, month, day ) ) ) : this._daylightSavingAdjust( new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) ); return this.formatDate( this._get( inst, "dateFormat" ), date, this._getFormatConfig( inst ) ); } } ); /* * Bind hover events for datepicker elements. * Done via delegate so the binding only occurs once in the lifetime of the parent div. * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker. */ function datepicker_bindHover( dpDiv ) { var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a"; return dpDiv.on( "mouseout", selector, function() { $( this ).removeClass( "ui-state-hover" ); if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) { $( this ).removeClass( "ui-datepicker-prev-hover" ); } if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) { $( this ).removeClass( "ui-datepicker-next-hover" ); } } ) .on( "mouseover", selector, datepicker_handleMouseover ); } function datepicker_handleMouseover() { if ( !$.datepicker._isDisabledDatepicker( datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[ 0 ] : datepicker_instActive.input[ 0 ] ) ) { $( this ).parents( ".ui-datepicker-calendar" ).find( "a" ).removeClass( "ui-state-hover" ); $( this ).addClass( "ui-state-hover" ); if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) { $( this ).addClass( "ui-datepicker-prev-hover" ); } if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) { $( this ).addClass( "ui-datepicker-next-hover" ); } } } /* jQuery extend now ignores nulls! */ function datepicker_extendRemove( target, props ) { $.extend( target, props ); for ( var name in props ) { if ( props[ name ] == null ) { target[ name ] = props[ name ]; } } return target; } /* Invoke the datepicker functionality. @param options string - a command, optionally followed by additional parameters or Object - settings for attaching new datepicker functionality @return jQuery object */ $.fn.datepicker = function( options ) { /* Verify an empty collection wasn't passed - Fixes #6976 */ if ( !this.length ) { return this; } /* Initialise the date picker. */ if ( !$.datepicker.initialized ) { $( document ).on( "mousedown", $.datepicker._checkExternalClick ); $.datepicker.initialized = true; } /* Append datepicker main container to body if not exist. */ if ( $( "#" + $.datepicker._mainDivId ).length === 0 ) { $( "body" ).append( $.datepicker.dpDiv ); } var otherArgs = Array.prototype.slice.call( arguments, 1 ); if ( typeof options === "string" && ( options === "isDisabled" || options === "getDate" || options === "widget" ) ) { return $.datepicker[ "_" + options + "Datepicker" ]. apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) ); } if ( options === "option" && arguments.length === 2 && typeof arguments[ 1 ] === "string" ) { return $.datepicker[ "_" + options + "Datepicker" ]. apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) ); } return this.each( function() { typeof options === "string" ? $.datepicker[ "_" + options + "Datepicker" ]. apply( $.datepicker, [ this ].concat( otherArgs ) ) : $.datepicker._attachDatepicker( this, options ); } ); }; $.datepicker = new Datepicker(); // singleton instance $.datepicker.initialized = false; $.datepicker.uuid = new Date().getTime(); $.datepicker.version = "1.12.1"; var widgetsDatepicker = $.datepicker; /*! * jQuery UI Tooltip 1.12.1 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license */ //>>label: Tooltip //>>group: Widgets //>>description: Shows additional information for any element on hover or focus. //>>docs: http://api.jqueryui.com/tooltip/ //>>demos: http://jqueryui.com/tooltip/ //>>css.structure: ../../themes/base/core.css //>>css.structure: ../../themes/base/tooltip.css //>>css.theme: ../../themes/base/theme.css $.widget( "ui.tooltip", { version: "1.12.1", options: { classes: { "ui-tooltip": "ui-corner-all ui-widget-shadow" }, content: function() { // support: IE<9, Opera in jQuery <1.7 // .text() can't accept undefined, so coerce to a string var title = $( this ).attr( "title" ) || ""; // Escape title, since we're going from an attribute to raw HTML return $( "" ).text( title ).html(); }, hide: true, // Disabled elements have inconsistent behavior across browsers (#8661) items: "[title]:not([disabled])", position: { my: "left top+15", at: "left bottom", collision: "flipfit flip" }, show: true, track: false, // Callbacks close: null, open: null }, _addDescribedBy: function( elem, id ) { var describedby = ( elem.attr( "aria-describedby" ) || "" ).split( /\s+/ ); describedby.push( id ); elem .data( "ui-tooltip-id", id ) .attr( "aria-describedby", $.trim( describedby.join( " " ) ) ); }, _removeDescribedBy: function( elem ) { var id = elem.data( "ui-tooltip-id" ), describedby = ( elem.attr( "aria-describedby" ) || "" ).split( /\s+/ ), index = $.inArray( id, describedby ); if ( index !== -1 ) { describedby.splice( index, 1 ); } elem.removeData( "ui-tooltip-id" ); describedby = $.trim( describedby.join( " " ) ); if ( describedby ) { elem.attr( "aria-describedby", describedby ); } else { elem.removeAttr( "aria-describedby" ); } }, _create: function() { this._on( { mouseover: "open", focusin: "open" } ); // IDs of generated tooltips, needed for destroy this.tooltips = {}; // IDs of parent tooltips where we removed the title attribute this.parents = {}; // Append the aria-live region so tooltips announce correctly this.liveRegion = $( "
" ) .attr( { role: "log", "aria-live": "assertive", "aria-relevant": "additions" } ) .appendTo( this.document[ 0 ].body ); this._addClass( this.liveRegion, null, "ui-helper-hidden-accessible" ); this.disabledTitles = $( [] ); }, _setOption: function( key, value ) { var that = this; this._super( key, value ); if ( key === "content" ) { $.each( this.tooltips, function( id, tooltipData ) { that._updateContent( tooltipData.element ); } ); } }, _setOptionDisabled: function( value ) { this[ value ? "_disable" : "_enable" ](); }, _disable: function() { var that = this; // Close open tooltips $.each( this.tooltips, function( id, tooltipData ) { var event = $.Event( "blur" ); event.target = event.currentTarget = tooltipData.element[ 0 ]; that.close( event, true ); } ); // Remove title attributes to prevent native tooltips this.disabledTitles = this.disabledTitles.add( this.element.find( this.options.items ).addBack() .filter( function() { var element = $( this ); if ( element.is( "[title]" ) ) { return element .data( "ui-tooltip-title", element.attr( "title" ) ) .removeAttr( "title" ); } } ) ); }, _enable: function() { // restore title attributes this.disabledTitles.each( function() { var element = $( this ); if ( element.data( "ui-tooltip-title" ) ) { element.attr( "title", element.data( "ui-tooltip-title" ) ); } } ); this.disabledTitles = $( [] ); }, open: function( event ) { var that = this, target = $( event ? event.target : this.element ) // we need closest here due to mouseover bubbling, // but always pointing at the same event target .closest( this.options.items ); // No element to show a tooltip for or the tooltip is already open if ( !target.length || target.data( "ui-tooltip-id" ) ) { return; } if ( target.attr( "title" ) ) { target.data( "ui-tooltip-title", target.attr( "title" ) ); } target.data( "ui-tooltip-open", true ); // Kill parent tooltips, custom or native, for hover if ( event && event.type === "mouseover" ) { target.parents().each( function() { var parent = $( this ), blurEvent; if ( parent.data( "ui-tooltip-open" ) ) { blurEvent = $.Event( "blur" ); blurEvent.target = blurEvent.currentTarget = this; that.close( blurEvent, true ); } if ( parent.attr( "title" ) ) { parent.uniqueId(); that.parents[ this.id ] = { element: this, title: parent.attr( "title" ) }; parent.attr( "title", "" ); } } ); } this._registerCloseHandlers( event, target ); this._updateContent( target, event ); }, _updateContent: function( target, event ) { var content, contentOption = this.options.content, that = this, eventType = event ? event.type : null; if ( typeof contentOption === "string" || contentOption.nodeType || contentOption.jquery ) { return this._open( event, target, contentOption ); } content = contentOption.call( target[ 0 ], function( response ) { // IE may instantly serve a cached response for ajax requests // delay this call to _open so the other call to _open runs first that._delay( function() { // Ignore async response if tooltip was closed already if ( !target.data( "ui-tooltip-open" ) ) { return; } // JQuery creates a special event for focusin when it doesn't // exist natively. To improve performance, the native event // object is reused and the type is changed. Therefore, we can't // rely on the type being correct after the event finished // bubbling, so we set it back to the previous value. (#8740) if ( event ) { event.type = eventType; } this._open( event, target, response ); } ); } ); if ( content ) { this._open( event, target, content ); } }, _open: function( event, target, content ) { var tooltipData, tooltip, delayedShow, a11yContent, positionOption = $.extend( {}, this.options.position ); if ( !content ) { return; } // Content can be updated multiple times. If the tooltip already // exists, then just update the content and bail. tooltipData = this._find( target ); if ( tooltipData ) { tooltipData.tooltip.find( ".ui-tooltip-content" ).html( content ); return; } // If we have a title, clear it to prevent the native tooltip // we have to check first to avoid defining a title if none exists // (we don't want to cause an element to start matching [title]) // // We use removeAttr only for key events, to allow IE to export the correct // accessible attributes. For mouse events, set to empty string to avoid // native tooltip showing up (happens only when removing inside mouseover). if ( target.is( "[title]" ) ) { if ( event && event.type === "mouseover" ) { target.attr( "title", "" ); } else { target.removeAttr( "title" ); } } tooltipData = this._tooltip( target ); tooltip = tooltipData.tooltip; this._addDescribedBy( target, tooltip.attr( "id" ) ); tooltip.find( ".ui-tooltip-content" ).html( content ); // Support: Voiceover on OS X, JAWS on IE <= 9 // JAWS announces deletions even when aria-relevant="additions" // Voiceover will sometimes re-read the entire log region's contents from the beginning this.liveRegion.children().hide(); a11yContent = $( "
" ).html( tooltip.find( ".ui-tooltip-content" ).html() ); a11yContent.removeAttr( "name" ).find( "[name]" ).removeAttr( "name" ); a11yContent.removeAttr( "id" ).find( "[id]" ).removeAttr( "id" ); a11yContent.appendTo( this.liveRegion ); function position( event ) { positionOption.of = event; if ( tooltip.is( ":hidden" ) ) { return; } tooltip.position( positionOption ); } if ( this.options.track && event && /^mouse/.test( event.type ) ) { this._on( this.document, { mousemove: position } ); // trigger once to override element-relative positioning position( event ); } else { tooltip.position( $.extend( { of: target }, this.options.position ) ); } tooltip.hide(); this._show( tooltip, this.options.show ); // Handle tracking tooltips that are shown with a delay (#8644). As soon // as the tooltip is visible, position the tooltip using the most recent // event. // Adds the check to add the timers only when both delay and track options are set (#14682) if ( this.options.track && this.options.show && this.options.show.delay ) { delayedShow = this.delayedShow = setInterval( function() { if ( tooltip.is( ":visible" ) ) { position( positionOption.of ); clearInterval( delayedShow ); } }, $.fx.interval ); } this._trigger( "open", event, { tooltip: tooltip } ); }, _registerCloseHandlers: function( event, target ) { var events = { keyup: function( event ) { if ( event.keyCode === $.ui.keyCode.ESCAPE ) { var fakeEvent = $.Event( event ); fakeEvent.currentTarget = target[ 0 ]; this.close( fakeEvent, true ); } } }; // Only bind remove handler for delegated targets. Non-delegated // tooltips will handle this in destroy. if ( target[ 0 ] !== this.element[ 0 ] ) { events.remove = function() { this._removeTooltip( this._find( target ).tooltip ); }; } if ( !event || event.type === "mouseover" ) { events.mouseleave = "close"; } if ( !event || event.type === "focusin" ) { events.focusout = "close"; } this._on( true, target, events ); }, close: function( event ) { var tooltip, that = this, target = $( event ? event.currentTarget : this.element ), tooltipData = this._find( target ); // The tooltip may already be closed if ( !tooltipData ) { // We set ui-tooltip-open immediately upon open (in open()), but only set the // additional data once there's actually content to show (in _open()). So even if the // tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in // the period between open() and _open(). target.removeData( "ui-tooltip-open" ); return; } tooltip = tooltipData.tooltip; // Disabling closes the tooltip, so we need to track when we're closing // to avoid an infinite loop in case the tooltip becomes disabled on close if ( tooltipData.closing ) { return; } // Clear the interval for delayed tracking tooltips clearInterval( this.delayedShow ); // Only set title if we had one before (see comment in _open()) // If the title attribute has changed since open(), don't restore if ( target.data( "ui-tooltip-title" ) && !target.attr( "title" ) ) { target.attr( "title", target.data( "ui-tooltip-title" ) ); } this._removeDescribedBy( target ); tooltipData.hiding = true; tooltip.stop( true ); this._hide( tooltip, this.options.hide, function() { that._removeTooltip( $( this ) ); } ); target.removeData( "ui-tooltip-open" ); this._off( target, "mouseleave focusout keyup" ); // Remove 'remove' binding only on delegated targets if ( target[ 0 ] !== this.element[ 0 ] ) { this._off( target, "remove" ); } this._off( this.document, "mousemove" ); if ( event && event.type === "mouseleave" ) { $.each( this.parents, function( id, parent ) { $( parent.element ).attr( "title", parent.title ); delete that.parents[ id ]; } ); } tooltipData.closing = true; this._trigger( "close", event, { tooltip: tooltip } ); if ( !tooltipData.hiding ) { tooltipData.closing = false; } }, _tooltip: function( element ) { var tooltip = $( "
" ).attr( "role", "tooltip" ), content = $( "
" ).appendTo( tooltip ), id = tooltip.uniqueId().attr( "id" ); this._addClass( content, "ui-tooltip-content" ); this._addClass( tooltip, "ui-tooltip", "ui-widget ui-widget-content" ); tooltip.appendTo( this._appendTo( element ) ); return this.tooltips[ id ] = { element: element, tooltip: tooltip }; }, _find: function( target ) { var id = target.data( "ui-tooltip-id" ); return id ? this.tooltips[ id ] : null; }, _removeTooltip: function( tooltip ) { tooltip.remove(); delete this.tooltips[ tooltip.attr( "id" ) ]; }, _appendTo: function( target ) { var element = target.closest( ".ui-front, dialog" ); if ( !element.length ) { element = this.document[ 0 ].body; } return element; }, _destroy: function() { var that = this; // Close open tooltips $.each( this.tooltips, function( id, tooltipData ) { // Delegate to close method to handle common cleanup var event = $.Event( "blur" ), element = tooltipData.element; event.target = event.currentTarget = element[ 0 ]; that.close( event, true ); // Remove immediately; destroying an open tooltip doesn't use the // hide animation $( "#" + id ).remove(); // Restore the title if ( element.data( "ui-tooltip-title" ) ) { // If the title attribute has changed since open(), don't restore if ( !element.attr( "title" ) ) { element.attr( "title", element.data( "ui-tooltip-title" ) ); } element.removeData( "ui-tooltip-title" ); } } ); this.liveRegion.remove(); } } ); // DEPRECATED // TODO: Switch return back to widget declaration at top of file when this is removed if ( $.uiBackCompat !== false ) { // Backcompat for tooltipClass option $.widget( "ui.tooltip", $.ui.tooltip, { options: { tooltipClass: null }, _tooltip: function() { var tooltipData = this._superApply( arguments ); if ( this.options.tooltipClass ) { tooltipData.tooltip.addClass( this.options.tooltipClass ); } return tooltipData; } } ); } var widgetsTooltip = $.ui.tooltip; /*! * jQuery UI Effects 1.12.1 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license */ //>>label: Effects Core //>>group: Effects // jscs:disable maximumLineLength //>>description: Extends the internal jQuery effects. Includes morphing and easing. Required by all other effects. // jscs:enable maximumLineLength //>>docs: http://api.jqueryui.com/category/effects-core/ //>>demos: http://jqueryui.com/effect/ var dataSpace = "ui-effects-", dataSpaceStyle = "ui-effects-style", dataSpaceAnimated = "ui-effects-animated", // Create a local jQuery because jQuery Color relies on it and the // global may not exist with AMD and a custom build (#10199) jQuery = $; $.effects = { effect: {} }; /*! * jQuery Color Animations v2.1.2 * https://github.com/jquery/jquery-color * * Copyright 2014 jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license * * Date: Wed Jan 16 08:47:09 2013 -0600 */ ( function( jQuery, undefined ) { var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor " + "borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor", // Plusequals test for += 100 -= 100 rplusequals = /^([\-+])=\s*(\d+\.?\d*)/, // A set of RE's that can match strings and generate color tuples. stringParsers = [ { re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/, parse: function( execResult ) { return [ execResult[ 1 ], execResult[ 2 ], execResult[ 3 ], execResult[ 4 ] ]; } }, { re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/, parse: function( execResult ) { return [ execResult[ 1 ] * 2.55, execResult[ 2 ] * 2.55, execResult[ 3 ] * 2.55, execResult[ 4 ] ]; } }, { // This regex ignores A-F because it's compared against an already lowercased string re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/, parse: function( execResult ) { return [ parseInt( execResult[ 1 ], 16 ), parseInt( execResult[ 2 ], 16 ), parseInt( execResult[ 3 ], 16 ) ]; } }, { // This regex ignores A-F because it's compared against an already lowercased string re: /#([a-f0-9])([a-f0-9])([a-f0-9])/, parse: function( execResult ) { return [ parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ), parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ), parseInt( execResult[ 3 ] + execResult[ 3 ], 16 ) ]; } }, { re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/, space: "hsla", parse: function( execResult ) { return [ execResult[ 1 ], execResult[ 2 ] / 100, execResult[ 3 ] / 100, execResult[ 4 ] ]; } } ], // JQuery.Color( ) color = jQuery.Color = function( color, green, blue, alpha ) { return new jQuery.Color.fn.parse( color, green, blue, alpha ); }, spaces = { rgba: { props: { red: { idx: 0, type: "byte" }, green: { idx: 1, type: "byte" }, blue: { idx: 2, type: "byte" } } }, hsla: { props: { hue: { idx: 0, type: "degrees" }, saturation: { idx: 1, type: "percent" }, lightness: { idx: 2, type: "percent" } } } }, propTypes = { "byte": { floor: true, max: 255 }, "percent": { max: 1 }, "degrees": { mod: 360, floor: true } }, support = color.support = {}, // Element for support tests supportElem = jQuery( "
" )[ 0 ], // Colors = jQuery.Color.names colors, // Local aliases of functions called often each = jQuery.each; // Determine rgba support immediately supportElem.style.cssText = "background-color:rgba(1,1,1,.5)"; support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1; // Define cache name and alpha properties // for rgba and hsla spaces each( spaces, function( spaceName, space ) { space.cache = "_" + spaceName; space.props.alpha = { idx: 3, type: "percent", def: 1 }; } ); function clamp( value, prop, allowEmpty ) { var type = propTypes[ prop.type ] || {}; if ( value == null ) { return ( allowEmpty || !prop.def ) ? null : prop.def; } // ~~ is an short way of doing floor for positive numbers value = type.floor ? ~~value : parseFloat( value ); // IE will pass in empty strings as value for alpha, // which will hit this case if ( isNaN( value ) ) { return prop.def; } if ( type.mod ) { // We add mod before modding to make sure that negatives values // get converted properly: -10 -> 350 return ( value + type.mod ) % type.mod; } // For now all property types without mod have min and max return 0 > value ? 0 : type.max < value ? type.max : value; } function stringParse( string ) { var inst = color(), rgba = inst._rgba = []; string = string.toLowerCase(); each( stringParsers, function( i, parser ) { var parsed, match = parser.re.exec( string ), values = match && parser.parse( match ), spaceName = parser.space || "rgba"; if ( values ) { parsed = inst[ spaceName ]( values ); // If this was an rgba parse the assignment might happen twice // oh well.... inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ]; rgba = inst._rgba = parsed._rgba; // Exit each( stringParsers ) here because we matched return false; } } ); // Found a stringParser that handled it if ( rgba.length ) { // If this came from a parsed string, force "transparent" when alpha is 0 // chrome, (and maybe others) return "transparent" as rgba(0,0,0,0) if ( rgba.join() === "0,0,0,0" ) { jQuery.extend( rgba, colors.transparent ); } return inst; } // Named colors return colors[ string ]; } color.fn = jQuery.extend( color.prototype, { parse: function( red, green, blue, alpha ) { if ( red === undefined ) { this._rgba = [ null, null, null, null ]; return this; } if ( red.jquery || red.nodeType ) { red = jQuery( red ).css( green ); green = undefined; } var inst = this, type = jQuery.type( red ), rgba = this._rgba = []; // More than 1 argument specified - assume ( red, green, blue, alpha ) if ( green !== undefined ) { red = [ red, green, blue, alpha ]; type = "array"; } if ( type === "string" ) { return this.parse( stringParse( red ) || colors._default ); } if ( type === "array" ) { each( spaces.rgba.props, function( key, prop ) { rgba[ prop.idx ] = clamp( red[ prop.idx ], prop ); } ); return this; } if ( type === "object" ) { if ( red instanceof color ) { each( spaces, function( spaceName, space ) { if ( red[ space.cache ] ) { inst[ space.cache ] = red[ space.cache ].slice(); } } ); } else { each( spaces, function( spaceName, space ) { var cache = space.cache; each( space.props, function( key, prop ) { // If the cache doesn't exist, and we know how to convert if ( !inst[ cache ] && space.to ) { // If the value was null, we don't need to copy it // if the key was alpha, we don't need to copy it either if ( key === "alpha" || red[ key ] == null ) { return; } inst[ cache ] = space.to( inst._rgba ); } // This is the only case where we allow nulls for ALL properties. // call clamp with alwaysAllowEmpty inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true ); } ); // Everything defined but alpha? if ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) { // Use the default of 1 inst[ cache ][ 3 ] = 1; if ( space.from ) { inst._rgba = space.from( inst[ cache ] ); } } } ); } return this; } }, is: function( compare ) { var is = color( compare ), same = true, inst = this; each( spaces, function( _, space ) { var localCache, isCache = is[ space.cache ]; if ( isCache ) { localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || []; each( space.props, function( _, prop ) { if ( isCache[ prop.idx ] != null ) { same = ( isCache[ prop.idx ] === localCache[ prop.idx ] ); return same; } } ); } return same; } ); return same; }, _space: function() { var used = [], inst = this; each( spaces, function( spaceName, space ) { if ( inst[ space.cache ] ) { used.push( spaceName ); } } ); return used.pop(); }, transition: function( other, distance ) { var end = color( other ), spaceName = end._space(), space = spaces[ spaceName ], startColor = this.alpha() === 0 ? color( "transparent" ) : this, start = startColor[ space.cache ] || space.to( startColor._rgba ), result = start.slice(); end = end[ space.cache ]; each( space.props, function( key, prop ) { var index = prop.idx, startValue = start[ index ], endValue = end[ index ], type = propTypes[ prop.type ] || {}; // If null, don't override start value if ( endValue === null ) { return; } // If null - use end if ( startValue === null ) { result[ index ] = endValue; } else { if ( type.mod ) { if ( endValue - startValue > type.mod / 2 ) { startValue += type.mod; } else if ( startValue - endValue > type.mod / 2 ) { startValue -= type.mod; } } result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop ); } } ); return this[ spaceName ]( result ); }, blend: function( opaque ) { // If we are already opaque - return ourself if ( this._rgba[ 3 ] === 1 ) { return this; } var rgb = this._rgba.slice(), a = rgb.pop(), blend = color( opaque )._rgba; return color( jQuery.map( rgb, function( v, i ) { return ( 1 - a ) * blend[ i ] + a * v; } ) ); }, toRgbaString: function() { var prefix = "rgba(", rgba = jQuery.map( this._rgba, function( v, i ) { return v == null ? ( i > 2 ? 1 : 0 ) : v; } ); if ( rgba[ 3 ] === 1 ) { rgba.pop(); prefix = "rgb("; } return prefix + rgba.join() + ")"; }, toHslaString: function() { var prefix = "hsla(", hsla = jQuery.map( this.hsla(), function( v, i ) { if ( v == null ) { v = i > 2 ? 1 : 0; } // Catch 1 and 2 if ( i && i < 3 ) { v = Math.round( v * 100 ) + "%"; } return v; } ); if ( hsla[ 3 ] === 1 ) { hsla.pop(); prefix = "hsl("; } return prefix + hsla.join() + ")"; }, toHexString: function( includeAlpha ) { var rgba = this._rgba.slice(), alpha = rgba.pop(); if ( includeAlpha ) { rgba.push( ~~( alpha * 255 ) ); } return "#" + jQuery.map( rgba, function( v ) { // Default to 0 when nulls exist v = ( v || 0 ).toString( 16 ); return v.length === 1 ? "0" + v : v; } ).join( "" ); }, toString: function() { return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString(); } } ); color.fn.parse.prototype = color.fn; // Hsla conversions adapted from: // https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021 function hue2rgb( p, q, h ) { h = ( h + 1 ) % 1; if ( h * 6 < 1 ) { return p + ( q - p ) * h * 6; } if ( h * 2 < 1 ) { return q; } if ( h * 3 < 2 ) { return p + ( q - p ) * ( ( 2 / 3 ) - h ) * 6; } return p; } spaces.hsla.to = function( rgba ) { if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) { return [ null, null, null, rgba[ 3 ] ]; } var r = rgba[ 0 ] / 255, g = rgba[ 1 ] / 255, b = rgba[ 2 ] / 255, a = rgba[ 3 ], max = Math.max( r, g, b ), min = Math.min( r, g, b ), diff = max - min, add = max + min, l = add * 0.5, h, s; if ( min === max ) { h = 0; } else if ( r === max ) { h = ( 60 * ( g - b ) / diff ) + 360; } else if ( g === max ) { h = ( 60 * ( b - r ) / diff ) + 120; } else { h = ( 60 * ( r - g ) / diff ) + 240; } // Chroma (diff) == 0 means greyscale which, by definition, saturation = 0% // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add) if ( diff === 0 ) { s = 0; } else if ( l <= 0.5 ) { s = diff / add; } else { s = diff / ( 2 - add ); } return [ Math.round( h ) % 360, s, l, a == null ? 1 : a ]; }; spaces.hsla.from = function( hsla ) { if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) { return [ null, null, null, hsla[ 3 ] ]; } var h = hsla[ 0 ] / 360, s = hsla[ 1 ], l = hsla[ 2 ], a = hsla[ 3 ], q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s, p = 2 * l - q; return [ Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ), Math.round( hue2rgb( p, q, h ) * 255 ), Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ), a ]; }; each( spaces, function( spaceName, space ) { var props = space.props, cache = space.cache, to = space.to, from = space.from; // Makes rgba() and hsla() color.fn[ spaceName ] = function( value ) { // Generate a cache for this space if it doesn't exist if ( to && !this[ cache ] ) { this[ cache ] = to( this._rgba ); } if ( value === undefined ) { return this[ cache ].slice(); } var ret, type = jQuery.type( value ), arr = ( type === "array" || type === "object" ) ? value : arguments, local = this[ cache ].slice(); each( props, function( key, prop ) { var val = arr[ type === "object" ? key : prop.idx ]; if ( val == null ) { val = local[ prop.idx ]; } local[ prop.idx ] = clamp( val, prop ); } ); if ( from ) { ret = color( from( local ) ); ret[ cache ] = local; return ret; } else { return color( local ); } }; // Makes red() green() blue() alpha() hue() saturation() lightness() each( props, function( key, prop ) { // Alpha is included in more than one space if ( color.fn[ key ] ) { return; } color.fn[ key ] = function( value ) { var vtype = jQuery.type( value ), fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ), local = this[ fn ](), cur = local[ prop.idx ], match; if ( vtype === "undefined" ) { return cur; } if ( vtype === "function" ) { value = value.call( this, cur ); vtype = jQuery.type( value ); } if ( value == null && prop.empty ) { return this; } if ( vtype === "string" ) { match = rplusequals.exec( value ); if ( match ) { value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 ); } } local[ prop.idx ] = value; return this[ fn ]( local ); }; } ); } ); // Add cssHook and .fx.step function for each named hook. // accept a space separated string of properties color.hook = function( hook ) { var hooks = hook.split( " " ); each( hooks, function( i, hook ) { jQuery.cssHooks[ hook ] = { set: function( elem, value ) { var parsed, curElem, backgroundColor = ""; if ( value !== "transparent" && ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) ) { value = color( parsed || value ); if ( !support.rgba && value._rgba[ 3 ] !== 1 ) { curElem = hook === "backgroundColor" ? elem.parentNode : elem; while ( ( backgroundColor === "" || backgroundColor === "transparent" ) && curElem && curElem.style ) { try { backgroundColor = jQuery.css( curElem, "backgroundColor" ); curElem = curElem.parentNode; } catch ( e ) { } } value = value.blend( backgroundColor && backgroundColor !== "transparent" ? backgroundColor : "_default" ); } value = value.toRgbaString(); } try { elem.style[ hook ] = value; } catch ( e ) { // Wrapped to prevent IE from throwing errors on "invalid" values like // 'auto' or 'inherit' } } }; jQuery.fx.step[ hook ] = function( fx ) { if ( !fx.colorInit ) { fx.start = color( fx.elem, hook ); fx.end = color( fx.end ); fx.colorInit = true; } jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) ); }; } ); }; color.hook( stepHooks ); jQuery.cssHooks.borderColor = { expand: function( value ) { var expanded = {}; each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) { expanded[ "border" + part + "Color" ] = value; } ); return expanded; } }; // Basic color names only. // Usage of any of the other color names requires adding yourself or including // jquery.color.svg-names.js. colors = jQuery.Color.names = { // 4.1. Basic color keywords aqua: "#00ffff", black: "#000000", blue: "#0000ff", fuchsia: "#ff00ff", gray: "#808080", green: "#008000", lime: "#00ff00", maroon: "#800000", navy: "#000080", olive: "#808000", purple: "#800080", red: "#ff0000", silver: "#c0c0c0", teal: "#008080", white: "#ffffff", yellow: "#ffff00", // 4.2.3. "transparent" color keyword transparent: [ null, null, null, 0 ], _default: "#ffffff" }; } )( jQuery ); /******************************************************************************/ /****************************** CLASS ANIMATIONS ******************************/ /******************************************************************************/ ( function() { var classAnimationActions = [ "add", "remove", "toggle" ], shorthandStyles = { border: 1, borderBottom: 1, borderColor: 1, borderLeft: 1, borderRight: 1, borderTop: 1, borderWidth: 1, margin: 1, padding: 1 }; $.each( [ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) { $.fx.step[ prop ] = function( fx ) { if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) { jQuery.style( fx.elem, prop, fx.end ); fx.setAttr = true; } }; } ); function getElementStyles( elem ) { var key, len, style = elem.ownerDocument.defaultView ? elem.ownerDocument.defaultView.getComputedStyle( elem, null ) : elem.currentStyle, styles = {}; if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) { len = style.length; while ( len-- ) { key = style[ len ]; if ( typeof style[ key ] === "string" ) { styles[ $.camelCase( key ) ] = style[ key ]; } } // Support: Opera, IE <9 } else { for ( key in style ) { if ( typeof style[ key ] === "string" ) { styles[ key ] = style[ key ]; } } } return styles; } function styleDifference( oldStyle, newStyle ) { var diff = {}, name, value; for ( name in newStyle ) { value = newStyle[ name ]; if ( oldStyle[ name ] !== value ) { if ( !shorthandStyles[ name ] ) { if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) { diff[ name ] = value; } } } } return diff; } // Support: jQuery <1.8 if ( !$.fn.addBack ) { $.fn.addBack = function( selector ) { return this.add( selector == null ? this.prevObject : this.prevObject.filter( selector ) ); }; } $.effects.animateClass = function( value, duration, easing, callback ) { var o = $.speed( duration, easing, callback ); return this.queue( function() { var animated = $( this ), baseClass = animated.attr( "class" ) || "", applyClassChange, allAnimations = o.children ? animated.find( "*" ).addBack() : animated; // Map the animated objects to store the original styles. allAnimations = allAnimations.map( function() { var el = $( this ); return { el: el, start: getElementStyles( this ) }; } ); // Apply class change applyClassChange = function() { $.each( classAnimationActions, function( i, action ) { if ( value[ action ] ) { animated[ action + "Class" ]( value[ action ] ); } } ); }; applyClassChange(); // Map all animated objects again - calculate new styles and diff allAnimations = allAnimations.map( function() { this.end = getElementStyles( this.el[ 0 ] ); this.diff = styleDifference( this.start, this.end ); return this; } ); // Apply original class animated.attr( "class", baseClass ); // Map all animated objects again - this time collecting a promise allAnimations = allAnimations.map( function() { var styleInfo = this, dfd = $.Deferred(), opts = $.extend( {}, o, { queue: false, complete: function() { dfd.resolve( styleInfo ); } } ); this.el.animate( this.diff, opts ); return dfd.promise(); } ); // Once all animations have completed: $.when.apply( $, allAnimations.get() ).done( function() { // Set the final class applyClassChange(); // For each animated element, // clear all css properties that were animated $.each( arguments, function() { var el = this.el; $.each( this.diff, function( key ) { el.css( key, "" ); } ); } ); // This is guarnteed to be there if you use jQuery.speed() // it also handles dequeuing the next anim... o.complete.call( animated[ 0 ] ); } ); } ); }; $.fn.extend( { addClass: ( function( orig ) { return function( classNames, speed, easing, callback ) { return speed ? $.effects.animateClass.call( this, { add: classNames }, speed, easing, callback ) : orig.apply( this, arguments ); }; } )( $.fn.addClass ), removeClass: ( function( orig ) { return function( classNames, speed, easing, callback ) { return arguments.length > 1 ? $.effects.animateClass.call( this, { remove: classNames }, speed, easing, callback ) : orig.apply( this, arguments ); }; } )( $.fn.removeClass ), toggleClass: ( function( orig ) { return function( classNames, force, speed, easing, callback ) { if ( typeof force === "boolean" || force === undefined ) { if ( !speed ) { // Without speed parameter return orig.apply( this, arguments ); } else { return $.effects.animateClass.call( this, ( force ? { add: classNames } : { remove: classNames } ), speed, easing, callback ); } } else { // Without force parameter return $.effects.animateClass.call( this, { toggle: classNames }, force, speed, easing ); } }; } )( $.fn.toggleClass ), switchClass: function( remove, add, speed, easing, callback ) { return $.effects.animateClass.call( this, { add: add, remove: remove }, speed, easing, callback ); } } ); } )(); /******************************************************************************/ /*********************************** EFFECTS **********************************/ /******************************************************************************/ ( function() { if ( $.expr && $.expr.filters && $.expr.filters.animated ) { $.expr.filters.animated = ( function( orig ) { return function( elem ) { return !!$( elem ).data( dataSpaceAnimated ) || orig( elem ); }; } )( $.expr.filters.animated ); } if ( $.uiBackCompat !== false ) { $.extend( $.effects, { // Saves a set of properties in a data storage save: function( element, set ) { var i = 0, length = set.length; for ( ; i < length; i++ ) { if ( set[ i ] !== null ) { element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] ); } } }, // Restores a set of previously saved properties from a data storage restore: function( element, set ) { var val, i = 0, length = set.length; for ( ; i < length; i++ ) { if ( set[ i ] !== null ) { val = element.data( dataSpace + set[ i ] ); element.css( set[ i ], val ); } } }, setMode: function( el, mode ) { if ( mode === "toggle" ) { mode = el.is( ":hidden" ) ? "show" : "hide"; } return mode; }, // Wraps the element around a wrapper that copies position properties createWrapper: function( element ) { // If the element is already wrapped, return it if ( element.parent().is( ".ui-effects-wrapper" ) ) { return element.parent(); } // Wrap the element var props = { width: element.outerWidth( true ), height: element.outerHeight( true ), "float": element.css( "float" ) }, wrapper = $( "

" ) .addClass( "ui-effects-wrapper" ) .css( { fontSize: "100%", background: "transparent", border: "none", margin: 0, padding: 0 } ), // Store the size in case width/height are defined in % - Fixes #5245 size = { width: element.width(), height: element.height() }, active = document.activeElement; // Support: Firefox // Firefox incorrectly exposes anonymous content // https://bugzilla.mozilla.org/show_bug.cgi?id=561664 try { active.id; } catch ( e ) { active = document.body; } element.wrap( wrapper ); // Fixes #7595 - Elements lose focus when wrapped. if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) { $( active ).trigger( "focus" ); } // Hotfix for jQuery 1.4 since some change in wrap() seems to actually // lose the reference to the wrapped element wrapper = element.parent(); // Transfer positioning properties to the wrapper if ( element.css( "position" ) === "static" ) { wrapper.css( { position: "relative" } ); element.css( { position: "relative" } ); } else { $.extend( props, { position: element.css( "position" ), zIndex: element.css( "z-index" ) } ); $.each( [ "top", "left", "bottom", "right" ], function( i, pos ) { props[ pos ] = element.css( pos ); if ( isNaN( parseInt( props[ pos ], 10 ) ) ) { props[ pos ] = "auto"; } } ); element.css( { position: "relative", top: 0, left: 0, right: "auto", bottom: "auto" } ); } element.css( size ); return wrapper.css( props ).show(); }, removeWrapper: function( element ) { var active = document.activeElement; if ( element.parent().is( ".ui-effects-wrapper" ) ) { element.parent().replaceWith( element ); // Fixes #7595 - Elements lose focus when wrapped. if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) { $( active ).trigger( "focus" ); } } return element; } } ); } $.extend( $.effects, { version: "1.12.1", define: function( name, mode, effect ) { if ( !effect ) { effect = mode; mode = "effect"; } $.effects.effect[ name ] = effect; $.effects.effect[ name ].mode = mode; return effect; }, scaledDimensions: function( element, percent, direction ) { if ( percent === 0 ) { return { height: 0, width: 0, outerHeight: 0, outerWidth: 0 }; } var x = direction !== "horizontal" ? ( ( percent || 100 ) / 100 ) : 1, y = direction !== "vertical" ? ( ( percent || 100 ) / 100 ) : 1; return { height: element.height() * y, width: element.width() * x, outerHeight: element.outerHeight() * y, outerWidth: element.outerWidth() * x }; }, clipToBox: function( animation ) { return { width: animation.clip.right - animation.clip.left, height: animation.clip.bottom - animation.clip.top, left: animation.clip.left, top: animation.clip.top }; }, // Injects recently queued functions to be first in line (after "inprogress") unshift: function( element, queueLength, count ) { var queue = element.queue(); if ( queueLength > 1 ) { queue.splice.apply( queue, [ 1, 0 ].concat( queue.splice( queueLength, count ) ) ); } element.dequeue(); }, saveStyle: function( element ) { element.data( dataSpaceStyle, element[ 0 ].style.cssText ); }, restoreStyle: function( element ) { element[ 0 ].style.cssText = element.data( dataSpaceStyle ) || ""; element.removeData( dataSpaceStyle ); }, mode: function( element, mode ) { var hidden = element.is( ":hidden" ); if ( mode === "toggle" ) { mode = hidden ? "show" : "hide"; } if ( hidden ? mode === "hide" : mode === "show" ) { mode = "none"; } return mode; }, // Translates a [top,left] array into a baseline value getBaseline: function( origin, original ) { var y, x; switch ( origin[ 0 ] ) { case "top": y = 0; break; case "middle": y = 0.5; break; case "bottom": y = 1; break; default: y = origin[ 0 ] / original.height; } switch ( origin[ 1 ] ) { case "left": x = 0; break; case "center": x = 0.5; break; case "right": x = 1; break; default: x = origin[ 1 ] / original.width; } return { x: x, y: y }; }, // Creates a placeholder element so that the original element can be made absolute createPlaceholder: function( element ) { var placeholder, cssPosition = element.css( "position" ), position = element.position(); // Lock in margins first to account for form elements, which // will change margin if you explicitly set height // see: http://jsfiddle.net/JZSMt/3/ https://bugs.webkit.org/show_bug.cgi?id=107380 // Support: Safari element.css( { marginTop: element.css( "marginTop" ), marginBottom: element.css( "marginBottom" ), marginLeft: element.css( "marginLeft" ), marginRight: element.css( "marginRight" ) } ) .outerWidth( element.outerWidth() ) .outerHeight( element.outerHeight() ); if ( /^(static|relative)/.test( cssPosition ) ) { cssPosition = "absolute"; placeholder = $( "<" + element[ 0 ].nodeName + ">" ).insertAfter( element ).css( { // Convert inline to inline block to account for inline elements // that turn to inline block based on content (like img) display: /^(inline|ruby)/.test( element.css( "display" ) ) ? "inline-block" : "block", visibility: "hidden", // Margins need to be set to account for margin collapse marginTop: element.css( "marginTop" ), marginBottom: element.css( "marginBottom" ), marginLeft: element.css( "marginLeft" ), marginRight: element.css( "marginRight" ), "float": element.css( "float" ) } ) .outerWidth( element.outerWidth() ) .outerHeight( element.outerHeight() ) .addClass( "ui-effects-placeholder" ); element.data( dataSpace + "placeholder", placeholder ); } element.css( { position: cssPosition, left: position.left, top: position.top } ); return placeholder; }, removePlaceholder: function( element ) { var dataKey = dataSpace + "placeholder", placeholder = element.data( dataKey ); if ( placeholder ) { placeholder.remove(); element.removeData( dataKey ); } }, // Removes a placeholder if it exists and restores // properties that were modified during placeholder creation cleanUp: function( element ) { $.effects.restoreStyle( element ); $.effects.removePlaceholder( element ); }, setTransition: function( element, list, factor, value ) { value = value || {}; $.each( list, function( i, x ) { var unit = element.cssUnit( x ); if ( unit[ 0 ] > 0 ) { value[ x ] = unit[ 0 ] * factor + unit[ 1 ]; } } ); return value; } } ); // Return an effect options object for the given parameters: function _normalizeArguments( effect, options, speed, callback ) { // Allow passing all options as the first parameter if ( $.isPlainObject( effect ) ) { options = effect; effect = effect.effect; } // Convert to an object effect = { effect: effect }; // Catch (effect, null, ...) if ( options == null ) { options = {}; } // Catch (effect, callback) if ( $.isFunction( options ) ) { callback = options; speed = null; options = {}; } // Catch (effect, speed, ?) if ( typeof options === "number" || $.fx.speeds[ options ] ) { callback = speed; speed = options; options = {}; } // Catch (effect, options, callback) if ( $.isFunction( speed ) ) { callback = speed; speed = null; } // Add options to effect if ( options ) { $.extend( effect, options ); } speed = speed || options.duration; effect.duration = $.fx.off ? 0 : typeof speed === "number" ? speed : speed in $.fx.speeds ? $.fx.speeds[ speed ] : $.fx.speeds._default; effect.complete = callback || options.complete; return effect; } function standardAnimationOption( option ) { // Valid standard speeds (nothing, number, named speed) if ( !option || typeof option === "number" || $.fx.speeds[ option ] ) { return true; } // Invalid strings - treat as "normal" speed if ( typeof option === "string" && !$.effects.effect[ option ] ) { return true; } // Complete callback if ( $.isFunction( option ) ) { return true; } // Options hash (but not naming an effect) if ( typeof option === "object" && !option.effect ) { return true; } // Didn't match any standard API return false; } $.fn.extend( { effect: function( /* effect, options, speed, callback */ ) { var args = _normalizeArguments.apply( this, arguments ), effectMethod = $.effects.effect[ args.effect ], defaultMode = effectMethod.mode, queue = args.queue, queueName = queue || "fx", complete = args.complete, mode = args.mode, modes = [], prefilter = function( next ) { var el = $( this ), normalizedMode = $.effects.mode( el, mode ) || defaultMode; // Sentinel for duck-punching the :animated psuedo-selector el.data( dataSpaceAnimated, true ); // Save effect mode for later use, // we can't just call $.effects.mode again later, // as the .show() below destroys the initial state modes.push( normalizedMode ); // See $.uiBackCompat inside of run() for removal of defaultMode in 1.13 if ( defaultMode && ( normalizedMode === "show" || ( normalizedMode === defaultMode && normalizedMode === "hide" ) ) ) { el.show(); } if ( !defaultMode || normalizedMode !== "none" ) { $.effects.saveStyle( el ); } if ( $.isFunction( next ) ) { next(); } }; if ( $.fx.off || !effectMethod ) { // Delegate to the original method (e.g., .show()) if possible if ( mode ) { return this[ mode ]( args.duration, complete ); } else { return this.each( function() { if ( complete ) { complete.call( this ); } } ); } } function run( next ) { var elem = $( this ); function cleanup() { elem.removeData( dataSpaceAnimated ); $.effects.cleanUp( elem ); if ( args.mode === "hide" ) { elem.hide(); } done(); } function done() { if ( $.isFunction( complete ) ) { complete.call( elem[ 0 ] ); } if ( $.isFunction( next ) ) { next(); } } // Override mode option on a per element basis, // as toggle can be either show or hide depending on element state args.mode = modes.shift(); if ( $.uiBackCompat !== false && !defaultMode ) { if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) { // Call the core method to track "olddisplay" properly elem[ mode ](); done(); } else { effectMethod.call( elem[ 0 ], args, done ); } } else { if ( args.mode === "none" ) { // Call the core method to track "olddisplay" properly elem[ mode ](); done(); } else { effectMethod.call( elem[ 0 ], args, cleanup ); } } } // Run prefilter on all elements first to ensure that // any showing or hiding happens before placeholder creation, // which ensures that any layout changes are correctly captured. return queue === false ? this.each( prefilter ).each( run ) : this.queue( queueName, prefilter ).queue( queueName, run ); }, show: ( function( orig ) { return function( option ) { if ( standardAnimationOption( option ) ) { return orig.apply( this, arguments ); } else { var args = _normalizeArguments.apply( this, arguments ); args.mode = "show"; return this.effect.call( this, args ); } }; } )( $.fn.show ), hide: ( function( orig ) { return function( option ) { if ( standardAnimationOption( option ) ) { return orig.apply( this, arguments ); } else { var args = _normalizeArguments.apply( this, arguments ); args.mode = "hide"; return this.effect.call( this, args ); } }; } )( $.fn.hide ), toggle: ( function( orig ) { return function( option ) { if ( standardAnimationOption( option ) || typeof option === "boolean" ) { return orig.apply( this, arguments ); } else { var args = _normalizeArguments.apply( this, arguments ); args.mode = "toggle"; return this.effect.call( this, args ); } }; } )( $.fn.toggle ), cssUnit: function( key ) { var style = this.css( key ), val = []; $.each( [ "em", "px", "%", "pt" ], function( i, unit ) { if ( style.indexOf( unit ) > 0 ) { val = [ parseFloat( style ), unit ]; } } ); return val; }, cssClip: function( clipObj ) { if ( clipObj ) { return this.css( "clip", "rect(" + clipObj.top + "px " + clipObj.right + "px " + clipObj.bottom + "px " + clipObj.left + "px)" ); } return parseClip( this.css( "clip" ), this ); }, transfer: function( options, done ) { var element = $( this ), target = $( options.to ), targetFixed = target.css( "position" ) === "fixed", body = $( "body" ), fixTop = targetFixed ? body.scrollTop() : 0, fixLeft = targetFixed ? body.scrollLeft() : 0, endPosition = target.offset(), animation = { top: endPosition.top - fixTop, left: endPosition.left - fixLeft, height: target.innerHeight(), width: target.innerWidth() }, startPosition = element.offset(), transfer = $( "
" ) .appendTo( "body" ) .addClass( options.className ) .css( { top: startPosition.top - fixTop, left: startPosition.left - fixLeft, height: element.innerHeight(), width: element.innerWidth(), position: targetFixed ? "fixed" : "absolute" } ) .animate( animation, options.duration, options.easing, function() { transfer.remove(); if ( $.isFunction( done ) ) { done(); } } ); } } ); function parseClip( str, element ) { var outerWidth = element.outerWidth(), outerHeight = element.outerHeight(), clipRegex = /^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/, values = clipRegex.exec( str ) || [ "", 0, outerWidth, outerHeight, 0 ]; return { top: parseFloat( values[ 1 ] ) || 0, right: values[ 2 ] === "auto" ? outerWidth : parseFloat( values[ 2 ] ), bottom: values[ 3 ] === "auto" ? outerHeight : parseFloat( values[ 3 ] ), left: parseFloat( values[ 4 ] ) || 0 }; } $.fx.step.clip = function( fx ) { if ( !fx.clipInit ) { fx.start = $( fx.elem ).cssClip(); if ( typeof fx.end === "string" ) { fx.end = parseClip( fx.end, fx.elem ); } fx.clipInit = true; } $( fx.elem ).cssClip( { top: fx.pos * ( fx.end.top - fx.start.top ) + fx.start.top, right: fx.pos * ( fx.end.right - fx.start.right ) + fx.start.right, bottom: fx.pos * ( fx.end.bottom - fx.start.bottom ) + fx.start.bottom, left: fx.pos * ( fx.end.left - fx.start.left ) + fx.start.left } ); }; } )(); /******************************************************************************/ /*********************************** EASING ***********************************/ /******************************************************************************/ ( function() { // Based on easing equations from Robert Penner (http://www.robertpenner.com/easing) var baseEasings = {}; $.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) { baseEasings[ name ] = function( p ) { return Math.pow( p, i + 2 ); }; } ); $.extend( baseEasings, { Sine: function( p ) { return 1 - Math.cos( p * Math.PI / 2 ); }, Circ: function( p ) { return 1 - Math.sqrt( 1 - p * p ); }, Elastic: function( p ) { return p === 0 || p === 1 ? p : -Math.pow( 2, 8 * ( p - 1 ) ) * Math.sin( ( ( p - 1 ) * 80 - 7.5 ) * Math.PI / 15 ); }, Back: function( p ) { return p * p * ( 3 * p - 2 ); }, Bounce: function( p ) { var pow2, bounce = 4; while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {} return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 ); } } ); $.each( baseEasings, function( name, easeIn ) { $.easing[ "easeIn" + name ] = easeIn; $.easing[ "easeOut" + name ] = function( p ) { return 1 - easeIn( 1 - p ); }; $.easing[ "easeInOut" + name ] = function( p ) { return p < 0.5 ? easeIn( p * 2 ) / 2 : 1 - easeIn( p * -2 + 2 ) / 2; }; } ); } )(); var effect = $.effects; /*! * jQuery UI Effects Bounce 1.12.1 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license */ //>>label: Bounce Effect //>>group: Effects //>>description: Bounces an element horizontally or vertically n times. //>>docs: http://api.jqueryui.com/bounce-effect/ //>>demos: http://jqueryui.com/effect/ var effectsEffectBounce = $.effects.define( "bounce", function( options, done ) { var upAnim, downAnim, refValue, element = $( this ), // Defaults: mode = options.mode, hide = mode === "hide", show = mode === "show", direction = options.direction || "up", distance = options.distance, times = options.times || 5, // Number of internal animations anims = times * 2 + ( show || hide ? 1 : 0 ), speed = options.duration / anims, easing = options.easing, // Utility: ref = ( direction === "up" || direction === "down" ) ? "top" : "left", motion = ( direction === "up" || direction === "left" ), i = 0, queuelen = element.queue().length; $.effects.createPlaceholder( element ); refValue = element.css( ref ); // Default distance for the BIGGEST bounce is the outer Distance / 3 if ( !distance ) { distance = element[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3; } if ( show ) { downAnim = { opacity: 1 }; downAnim[ ref ] = refValue; // If we are showing, force opacity 0 and set the initial position // then do the "first" animation element .css( "opacity", 0 ) .css( ref, motion ? -distance * 2 : distance * 2 ) .animate( downAnim, speed, easing ); } // Start at the smallest distance if we are hiding if ( hide ) { distance = distance / Math.pow( 2, times - 1 ); } downAnim = {}; downAnim[ ref ] = refValue; // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here for ( ; i < times; i++ ) { upAnim = {}; upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance; element .animate( upAnim, speed, easing ) .animate( downAnim, speed, easing ); distance = hide ? distance * 2 : distance / 2; } // Last Bounce when Hiding if ( hide ) { upAnim = { opacity: 0 }; upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance; element.animate( upAnim, speed, easing ); } element.queue( done ); $.effects.unshift( element, queuelen, anims + 1 ); } ); }));; /* /web/static/lib/jquery/jquery.browser.js defined in bundle 'web.assetsCommon' */ (function() { /** reimport deprecated $.browser, remove me when jquery.ba-bqq is dropped */ $.uaMatch = function( ua ) { var ua = ua.toLowerCase(); var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) || /(webkit)[ \/]([\w.]+)/.exec( ua ) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) || /(msie) ([\w.]+)/.exec( ua ) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) || []; return { browser: match[ 1 ] || "", version: match[ 2 ] || "0" }; }; // Don't clobber any existing jQuery.browser in case it's different if ( !$.browser ) { var matched = $.uaMatch( navigator.userAgent ); var browser = {}; if ( matched.browser ) { browser[ matched.browser ] = true; browser.version = matched.version; } // Chrome is Webkit, but Webkit is also Safari. if ( browser.chrome ) { browser.webkit = true; } else if ( browser.webkit ) { browser.safari = true; } $.browser = browser; } })(); ; /* /web/static/lib/jquery.blockUI/jquery.blockUI.js defined in bundle 'web.assetsCommon' */ /*! * jQuery blockUI plugin * Version 2.70.0-2014.11.23 * Requires jQuery v1.7 or later * * Examples at: http://malsup.com/jquery/block/ * Copyright (c) 2007-2013 M. Alsup * Dual licensed under the MIT and GPL licenses: * http://www.opensource.org/licenses/mit-license.php * http://www.gnu.org/licenses/gpl.html * * Thanks to Amir-Hossein Sobhi for some excellent contributions! */ ;(function() { /*jshint eqeqeq:false curly:false latedef:false */ "use strict"; function setup($) { $.fn._fadeIn = $.fn.fadeIn; var noOp = $.noop || function() {}; // this bit is to ensure we don't call setExpression when we shouldn't (with extra muscle to handle // confusing userAgent strings on Vista) var msie = /MSIE/.test(navigator.userAgent); var ie6 = /MSIE 6.0/.test(navigator.userAgent) && ! /MSIE 8.0/.test(navigator.userAgent); var mode = document.documentMode || 0; var setExpr = $.isFunction( document.createElement('div').style.setExpression ); // global $ methods for blocking/unblocking the entire page $.blockUI = function(opts) { install(window, opts); }; $.unblockUI = function(opts) { remove(window, opts); }; // convenience method for quick growl-like notifications (http://www.google.com/search?q=growl) $.growlUI = function(title, message, timeout, onClose) { var $m = $('
'); if (title) $m.append('
'+title+'
'); if (message) $m.append('
'+message+'
'); if (timeout === undefined) timeout = 3000; // Added by konapun: Set timeout to 30 seconds if this growl is moused over, like normal toast notifications var callBlock = function(opts) { opts = opts || {}; $.blockUI({ message: $m, fadeIn : typeof opts.fadeIn !== 'undefined' ? opts.fadeIn : 700, fadeOut: typeof opts.fadeOut !== 'undefined' ? opts.fadeOut : 1000, timeout: typeof opts.timeout !== 'undefined' ? opts.timeout : timeout, centerY: false, showOverlay: false, onUnblock: onClose, css: $.blockUI.defaults.growlCSS }); }; callBlock(); var nonmousedOpacity = $m.css('opacity'); $m.mouseover(function() { callBlock({ fadeIn: 0, timeout: 30000 }); var displayBlock = $('.blockMsg'); displayBlock.stop(); // cancel fadeout if it has started displayBlock.fadeTo(300, 1); // make it easier to read the message by removing transparency }).mouseout(function() { $('.blockMsg').fadeOut(1000); }); // End konapun additions }; // plugin method for blocking element content $.fn.block = function(opts) { if ( this[0] === window ) { $.blockUI( opts ); return this; } var fullOpts = $.extend({}, $.blockUI.defaults, opts || {}); this.each(function() { var $el = $(this); if (fullOpts.ignoreIfBlocked && $el.data('blockUI.isBlocked')) return; $el.unblock({ fadeOut: 0 }); }); return this.each(function() { if ($.css(this,'position') == 'static') { this.style.position = 'relative'; $(this).data('blockUI.static', true); } this.style.zoom = 1; // force 'hasLayout' in ie install(this, opts); }); }; // plugin method for unblocking element content $.fn.unblock = function(opts) { if ( this[0] === window ) { $.unblockUI( opts ); return this; } return this.each(function() { remove(this, opts); }); }; $.blockUI.version = 2.70; // 2nd generation blocking at no extra cost! // override these in your code to change the default behavior and style $.blockUI.defaults = { // message displayed when blocking (use null for no message) message: '
Please wait...
', title: null, // title string; only used when theme == true draggable: true, // only used when theme == true (requires jquery-ui.js to be loaded) theme: false, // set to true to use with jQuery UI themes // styles for the message when blocking; if you wish to disable // these and use an external stylesheet then do this in your code: // $.blockUI.defaults.css = {}; css: { padding: 0, margin: 0, width: '30%', top: '40%', left: '35%', textAlign: 'center', color: '#000', border: '3px solid #aaa', backgroundColor:'#fff', cursor: 'wait' }, // minimal style set used when themes are used themedCSS: { width: '30%', top: '40%', left: '35%' }, // styles for the overlay overlayCSS: { backgroundColor: '#000', opacity: 0.6, cursor: 'wait' }, // style to replace wait cursor before unblocking to correct issue // of lingering wait cursor cursorReset: 'default', // styles applied when using $.growlUI growlCSS: { width: '350px', top: '10px', left: '', right: '10px', border: 'none', padding: '5px', opacity: 0.6, cursor: 'default', color: '#fff', backgroundColor: '#000', '-webkit-border-radius':'10px', '-moz-border-radius': '10px', 'border-radius': '10px' }, // IE issues: 'about:blank' fails on HTTPS and javascript:false is s-l-o-w // (hat tip to Jorge H. N. de Vasconcelos) /*jshint scripturl:true */ iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank', // force usage of iframe in non-IE browsers (handy for blocking applets) forceIframe: false, // z-index for the blocking overlay baseZ: 1000, // set these to true to have the message automatically centered centerX: true, // <-- only effects element blocking (page block controlled via css above) centerY: true, // allow body element to be stetched in ie6; this makes blocking look better // on "short" pages. disable if you wish to prevent changes to the body height allowBodyStretch: true, // enable if you want key and mouse events to be disabled for content that is blocked bindEvents: true, // be default blockUI will supress tab navigation from leaving blocking content // (if bindEvents is true) constrainTabKey: true, // fadeIn time in millis; set to 0 to disable fadeIn on block fadeIn: 200, // fadeOut time in millis; set to 0 to disable fadeOut on unblock fadeOut: 400, // time in millis to wait before auto-unblocking; set to 0 to disable auto-unblock timeout: 0, // disable if you don't want to show the overlay showOverlay: true, // if true, focus will be placed in the first available input field when // page blocking focusInput: true, // elements that can receive focus focusableElements: ':input:enabled:visible', // suppresses the use of overlay styles on FF/Linux (due to performance issues with opacity) // no longer needed in 2012 // applyPlatformOpacityRules: true, // callback method invoked when fadeIn has completed and blocking message is visible onBlock: null, // callback method invoked when unblocking has completed; the callback is // passed the element that has been unblocked (which is the window object for page // blocks) and the options that were passed to the unblock call: // onUnblock(element, options) onUnblock: null, // callback method invoked when the overlay area is clicked. // setting this will turn the cursor to a pointer, otherwise cursor defined in overlayCss will be used. onOverlayClick: null, // don't ask; if you really must know: http://groups.google.com/group/jquery-en/browse_thread/thread/36640a8730503595/2f6a79a77a78e493#2f6a79a77a78e493 quirksmodeOffsetHack: 4, // class name of the message block blockMsgClass: 'blockMsg', // if it is already blocked, then ignore it (don't unblock and reblock) ignoreIfBlocked: false }; // private data and functions follow... var pageBlock = null; var pageBlockEls = []; function install(el, opts) { var css, themedCSS; var full = (el == window); var msg = (opts && opts.message !== undefined ? opts.message : undefined); opts = $.extend({}, $.blockUI.defaults, opts || {}); if (opts.ignoreIfBlocked && $(el).data('blockUI.isBlocked')) return; opts.overlayCSS = $.extend({}, $.blockUI.defaults.overlayCSS, opts.overlayCSS || {}); css = $.extend({}, $.blockUI.defaults.css, opts.css || {}); if (opts.onOverlayClick) opts.overlayCSS.cursor = 'pointer'; themedCSS = $.extend({}, $.blockUI.defaults.themedCSS, opts.themedCSS || {}); msg = msg === undefined ? opts.message : msg; // remove the current block (if there is one) if (full && pageBlock) remove(window, {fadeOut:0}); // if an existing element is being used as the blocking content then we capture // its current place in the DOM (and current display style) so we can restore // it when we unblock if (msg && typeof msg != 'string' && (msg.parentNode || msg.jquery)) { var node = msg.jquery ? msg[0] : msg; var data = {}; $(el).data('blockUI.history', data); data.el = node; data.parent = node.parentNode; data.display = node.style.display; data.position = node.style.position; if (data.parent) data.parent.removeChild(node); } $(el).data('blockUI.onUnblock', opts.onUnblock); var z = opts.baseZ; // blockUI uses 3 layers for blocking, for simplicity they are all used on every platform; // layer1 is the iframe layer which is used to supress bleed through of underlying content // layer2 is the overlay layer which has opacity and a wait cursor (by default) // layer3 is the message content that is displayed while blocking var lyr1, lyr2, lyr3, s; if (msie || opts.forceIframe) lyr1 = $(''); else lyr1 = $('
'); if (opts.theme) lyr2 = $('
'); else lyr2 = $('
'); if (opts.theme && full) { s = '
'; if ( opts.title ) { s += '
'+(opts.title || ' ')+'
'; } s += '
'; s += '
'; } else if (opts.theme) { s = '
'; if ( opts.title ) { s += '
'+(opts.title || ' ')+'
'; } s += '
'; s += '
'; } else if (full) { s = '
'; } else { s = '
'; } lyr3 = $(s); // if we have a message, style it if (msg) { if (opts.theme) { lyr3.css(themedCSS); lyr3.addClass('ui-widget-content'); } else lyr3.css(css); } // style the overlay if (!opts.theme /*&& (!opts.applyPlatformOpacityRules)*/) lyr2.css(opts.overlayCSS); lyr2.css('position', full ? 'fixed' : 'absolute'); // make iframe layer transparent in IE if (msie || opts.forceIframe) lyr1.css('opacity',0.0); //$([lyr1[0],lyr2[0],lyr3[0]]).appendTo(full ? 'body' : el); var layers = [lyr1,lyr2,lyr3], $par = full ? $('body') : $(el); $.each(layers, function() { this.appendTo($par); }); if (opts.theme && opts.draggable && $.fn.draggable) { lyr3.draggable({ handle: '.ui-dialog-titlebar', cancel: 'li' }); } // ie7 must use absolute positioning in quirks mode and to account for activex issues (when scrolling) var expr = setExpr && (!$.support.boxModel || $('object,embed', full ? null : el).length > 0); if (ie6 || expr) { // give body 100% height if (full && opts.allowBodyStretch && $.support.boxModel) $('html,body').css('height','100%'); // fix ie6 issue when blocked element has a border width if ((ie6 || !$.support.boxModel) && !full) { var t = sz(el,'borderTopWidth'), l = sz(el,'borderLeftWidth'); var fixT = t ? '(0 - '+t+')' : 0; var fixL = l ? '(0 - '+l+')' : 0; } // simulate fixed position $.each(layers, function(i,o) { var s = o[0].style; s.position = 'absolute'; if (i < 2) { if (full) s.setExpression('height','Math.max(document.body.scrollHeight, document.body.offsetHeight) - (jQuery.support.boxModel?0:'+opts.quirksmodeOffsetHack+') + "px"'); else s.setExpression('height','this.parentNode.offsetHeight + "px"'); if (full) s.setExpression('width','jQuery.support.boxModel && document.documentElement.clientWidth || document.body.clientWidth + "px"'); else s.setExpression('width','this.parentNode.offsetWidth + "px"'); if (fixL) s.setExpression('left', fixL); if (fixT) s.setExpression('top', fixT); } else if (opts.centerY) { if (full) s.setExpression('top','(document.documentElement.clientHeight || document.body.clientHeight) / 2 - (this.offsetHeight / 2) + (blah = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + "px"'); s.marginTop = 0; } else if (!opts.centerY && full) { var top = (opts.css && opts.css.top) ? parseInt(opts.css.top, 10) : 0; var expression = '((document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + '+top+') + "px"'; s.setExpression('top',expression); } }); } // show the message if (msg) { if (opts.theme) lyr3.find('.ui-widget-content').append(msg); else lyr3.append(msg); if (msg.jquery || msg.nodeType) $(msg).show(); } if ((msie || opts.forceIframe) && opts.showOverlay) lyr1.show(); // opacity is zero if (opts.fadeIn) { var cb = opts.onBlock ? opts.onBlock : noOp; var cb1 = (opts.showOverlay && !msg) ? cb : noOp; var cb2 = msg ? cb : noOp; if (opts.showOverlay) lyr2._fadeIn(opts.fadeIn, cb1); if (msg) lyr3._fadeIn(opts.fadeIn, cb2); } else { if (opts.showOverlay) lyr2.show(); if (msg) lyr3.show(); if (opts.onBlock) opts.onBlock.bind(lyr3)(); } // bind key and mouse events bind(1, el, opts); if (full) { pageBlock = lyr3[0]; pageBlockEls = $(opts.focusableElements,pageBlock); if (opts.focusInput) setTimeout(focus, 20); } else center(lyr3[0], opts.centerX, opts.centerY); if (opts.timeout) { // auto-unblock var to = setTimeout(function() { if (full) $.unblockUI(opts); else $(el).unblock(opts); }, opts.timeout); $(el).data('blockUI.timeout', to); } } // remove the block function remove(el, opts) { var count; var full = (el == window); var $el = $(el); var data = $el.data('blockUI.history'); var to = $el.data('blockUI.timeout'); if (to) { clearTimeout(to); $el.removeData('blockUI.timeout'); } opts = $.extend({}, $.blockUI.defaults, opts || {}); bind(0, el, opts); // unbind events if (opts.onUnblock === null) { opts.onUnblock = $el.data('blockUI.onUnblock'); $el.removeData('blockUI.onUnblock'); } var els; if (full) // crazy selector to handle odd field errors in ie6/7 els = $('body').children().filter('.blockUI').add('body > .blockUI'); else els = $el.find('>.blockUI'); // fix cursor issue if ( opts.cursorReset ) { if ( els.length > 1 ) els[1].style.cursor = opts.cursorReset; if ( els.length > 2 ) els[2].style.cursor = opts.cursorReset; } if (full) pageBlock = pageBlockEls = null; if (opts.fadeOut) { count = els.length; els.stop().fadeOut(opts.fadeOut, function() { if ( --count === 0) reset(els,data,opts,el); }); } else reset(els, data, opts, el); } // move blocking element back into the DOM where it started function reset(els,data,opts,el) { var $el = $(el); if ( $el.data('blockUI.isBlocked') ) return; els.each(function(i,o) { // remove via DOM calls so we don't lose event handlers if (this.parentNode) this.parentNode.removeChild(this); }); if (data && data.el) { data.el.style.display = data.display; data.el.style.position = data.position; data.el.style.cursor = 'default'; // #59 if (data.parent) data.parent.appendChild(data.el); $el.removeData('blockUI.history'); } if ($el.data('blockUI.static')) { $el.css('position', 'static'); // #22 } if (typeof opts.onUnblock == 'function') opts.onUnblock(el,opts); // fix issue in Safari 6 where block artifacts remain until reflow var body = $(document.body), w = body.width(), cssW = body[0].style.width; body.width(w-1).width(w); body[0].style.width = cssW; } // bind/unbind the handler function bind(b, el, opts) { var full = el == window, $el = $(el); // don't bother unbinding if there is nothing to unbind if (!b && (full && !pageBlock || !full && !$el.data('blockUI.isBlocked'))) return; $el.data('blockUI.isBlocked', b); // don't bind events when overlay is not in use or if bindEvents is false if (!full || !opts.bindEvents || (b && !opts.showOverlay)) return; // bind anchors and inputs for mouse and key events var events = 'mousedown mouseup keydown keypress keyup touchstart touchend touchmove'; if (b) $(document).bind(events, opts, handler); else $(document).unbind(events, handler); // former impl... // var $e = $('a,:input'); // b ? $e.bind(events, opts, handler) : $e.unbind(events, handler); } // event handler to suppress keyboard/mouse events when blocking function handler(e) { // allow tab navigation (conditionally) if (e.type === 'keydown' && e.keyCode && e.keyCode == 9) { if (pageBlock && e.data.constrainTabKey) { var els = pageBlockEls; var fwd = !e.shiftKey && e.target === els[els.length-1]; var back = e.shiftKey && e.target === els[0]; if (fwd || back) { setTimeout(function(){focus(back);},10); return false; } } } var opts = e.data; var target = $(e.target); if (target.hasClass('blockOverlay') && opts.onOverlayClick) opts.onOverlayClick(e); // allow events within the message content if (target.parents('div.' + opts.blockMsgClass).length > 0) return true; // allow events for content that is not being blocked return target.parents().children().filter('div.blockUI').length === 0; } function focus(back) { if (!pageBlockEls) return; var e = pageBlockEls[back===true ? pageBlockEls.length-1 : 0]; if (e) e.focus(); } function center(el, x, y) { var p = el.parentNode, s = el.style; var l = ((p.offsetWidth - el.offsetWidth)/2) - sz(p,'borderLeftWidth'); var t = ((p.offsetHeight - el.offsetHeight)/2) - sz(p,'borderTopWidth'); if (x) s.left = l > 0 ? (l+'px') : '0'; if (y) s.top = t > 0 ? (t+'px') : '0'; } function sz(el, p) { return parseInt($.css(el,p),10)||0; } } /*global define:true */ if (typeof define === 'function' && define.amd && define.amd.jQuery) { define(['jquery'], setup); } else { setup(jQuery); } })(); ; /* /web/static/lib/jquery.hotkeys/jquery.hotkeys.js defined in bundle 'web.assetsCommon' */ /* * jQuery Hotkeys Plugin * Copyright 2010, John Resig * Dual licensed under the MIT or GPL Version 2 licenses. * * Based upon the plugin by Tzury Bar Yochay: * http://github.com/tzuryby/hotkeys * * Original idea by: * Binny V A, http://www.openjs.com/scripts/events/keyboard_shortcuts/ */ (function(jQuery){ jQuery.hotkeys = { version: "0.8", specialKeys: { 8: "backspace", 9: "tab", 13: "return", 16: "shift", 17: "ctrl", 18: "alt", 19: "pause", 20: "capslock", 27: "esc", 32: "space", 33: "pageup", 34: "pagedown", 35: "end", 36: "home", 37: "left", 38: "up", 39: "right", 40: "down", 45: "insert", 46: "del", 96: "0", 97: "1", 98: "2", 99: "3", 100: "4", 101: "5", 102: "6", 103: "7", 104: "8", 105: "9", 106: "*", 107: "+", 109: "-", 110: ".", 111 : "/", 112: "f1", 113: "f2", 114: "f3", 115: "f4", 116: "f5", 117: "f6", 118: "f7", 119: "f8", 120: "f9", 121: "f10", 122: "f11", 123: "f12", 144: "numlock", 145: "scroll", 191: "/", 224: "meta" }, shiftNums: { "`": "~", "1": "!", "2": "@", "3": "#", "4": "$", "5": "%", "6": "^", "7": "&", "8": "*", "9": "(", "0": ")", "-": "_", "=": "+", ";": ": ", "'": "\"", ",": "<", ".": ">", "/": "?", "\\": "|" } }; function keyHandler( handleObj ) { // Only care when a possible input has been specified if ( typeof handleObj.data !== "string" ) { return; } var origHandler = handleObj.handler, keys = handleObj.data.toLowerCase().split(" "); handleObj.handler = function( event ) { // Don't fire in text-accepting inputs that we didn't directly bind to if ( this !== event.target && (/textarea|select/i.test( event.target.nodeName ) || event.target.type === "text") ) { return; } // Keypress represents characters, not special keys var special = event.type !== "keypress" && jQuery.hotkeys.specialKeys[ event.which ], character = String.fromCharCode( event.which ).toLowerCase(), key, modif = "", possible = {}; // check combinations (alt|ctrl|shift+anything) if ( event.altKey && special !== "alt" ) { modif += "alt+"; } if ( event.ctrlKey && special !== "ctrl" ) { modif += "ctrl+"; } // TODO: Need to make sure this works consistently across platforms if ( event.metaKey && !event.ctrlKey && special !== "meta" ) { modif += "meta+"; } if ( event.shiftKey && special !== "shift" ) { modif += "shift+"; } if ( special ) { possible[ modif + special ] = true; } else { possible[ modif + character ] = true; possible[ modif + jQuery.hotkeys.shiftNums[ character ] ] = true; // "$" can be triggered as "Shift+4" or "Shift+$" or just "$" if ( modif === "shift+" ) { possible[ jQuery.hotkeys.shiftNums[ character ] ] = true; } } for ( var i = 0, l = keys.length; i < l; i++ ) { if ( possible[ keys[i] ] ) { return origHandler.apply( this, arguments ); } } }; } jQuery.each([ "keydown", "keyup", "keypress" ], function() { jQuery.event.special[ this ] = { add: keyHandler }; }); })( jQuery );; /* /web/static/lib/jquery.placeholder/jquery.placeholder.js defined in bundle 'web.assetsCommon' */ /*! http://mths.be/placeholder v2.0.7 by @mathias */ ;(function(window, document, $) { var isInputSupported = 'placeholder' in document.createElement('input'), isTextareaSupported = 'placeholder' in document.createElement('textarea'), prototype = $.fn, valHooks = $.valHooks, hooks, placeholder; if (isInputSupported && isTextareaSupported) { placeholder = prototype.placeholder = function() { return this; }; placeholder.input = placeholder.textarea = true; } else { placeholder = prototype.placeholder = function() { var $this = this; $this .filter((isInputSupported ? 'textarea' : ':input') + '[placeholder]') .not('.placeholder') .bind({ 'focus.placeholder': clearPlaceholder, 'blur.placeholder': setPlaceholder }) .data('placeholder-enabled', true) .trigger('blur.placeholder'); return $this; }; placeholder.input = isInputSupported; placeholder.textarea = isTextareaSupported; hooks = { 'get': function(element) { var $element = $(element); return $element.data('placeholder-enabled') && $element.hasClass('placeholder') ? '' : element.value; }, 'set': function(element, value) { var $element = $(element); if (!$element.data('placeholder-enabled')) { return element.value = value; } if (value == '') { element.value = value; // Issue #56: Setting the placeholder causes problems if the element continues to have focus. if (element != document.activeElement) { // We can't use `triggerHandler` here because of dummy text/password inputs :( setPlaceholder.call(element); } } else if ($element.hasClass('placeholder')) { clearPlaceholder.call(element, true, value) || (element.value = value); } else { element.value = value; } // `set` can not return `undefined`; see http://jsapi.info/jquery/1.7.1/val#L2363 return $element; } }; isInputSupported || (valHooks.input = hooks); isTextareaSupported || (valHooks.textarea = hooks); $(function() { // Look for forms $(document).delegate('form', 'submit.placeholder', function() { // Clear the placeholder values so they don't get submitted var $inputs = $('.placeholder', this).each(clearPlaceholder); setTimeout(function() { $inputs.each(setPlaceholder); }, 10); }); }); // Clear placeholder values upon page reload $(window).bind('beforeunload.placeholder', function() { $('.placeholder').each(function() { this.value = ''; }); }); } function args(elem) { // Return an object of element attributes var newAttrs = {}, rinlinejQuery = /^jQuery\d+$/; $.each(elem.attributes, function(i, attr) { if (attr.specified && !rinlinejQuery.test(attr.name)) { newAttrs[attr.name] = attr.value; } }); return newAttrs; } function clearPlaceholder(event, value) { var input = this, $input = $(input); if (input.value == $input.attr('placeholder') && $input.hasClass('placeholder')) { if ($input.data('placeholder-password')) { $input = $input.hide().next().show().attr('id', $input.removeAttr('id').data('placeholder-id')); // If `clearPlaceholder` was called from `$.valHooks.input.set` if (event === true) { return $input[0].value = value; } $input.focus(); } else { input.value = ''; $input.removeClass('placeholder'); input == document.activeElement && input.select(); } } } function setPlaceholder() { var $replacement, input = this, $input = $(input), $origInput = $input, id = this.id; if (input.value == '') { if (input.type == 'password') { if (!$input.data('placeholder-textinput')) { try { $replacement = $input.clone().attr({ 'type': 'text' }); } catch(e) { $replacement = $('
').attr($.extend(args(this), { 'type': 'text' })); } $replacement .removeAttr('name') .data({ 'placeholder-password': true, 'placeholder-id': id }) .bind('focus.placeholder', clearPlaceholder); $input .data({ 'placeholder-textinput': $replacement, 'placeholder-id': id }) .before($replacement); } $input = $input.removeAttr('id').hide().prev().attr('id', id).show(); // Note: `$input[0] != input` now! } $input.addClass('placeholder'); $input[0].value = $input.attr('placeholder'); } else { $input.removeClass('placeholder'); } } }(this, document, jQuery));; /* /web/static/lib/jquery.form/jquery.form.js defined in bundle 'web.assetsCommon' */ /*! * jQuery Form Plugin * version: 3.51.0-2014.06.20 * Requires jQuery v1.5 or later * Copyright (c) 2014 M. Alsup * Examples and documentation at: http://malsup.com/jquery/form/ * Project repository: https://github.com/malsup/form * Dual licensed under the MIT and GPL licenses. * https://github.com/malsup/form#copyright-and-license */ /*global ActiveXObject */ // AMD support (function (factory) { "use strict"; if (typeof define === 'function' && define.amd) { // using AMD; register as anon module define(['jquery'], factory); } else { // no AMD; invoke directly factory( (typeof(jQuery) != 'undefined') ? jQuery : window.Zepto ); } } (function($) { "use strict"; /* Usage Note: ----------- Do not use both ajaxSubmit and ajaxForm on the same form. These functions are mutually exclusive. Use ajaxSubmit if you want to bind your own submit handler to the form. For example, $(document).ready(function() { $('#myForm').on('submit', function(e) { e.preventDefault(); // <-- important $(this).ajaxSubmit({ target: '#output' }); }); }); Use ajaxForm when you want the plugin to manage all the event binding for you. For example, $(document).ready(function() { $('#myForm').ajaxForm({ target: '#output' }); }); You can also use ajaxForm with delegation (requires jQuery v1.7+), so the form does not have to exist when you invoke ajaxForm: $('#myForm').ajaxForm({ delegation: true, target: '#output' }); When using ajaxForm, the ajaxSubmit function will be invoked for you at the appropriate time. */ /** * Feature detection */ var feature = {}; feature.fileapi = $("No file chosen").get(0).files !== undefined; feature.formdata = window.FormData !== undefined; var hasProp = !!$.fn.prop; // attr2 uses prop when it can but checks the return type for // an expected string. this accounts for the case where a form // contains inputs with names like "action" or "method"; in those // cases "prop" returns the element $.fn.attr2 = function() { if ( ! hasProp ) { return this.attr.apply(this, arguments); } var val = this.prop.apply(this, arguments); if ( ( val && val.jquery ) || typeof val === 'string' ) { return val; } return this.attr.apply(this, arguments); }; /** * ajaxSubmit() provides a mechanism for immediately submitting * an HTML form using AJAX. */ $.fn.ajaxSubmit = function(options) { /*jshint scripturl:true */ // fast fail if nothing selected (http://dev.jquery.com/ticket/2752) if (!this.length) { log('ajaxSubmit: skipping submit process - no element selected'); return this; } var method, action, url, $form = this; if (typeof options == 'function') { options = { success: options }; } else if ( options === undefined ) { options = {}; } method = options.type || this.attr2('method'); action = options.url || this.attr2('action'); url = (typeof action === 'string') ? $.trim(action) : ''; url = url || window.location.href || ''; if (url) { // clean url (don't include hash vaue) url = (url.match(/^([^#]+)/)||[])[1]; } options = $.extend(true, { url: url, success: $.ajaxSettings.success, type: method || $.ajaxSettings.type, iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank' }, options); // hook for manipulating the form data before it is extracted; // convenient for use with rich editors like tinyMCE or FCKEditor var veto = {}; this.trigger('form-pre-serialize', [this, options, veto]); if (veto.veto) { log('ajaxSubmit: submit vetoed via form-pre-serialize trigger'); return this; } // provide opportunity to alter form data before it is serialized if (options.beforeSerialize && options.beforeSerialize(this, options) === false) { log('ajaxSubmit: submit aborted via beforeSerialize callback'); return this; } var traditional = options.traditional; if ( traditional === undefined ) { traditional = $.ajaxSettings.traditional; } var elements = []; var qx, a = this.formToArray(options.semantic, elements); if (options.data) { options.extraData = options.data; qx = $.param(options.data, traditional); } // give pre-submit callback an opportunity to abort the submit if (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) { log('ajaxSubmit: submit aborted via beforeSubmit callback'); return this; } // fire vetoable 'validate' event this.trigger('form-submit-validate', [a, this, options, veto]); if (veto.veto) { log('ajaxSubmit: submit vetoed via form-submit-validate trigger'); return this; } var q = $.param(a, traditional); if (qx) { q = ( q ? (q + '&' + qx) : qx ); } if (options.type.toUpperCase() == 'GET') { options.url += (options.url.indexOf('?') >= 0 ? '&' : '?') + q; options.data = null; // data is null for 'get' } else { options.data = q; // data is the query string for 'post' } var callbacks = []; if (options.resetForm) { callbacks.push(function() { $form.resetForm(); }); } if (options.clearForm) { callbacks.push(function() { $form.clearForm(options.includeHidden); }); } // perform a load on the target only if dataType is not provided if (!options.dataType && options.target) { var oldSuccess = options.success || function(){}; callbacks.push(function(data) { var fn = options.replaceTarget ? 'replaceWith' : 'html'; $(options.target)[fn](data).each(oldSuccess, arguments); }); } else if (options.success) { callbacks.push(options.success); } options.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg var context = options.context || this ; // jQuery 1.4+ supports scope context for (var i=0, max=callbacks.length; i < max; i++) { callbacks[i].apply(context, [data, status, xhr || $form, $form]); } }; if (options.error) { var oldError = options.error; options.error = function(xhr, status, error) { var context = options.context || this; oldError.apply(context, [xhr, status, error, $form]); }; } if (options.complete) { var oldComplete = options.complete; options.complete = function(xhr, status) { var context = options.context || this; oldComplete.apply(context, [xhr, status, $form]); }; } // are there files to upload? // [value] (issue #113), also see comment: // https://github.com/malsup/form/commit/588306aedba1de01388032d5f42a60159eea9228#commitcomment-2180219 var fileInputs = $('input[type=file]:enabled', this).filter(function() { return $(this).val() !== ''; }); var hasFileInputs = fileInputs.length > 0; var mp = 'multipart/form-data'; var multipart = ($form.attr('enctype') == mp || $form.attr('encoding') == mp); var fileAPI = feature.fileapi && feature.formdata; log("fileAPI :" + fileAPI); var shouldUseFrame = (hasFileInputs || multipart) && !fileAPI; var jqxhr; // options.iframe allows user to force iframe mode // 06-NOV-09: now defaulting to iframe mode if file input is detected if (options.iframe !== false && (options.iframe || shouldUseFrame)) { // hack to fix Safari hang (thanks to Tim Molendijk for this) // see: http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d if (options.closeKeepAlive) { $.get(options.closeKeepAlive, function() { jqxhr = fileUploadIframe(a); }); } else { jqxhr = fileUploadIframe(a); } } else if ((hasFileInputs || multipart) && fileAPI) { jqxhr = fileUploadXhr(a); } else { jqxhr = $.ajax(options); } $form.removeData('jqxhr').data('jqxhr', jqxhr); // clear element array for (var k=0; k < elements.length; k++) { elements[k] = null; } // fire 'notify' event this.trigger('form-submit-notify', [this, options]); return this; // utility fn for deep serialization function deepSerialize(extraData){ var serialized = $.param(extraData, options.traditional).split('&'); var len = serialized.length; var result = []; var i, part; for (i=0; i < len; i++) { // #252; undo param space replacement serialized[i] = serialized[i].replace(/\+/g,' '); part = serialized[i].split('='); // #278; use array instead of object storage, favoring array serializations result.push([decodeURIComponent(part[0]), decodeURIComponent(part[1])]); } return result; } // XMLHttpRequest Level 2 file uploads (big hat tip to francois2metz) function fileUploadXhr(a) { var formdata = new FormData(); for (var i=0; i < a.length; i++) { formdata.append(a[i].name, a[i].value); } if (options.extraData) { var serializedData = deepSerialize(options.extraData); for (i=0; i < serializedData.length; i++) { if (serializedData[i]) { formdata.append(serializedData[i][0], serializedData[i][1]); } } } options.data = null; var s = $.extend(true, {}, $.ajaxSettings, options, { contentType: false, processData: false, cache: false, type: method || 'POST' }); if (options.uploadProgress) { // workaround because jqXHR does not expose upload property s.xhr = function() { var xhr = $.ajaxSettings.xhr(); if (xhr.upload) { xhr.upload.addEventListener('progress', function(event) { var percent = 0; var position = event.loaded || event.position; /*event.position is deprecated*/ var total = event.total; if (event.lengthComputable) { percent = Math.ceil(position / total * 100); } options.uploadProgress(event, position, total, percent); }, false); } return xhr; }; } s.data = null; var beforeSend = s.beforeSend; s.beforeSend = function(xhr, o) { //Send FormData() provided by user if (options.formData) { o.data = options.formData; } else { o.data = formdata; } if(beforeSend) { beforeSend.call(this, xhr, o); } }; return $.ajax(s); } // private function for handling file uploads (hat tip to YAHOO!) function fileUploadIframe(a) { var form = $form[0], el, i, s, g, id, $io, io, xhr, sub, n, timedOut, timeoutHandle; var deferred = $.Deferred(); // #341 deferred.abort = function(status) { xhr.abort(status); }; if (a) { // ensure that every serialized input is still enabled for (i=0; i < elements.length; i++) { el = $(elements[i]); if ( hasProp ) { el.prop('disabled', false); } else { el.removeAttr('disabled'); } } } s = $.extend(true, {}, $.ajaxSettings, options); s.context = s.context || s; id = 'jqFormIO' + (new Date().getTime()); if (s.iframeTarget) { $io = $(s.iframeTarget); n = $io.attr2('name'); if (!n) { $io.attr2('name', id); } else { id = n; } } else { $io = $('